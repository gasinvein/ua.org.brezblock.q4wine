From 20eb41288cc34afdf032f12c34c00b9fbd136a5f Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 13 Jun 2018 10:44:49 -0500
Subject: [PATCH 01/83] configure: Check for sys/eventfd.h, ppoll(), and
 shm_open().

We use ppoll() instead of poll() for the better time granularity.

Although perhaps we shouldn't since the server doesn't do this.
---
 configure           | 68 +++++++++++++++++++++++++++++++++++++++++++++
 configure.ac        | 12 ++++++++
 include/config.h.in |  9 ++++++
 3 files changed, 89 insertions(+)

diff --git a/configure b/configure
index 4ab39a48aa..649a8917f5 100755
--- a/configure
+++ b/configure
@@ -7332,6 +7332,7 @@ for ac_header in \
 	sys/elf32.h \
 	sys/epoll.h \
 	sys/event.h \
+	sys/eventfd.h \
 	sys/exec_elf.h \
 	sys/filio.h \
 	sys/inotify.h \
@@ -16677,6 +16678,7 @@ for ac_func in \
 	poll \
 	popen \
 	port_create \
+	ppoll \
 	prctl \
 	pread \
 	proc_pidinfo \
@@ -17089,6 +17091,72 @@ fi
 
 LIBS=$ac_save_LIBS
 
+if test "$ac_cv_header_sys_mman_h" = "yes" -a "x$RT_LIBS" = "x"
+then
+    ac_save_LIBS=$LIBS
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing shm_open" >&5
+$as_echo_n "checking for library containing shm_open... " >&6; }
+if ${ac_cv_search_shm_open+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char shm_open ();
+int
+main ()
+{
+return shm_open ();
+  ;
+  return 0;
+}
+_ACEOF
+for ac_lib in '' rt; do
+  if test -z "$ac_lib"; then
+    ac_res="none required"
+  else
+    ac_res=-l$ac_lib
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+  fi
+  if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_search_shm_open=$ac_res
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext
+  if ${ac_cv_search_shm_open+:} false; then :
+  break
+fi
+done
+if ${ac_cv_search_shm_open+:} false; then :
+
+else
+  ac_cv_search_shm_open=no
+fi
+rm conftest.$ac_ext
+LIBS=$ac_func_search_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_shm_open" >&5
+$as_echo "$ac_cv_search_shm_open" >&6; }
+ac_res=$ac_cv_search_shm_open
+if test "$ac_res" != no; then :
+  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
+
+$as_echo "#define HAVE_SHM_OPEN 1" >>confdefs.h
+
+                    test "$ac_res" = "none required" || RT_LIBS="$ac_res"
+
+fi
+
+fi
+LIBS=$ac_save_LIBS
+
 if test "x$with_ldap" != "xno"
 then
         if ${LDAP_CFLAGS:+false} :; then :
diff --git a/configure.ac b/configure.ac
index 60f8accf16..704da15f40 100644
--- a/configure.ac
+++ b/configure.ac
@@ -497,6 +497,7 @@ AC_CHECK_HEADERS(\
 	sys/elf32.h \
 	sys/epoll.h \
 	sys/event.h \
+	sys/eventfd.h \
 	sys/exec_elf.h \
 	sys/filio.h \
 	sys/inotify.h \
@@ -2187,6 +2188,7 @@ AC_CHECK_FUNCS(\
 	poll \
 	popen \
 	port_create \
+	ppoll \
 	prctl \
 	pread \
 	proc_pidinfo \
@@ -2267,6 +2269,16 @@ AC_SEARCH_LIBS(clock_gettime, rt,
                 test "$ac_res" = "none required" || AC_SUBST(RT_LIBS,"$ac_res")])
 LIBS=$ac_save_LIBS
 
+dnl Check for shm_open which may be in -lrt
+if test "$ac_cv_header_sys_mman_h" = "yes" -a "x$RT_LIBS" = "x"
+then
+    ac_save_LIBS=$LIBS
+    AC_SEARCH_LIBS(shm_open, rt,
+                   [AC_DEFINE(HAVE_SHM_OPEN, 1, [Define to 1 if you have the `shm_open' function.])
+                    test "$ac_res" = "none required" || AC_SUBST(RT_LIBS,"$ac_res")])
+fi
+LIBS=$ac_save_LIBS
+
 dnl **** Check for OpenLDAP ***
 if test "x$with_ldap" != "xno"
 then
diff --git a/include/config.h.in b/include/config.h.in
index c5a3cb4807..1ba9efb29e 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -750,6 +750,9 @@
 /* Define if we can use ppdev.h for parallel port access */
 #undef HAVE_PPDEV
 
+/* Define to 1 if you have the `ppoll' function. */
+#undef HAVE_PPOLL
+
 /* Define to 1 if you have the `prctl' function. */
 #undef HAVE_PRCTL
 
@@ -876,6 +879,9 @@
 /* Define to 1 if `interface_id' is a member of `sg_io_hdr_t'. */
 #undef HAVE_SG_IO_HDR_T_INTERFACE_ID
 
+/* Define to 1 if you have the `shm_open' function. */
+#undef HAVE_SHM_OPEN
+
 /* Define if sigaddset is supported */
 #undef HAVE_SIGADDSET
 
@@ -1107,6 +1113,9 @@
 /* Define to 1 if you have the <sys/epoll.h> header file. */
 #undef HAVE_SYS_EPOLL_H
 
+/* Define to 1 if you have the <sys/eventfd.h> header file. */
+#undef HAVE_SYS_EVENTFD_H
+
 /* Define to 1 if you have the <sys/event.h> header file. */
 #undef HAVE_SYS_EVENT_H
 
-- 
2.20.1


From 2ad90343529a4787a7d9a160b4fb1362a67707f0 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 7 Jun 2018 20:09:59 -0500
Subject: [PATCH 02/83] server: Create server objects for eventfd-based
 synchronization objects.

---
 include/wine/server_protocol.h |  19 +++++
 server/Makefile.in             |   1 +
 server/esync.c                 | 136 +++++++++++++++++++++++++++++++++
 server/protocol.def            |  10 +++
 server/request.h               |   8 ++
 server/trace.c                 |  16 ++++
 6 files changed, 190 insertions(+)
 create mode 100644 server/esync.c

diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index 63f65cd00f..22eec04a38 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -5665,6 +5665,22 @@ struct terminate_job_reply
 };
 
 
+struct create_esync_request
+{
+    struct request_header __header;
+    unsigned int access;
+    int          initval;
+    int          flags;
+    /* VARARG(objattr,object_attributes); */
+};
+struct create_esync_reply
+{
+    struct reply_header __header;
+    obj_handle_t handle;
+    char __pad_12[4];
+};
+
+
 enum request
 {
     REQ_new_process,
@@ -5958,6 +5974,7 @@ enum request
     REQ_set_job_limits,
     REQ_set_job_completion_port,
     REQ_terminate_job,
+    REQ_create_esync,
     REQ_NB_REQUESTS
 };
 
@@ -6256,6 +6273,7 @@ union generic_request
     struct set_job_limits_request set_job_limits_request;
     struct set_job_completion_port_request set_job_completion_port_request;
     struct terminate_job_request terminate_job_request;
+    struct create_esync_request create_esync_request;
 };
 union generic_reply
 {
@@ -6552,6 +6570,7 @@ union generic_reply
     struct set_job_limits_reply set_job_limits_reply;
     struct set_job_completion_port_reply set_job_completion_port_reply;
     struct terminate_job_reply terminate_job_reply;
+    struct create_esync_reply create_esync_reply;
 };
 
 #define SERVER_PROTOCOL_VERSION 572
diff --git a/server/Makefile.in b/server/Makefile.in
index 29f17f3157..f23f577f0d 100644
--- a/server/Makefile.in
+++ b/server/Makefile.in
@@ -11,6 +11,7 @@ C_SRCS = \
 	debugger.c \
 	device.c \
 	directory.c \
+	esync.c \
 	event.c \
 	fd.c \
 	file.c \
diff --git a/server/esync.c b/server/esync.c
new file mode 100644
index 0000000000..66cae244f6
--- /dev/null
+++ b/server/esync.c
@@ -0,0 +1,136 @@
+/*
+ * eventfd-based synchronization objects
+ *
+ * Copyright (C) 2018 Zebediah Figura
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+#include "wine/port.h"
+
+#include <stdio.h>
+#include <stdarg.h>
+#ifdef HAVE_SYS_EVENTFD_H
+# include <sys/eventfd.h>
+#endif
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winternl.h"
+
+#include "handle.h"
+#include "request.h"
+#include "file.h"
+
+struct esync
+{
+    struct object   obj;    /* object header */
+    int             fd;     /* eventfd file descriptor */
+};
+
+static void esync_dump( struct object *obj, int verbose );
+static void esync_destroy( struct object *obj );
+
+static const struct object_ops esync_ops =
+{
+    sizeof(struct esync),      /* size */
+    esync_dump,                /* dump */
+    no_get_type,               /* get_type */
+    no_add_queue,              /* add_queue */
+    NULL,                      /* remove_queue */
+    NULL,                      /* signaled */
+    NULL,                      /* satisfied */
+    no_signal,                 /* signal */
+    no_get_fd,                 /* get_fd */
+    no_map_access,             /* map_access */
+    default_get_sd,            /* get_sd */
+    default_set_sd,            /* set_sd */
+    no_lookup_name,            /* lookup_name */
+    directory_link_name,       /* link_name */
+    default_unlink_name,       /* unlink_name */
+    no_open_file,              /* open_file */
+    no_close_handle,           /* close_handle */
+    esync_destroy              /* destroy */
+};
+
+static void esync_dump( struct object *obj, int verbose )
+{
+    struct esync *esync = (struct esync *)obj;
+    assert( obj->ops == &esync_ops );
+    fprintf( stderr, "esync fd=%d\n", esync->fd );
+}
+
+static void esync_destroy( struct object *obj )
+{
+    struct esync *esync = (struct esync *)obj;
+    close( esync->fd );
+}
+
+struct esync *create_esync( struct object *root, const struct unicode_str *name,
+                            unsigned int attr, int initval, int flags,
+                            const struct security_descriptor *sd )
+{
+#ifdef HAVE_SYS_EVENTFD_H
+    struct esync *esync;
+
+    if ((esync = create_named_object( root, &esync_ops, name, attr, sd )))
+    {
+        if (get_error() != STATUS_OBJECT_NAME_EXISTS)
+        {
+            /* initialize it if it didn't already exist */
+            esync->fd = eventfd( initval, flags | EFD_CLOEXEC | EFD_NONBLOCK );
+            if (esync->fd == -1)
+            {
+                perror( "eventfd" );
+                file_set_error();
+                release_object( esync );
+                return NULL;
+            }
+        }
+    }
+    return esync;
+#else
+    /* FIXME: Provide a fallback implementation using pipe(). */
+    set_error( STATUS_NOT_IMPLEMENTED );
+    return NULL;
+#endif
+}
+
+DECL_HANDLER(create_esync)
+{
+    struct esync *esync;
+    struct unicode_str name;
+    struct object *root;
+    const struct security_descriptor *sd;
+    const struct object_attributes *objattr = get_req_object_attributes( &sd, &name, &root );
+
+    if (!objattr) return;
+
+    if ((esync = create_esync( root, &name, objattr->attributes, req->initval, req->flags, sd )))
+    {
+        if (get_error() == STATUS_OBJECT_NAME_EXISTS)
+            reply->handle = alloc_handle( current->process, esync, req->access, objattr->attributes );
+        else
+            reply->handle = alloc_handle_no_access_check( current->process, esync,
+                                                          req->access, objattr->attributes );
+
+        send_client_fd( current->process, esync->fd, reply->handle );
+        release_object( esync );
+    }
+
+    if (root) release_object( root );
+}
diff --git a/server/protocol.def b/server/protocol.def
index e65b984a44..7c2887f7f4 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -3863,3 +3863,13 @@ struct handle_info
     obj_handle_t handle;          /* handle to the job */
     int          status;          /* process exit code */
 @END
+
+/* Create a new eventfd-based synchronization object */
+@REQ(create_esync)
+    unsigned int access;        /* wanted access rights */
+    int          initval;       /* initial value */
+    int          flags;         /* flags (EFD_SEMAPHORE or 0) */
+    VARARG(objattr,object_attributes); /* object attributes */
+@REPLY
+    obj_handle_t handle;        /* handle to the object */
+@END
diff --git a/server/request.h b/server/request.h
index 4610ca6868..242143d2c3 100644
--- a/server/request.h
+++ b/server/request.h
@@ -403,6 +403,7 @@ DECL_HANDLER(process_in_job);
 DECL_HANDLER(set_job_limits);
 DECL_HANDLER(set_job_completion_port);
 DECL_HANDLER(terminate_job);
+DECL_HANDLER(create_esync);
 
 #ifdef WANT_REQUEST_HANDLERS
 
@@ -700,6 +701,7 @@ static const req_handler req_handlers[REQ_NB_REQUESTS] =
     (req_handler)req_set_job_limits,
     (req_handler)req_set_job_completion_port,
     (req_handler)req_terminate_job,
+    (req_handler)req_create_esync,
 };
 
 C_ASSERT( sizeof(affinity_t) == 8 );
@@ -2406,6 +2408,12 @@ C_ASSERT( sizeof(struct set_job_completion_port_request) == 32 );
 C_ASSERT( FIELD_OFFSET(struct terminate_job_request, handle) == 12 );
 C_ASSERT( FIELD_OFFSET(struct terminate_job_request, status) == 16 );
 C_ASSERT( sizeof(struct terminate_job_request) == 24 );
+C_ASSERT( FIELD_OFFSET(struct create_esync_request, access) == 12 );
+C_ASSERT( FIELD_OFFSET(struct create_esync_request, initval) == 16 );
+C_ASSERT( FIELD_OFFSET(struct create_esync_request, flags) == 20 );
+C_ASSERT( sizeof(struct create_esync_request) == 24 );
+C_ASSERT( FIELD_OFFSET(struct create_esync_reply, handle) == 8 );
+C_ASSERT( sizeof(struct create_esync_reply) == 16 );
 
 #endif  /* WANT_REQUEST_HANDLERS */
 
diff --git a/server/trace.c b/server/trace.c
index 41bbe4a516..ce8afba720 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -4541,6 +4541,19 @@ static void dump_terminate_job_request( const struct terminate_job_request *req
     fprintf( stderr, ", status=%d", req->status );
 }
 
+static void dump_create_esync_request( const struct create_esync_request *req )
+{
+    fprintf( stderr, " access=%08x", req->access );
+    fprintf( stderr, ", initval=%d", req->initval );
+    fprintf( stderr, ", flags=%d", req->flags );
+    dump_varargs_object_attributes( ", objattr=", cur_size );
+}
+
+static void dump_create_esync_reply( const struct create_esync_reply *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+}
+
 static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_new_process_request,
     (dump_func)dump_exec_process_request,
@@ -4833,6 +4846,7 @@ static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_set_job_limits_request,
     (dump_func)dump_set_job_completion_port_request,
     (dump_func)dump_terminate_job_request,
+    (dump_func)dump_create_esync_request,
 };
 
 static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {
@@ -5127,6 +5141,7 @@ static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {
     NULL,
     NULL,
     NULL,
+    (dump_func)dump_create_esync_reply,
 };
 
 static const char * const req_names[REQ_NB_REQUESTS] = {
@@ -5421,6 +5436,7 @@ static const char * const req_names[REQ_NB_REQUESTS] = {
     "set_job_limits",
     "set_job_completion_port",
     "terminate_job",
+    "create_esync",
 };
 
 static const struct
-- 
2.20.1


From 54fee5bb00729e901720f4c4371815125299ca3a Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 7 Jun 2018 20:29:21 -0500
Subject: [PATCH 03/83] ntdll: Create eventfd-based objects for semaphores.

This patch break things, of course. That is fine. Its purpose is to prevent a Massive Patch Munge.
---
 dlls/ntdll/Makefile.in  |   1 +
 dlls/ntdll/esync.c      | 141 ++++++++++++++++++++++++++++++++++++++++
 dlls/ntdll/esync.h      |  32 +++++++++
 dlls/ntdll/ntdll_misc.h |   1 +
 dlls/ntdll/server.c     |   7 +-
 dlls/ntdll/sync.c       |   5 ++
 6 files changed, 184 insertions(+), 3 deletions(-)
 create mode 100644 dlls/ntdll/esync.c
 create mode 100644 dlls/ntdll/esync.h

diff --git a/dlls/ntdll/Makefile.in b/dlls/ntdll/Makefile.in
index ed4bb94e4d..b75e8308ac 100644
--- a/dlls/ntdll/Makefile.in
+++ b/dlls/ntdll/Makefile.in
@@ -15,6 +15,7 @@ C_SRCS = \
 	directory.c \
 	env.c \
 	error.c \
+	esync.c \
 	exception.c \
 	file.c \
 	handletable.c \
diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
new file mode 100644
index 0000000000..da35bdf854
--- /dev/null
+++ b/dlls/ntdll/esync.c
@@ -0,0 +1,141 @@
+/*
+ * eventfd-based synchronization objects
+ *
+ * Copyright (C) 2018 Zebediah Figura
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include <assert.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#ifdef HAVE_SYS_EVENTFD_H
+# include <sys/eventfd.h>
+#endif
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#define NONAMELESSUNION
+#include "windef.h"
+#include "winternl.h"
+#include "wine/server.h"
+#include "wine/debug.h"
+
+#include "ntdll_misc.h"
+#include "esync.h"
+
+#ifndef EFD_SEMAPHORE
+#define EFD_SEMAPHORE 1
+#endif
+
+WINE_DEFAULT_DEBUG_CHANNEL(esync);
+
+int do_esync(void)
+{
+#ifdef HAVE_SYS_EVENTFD_H
+    static int do_esync_cached = -1;
+
+    if (do_esync_cached == -1)
+        do_esync_cached = (getenv("WINEESYNC") != NULL);
+
+    return do_esync_cached;
+#else
+    static int once;
+    if (!once++)
+        FIXME("eventfd not supported on this platform.\n");
+    return 0;
+#endif
+}
+
+enum esync_type
+{
+    ESYNC_SEMAPHORE = 1,
+};
+
+struct esync
+{
+    enum esync_type type;
+    int fd;
+};
+
+struct semaphore
+{
+    struct esync obj;
+    int max;
+};
+
+static NTSTATUS create_esync(int *fd, HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr, int initval, int flags)
+{
+    NTSTATUS ret;
+    data_size_t len;
+    struct object_attributes *objattr;
+    obj_handle_t fd_handle;
+    sigset_t sigset;
+
+    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
+
+    /* We have to synchronize on the fd cache CS so that our calls to
+     * receive_fd don't race with theirs. */
+    server_enter_uninterrupted_section( &fd_cache_section, &sigset );
+    SERVER_START_REQ( create_esync )
+    {
+        req->access  = access;
+        req->initval = initval;
+        req->flags   = flags;
+        wine_server_add_data( req, objattr, len );
+        ret = wine_server_call( req );
+        if (!ret || ret == STATUS_OBJECT_NAME_EXISTS)
+        {
+            *handle = wine_server_ptr_handle( reply->handle );
+            *fd = receive_fd( &fd_handle );
+            assert( wine_server_ptr_handle(fd_handle) == *handle );
+        }
+    }
+    SERVER_END_REQ;
+    server_leave_uninterrupted_section( &fd_cache_section, &sigset );
+
+    TRACE("-> handle %p, fd %d.\n", *handle, *fd);
+
+    RtlFreeHeap( GetProcessHeap(), 0, objattr );
+    return ret;
+}
+
+extern NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr, LONG initial, LONG max)
+{
+    struct semaphore *semaphore;
+    NTSTATUS ret;
+    int fd = -1;
+
+    TRACE("name %s, initial %d, max %d.\n",
+        attr ? debugstr_us(attr->ObjectName) : "<no name>", initial, max);
+
+    ret = create_esync( &fd, handle, access, attr, initial, EFD_SEMAPHORE );
+    if (!ret || ret == STATUS_OBJECT_NAME_EXISTS)
+    {
+        semaphore = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*semaphore) );
+        if (!semaphore)
+            return STATUS_NO_MEMORY;
+
+        semaphore->obj.type = ESYNC_SEMAPHORE;
+        semaphore->obj.fd = fd;
+        semaphore->max = max;
+    }
+
+    return ret;
+}
diff --git a/dlls/ntdll/esync.h b/dlls/ntdll/esync.h
new file mode 100644
index 0000000000..1a88170cfc
--- /dev/null
+++ b/dlls/ntdll/esync.h
@@ -0,0 +1,32 @@
+/*
+ * eventfd-based synchronization objects
+ *
+ * Copyright (C) 2018 Zebediah Figura
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+extern int do_esync(void) DECLSPEC_HIDDEN;
+
+extern NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr, LONG initial, LONG max) DECLSPEC_HIDDEN;
+
+
+/* We have to synchronize on the fd cache CS so that our calls to receive_fd
+ * don't race with theirs. It looks weird, I know.
+ *
+ * If we weren't trying to avoid touching the code I'd rename the CS to
+ * "server_fd_section" or something similar. */
+extern RTL_CRITICAL_SECTION fd_cache_section;
diff --git a/dlls/ntdll/ntdll_misc.h b/dlls/ntdll/ntdll_misc.h
index 5afb17fe9c..effcd4ce7a 100644
--- a/dlls/ntdll/ntdll_misc.h
+++ b/dlls/ntdll/ntdll_misc.h
@@ -102,6 +102,7 @@ extern unsigned int server_queue_process_apc( HANDLE process, const apc_call_t *
 extern int server_remove_fd_from_cache( HANDLE handle ) DECLSPEC_HIDDEN;
 extern int server_get_unix_fd( HANDLE handle, unsigned int access, int *unix_fd,
                                int *needs_close, enum server_fd_type *type, unsigned int *options ) DECLSPEC_HIDDEN;
+extern int receive_fd( obj_handle_t *handle ) DECLSPEC_HIDDEN;
 extern int server_pipe( int fd[2] ) DECLSPEC_HIDDEN;
 extern NTSTATUS alloc_object_attributes( const OBJECT_ATTRIBUTES *attr, struct object_attributes **ret,
                                          data_size_t *ret_len ) DECLSPEC_HIDDEN;
diff --git a/dlls/ntdll/server.c b/dlls/ntdll/server.c
index 094b530950..773e697ae4 100644
--- a/dlls/ntdll/server.c
+++ b/dlls/ntdll/server.c
@@ -81,6 +81,7 @@
 #include "wine/server.h"
 #include "wine/debug.h"
 #include "ntdll_misc.h"
+#include "esync.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(server);
 
@@ -119,14 +120,14 @@ sigset_t server_block_set;  /* signals to block during server calls */
 static int fd_socket = -1;  /* socket to exchange file descriptors with the server */
 static pid_t server_pid;
 
-static RTL_CRITICAL_SECTION fd_cache_section;
+RTL_CRITICAL_SECTION fd_cache_section;
 static RTL_CRITICAL_SECTION_DEBUG critsect_debug =
 {
     0, 0, &fd_cache_section,
     { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
       0, 0, { (DWORD_PTR)(__FILE__ ": fd_cache_section") }
 };
-static RTL_CRITICAL_SECTION fd_cache_section = { &critsect_debug, -1, 0, 0, 0, 0 };
+RTL_CRITICAL_SECTION fd_cache_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
 /* atomically exchange a 64-bit value */
 static inline LONG64 interlocked_xchg64( LONG64 *dest, LONG64 val )
@@ -750,7 +751,7 @@ void CDECL wine_server_send_fd( int fd )
  *
  * Receive a file descriptor passed from the server.
  */
-static int receive_fd( obj_handle_t *handle )
+int receive_fd( obj_handle_t *handle )
 {
     struct iovec vec;
     struct msghdr msghdr;
diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index 3293c52859..1db8ac0fa1 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -59,7 +59,9 @@
 #include "winternl.h"
 #include "wine/server.h"
 #include "wine/debug.h"
+
 #include "ntdll_misc.h"
+#include "esync.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(ntdll);
 
@@ -248,6 +250,9 @@ NTSTATUS WINAPI NtCreateSemaphore( OUT PHANDLE SemaphoreHandle,
     if (MaximumCount <= 0 || InitialCount < 0 || InitialCount > MaximumCount)
         return STATUS_INVALID_PARAMETER;
 
+    if (do_esync())
+        return esync_create_semaphore( SemaphoreHandle, access, attr, InitialCount, MaximumCount );
+
     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
 
     SERVER_START_REQ( create_semaphore )
-- 
2.20.1


From 7653a8fe2ca3872d2e3ba8913f8c29253b3cdcaa Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 7 Jun 2018 20:45:57 -0500
Subject: [PATCH 04/83] ntdll: Store esync objects locally.

Slight tweak for optimization: return UINT_PTR instead, and remove a useless
cmpxchg.
---
 dlls/ntdll/esync.c | 62 +++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 61 insertions(+), 1 deletion(-)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index da35bdf854..2bb85d910b 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -19,6 +19,7 @@
  */
 
 #include "config.h"
+#include "wine/port.h"
 
 #include <assert.h>
 #include <stdarg.h>
@@ -26,6 +27,9 @@
 #ifdef HAVE_SYS_EVENTFD_H
 # include <sys/eventfd.h>
 #endif
+#ifdef HAVE_SYS_MMAN_H
+# include <sys/mman.h>
+#endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -34,6 +38,7 @@
 #include "winternl.h"
 #include "wine/server.h"
 #include "wine/debug.h"
+#include "wine/library.h"
 
 #include "ntdll_misc.h"
 #include "esync.h"
@@ -78,6 +83,59 @@ struct semaphore
     int max;
 };
 
+/* We'd like lookup to be fast. To that end, we use a static list indexed by handle.
+ * This is copied and adapted from the fd cache code. */
+
+#define ESYNC_LIST_BLOCK_SIZE  (65536 / sizeof(struct esync *))
+#define ESYNC_LIST_ENTRIES     128
+
+static struct esync * *esync_list[ESYNC_LIST_ENTRIES];
+static struct esync * esync_list_initial_block[ESYNC_LIST_BLOCK_SIZE];
+
+static inline UINT_PTR handle_to_index( HANDLE handle, UINT_PTR *entry )
+{
+    UINT_PTR idx = (((UINT_PTR)handle) >> 2) - 1;
+    *entry = idx / ESYNC_LIST_BLOCK_SIZE;
+    return idx % ESYNC_LIST_BLOCK_SIZE;
+}
+
+static BOOL add_to_list( HANDLE handle, struct esync *obj )
+{
+    UINT_PTR entry, idx = handle_to_index( handle, &entry );
+
+    if (entry >= ESYNC_LIST_ENTRIES)
+    {
+        FIXME( "too many allocated handles, not caching %p\n", handle );
+        return FALSE;
+    }
+
+    if (!esync_list[entry])  /* do we need to allocate a new block of entries? */
+    {
+        if (!entry) esync_list[0] = esync_list_initial_block;
+        else
+        {
+            void *ptr = wine_anon_mmap( NULL, ESYNC_LIST_BLOCK_SIZE * sizeof(struct esync *),
+                                        PROT_READ | PROT_WRITE, 0 );
+            if (ptr == MAP_FAILED) return FALSE;
+            esync_list[entry] = ptr;
+        }
+    }
+
+    obj = interlocked_xchg_ptr((void **)&esync_list[entry][idx], obj);
+    assert(!obj);
+    return TRUE;
+}
+
+static void *esync_get_object( HANDLE handle )
+{
+    UINT_PTR entry, idx = handle_to_index( handle, &entry );
+
+    if (entry >= ESYNC_LIST_ENTRIES || !esync_list[entry]) return NULL;
+
+    return esync_list[entry][idx];
+}
+
+
 static NTSTATUS create_esync(int *fd, HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, int initval, int flags)
 {
@@ -115,7 +173,7 @@ static NTSTATUS create_esync(int *fd, HANDLE *handle, ACCESS_MASK access,
     return ret;
 }
 
-extern NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
+NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, LONG initial, LONG max)
 {
     struct semaphore *semaphore;
@@ -135,6 +193,8 @@ extern NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
         semaphore->obj.type = ESYNC_SEMAPHORE;
         semaphore->obj.fd = fd;
         semaphore->max = max;
+
+        add_to_list( *handle, &semaphore->obj );
     }
 
     return ret;
-- 
2.20.1


From e6749b1e6a4aef7cceaa6e40151062f14de5289b Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 7 Jun 2018 21:02:14 -0500
Subject: [PATCH 05/83] ntdll: Implement NtReleaseSemaphore().

---
 dlls/ntdll/esync.c | 21 +++++++++++++++++++++
 dlls/ntdll/esync.h |  1 +
 dlls/ntdll/sync.c  |  4 ++++
 3 files changed, 26 insertions(+)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 2bb85d910b..e3149353eb 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -199,3 +199,24 @@ NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
 
     return ret;
 }
+
+NTSTATUS esync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev )
+{
+    struct semaphore *semaphore = esync_get_object( handle );
+    uint64_t count64 = count;
+
+    TRACE("%p, %d, %p.\n", handle, count, prev);
+
+    if (!semaphore) return STATUS_INVALID_HANDLE;
+
+    if (prev)
+    {
+        FIXME("Can't write previous value.\n");
+        *prev = 1;
+    }
+
+    if (write( semaphore->obj.fd, &count64, sizeof(count64) ) == -1)
+        return FILE_GetNtStatus();
+
+    return STATUS_SUCCESS;
+}
diff --git a/dlls/ntdll/esync.h b/dlls/ntdll/esync.h
index 1a88170cfc..fec0b68e8d 100644
--- a/dlls/ntdll/esync.h
+++ b/dlls/ntdll/esync.h
@@ -22,6 +22,7 @@ extern int do_esync(void) DECLSPEC_HIDDEN;
 
 extern NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, LONG initial, LONG max) DECLSPEC_HIDDEN;
+extern NTSTATUS esync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev ) DECLSPEC_HIDDEN;
 
 
 /* We have to synchronize on the fd cache CS so that our calls to receive_fd
diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index 1db8ac0fa1..0b1afb1e1b 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -333,6 +333,10 @@ NTSTATUS WINAPI NtQuerySemaphore( HANDLE handle, SEMAPHORE_INFORMATION_CLASS cla
 NTSTATUS WINAPI NtReleaseSemaphore( HANDLE handle, ULONG count, PULONG previous )
 {
     NTSTATUS ret;
+
+    if (do_esync())
+        return esync_release_semaphore( handle, count, previous );
+
     SERVER_START_REQ( release_semaphore )
     {
         req->handle = wine_server_obj_handle( handle );
-- 
2.20.1


From 5441b299d23d122414f4311ce879410d7e6e0c51 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 7 Jun 2018 21:07:51 -0500
Subject: [PATCH 06/83] ntdll: Close esync objects.

---
 dlls/ntdll/esync.c | 19 +++++++++++++++++++
 dlls/ntdll/esync.h |  1 +
 dlls/ntdll/om.c    |  4 ++++
 3 files changed, 24 insertions(+)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index e3149353eb..03a627a157 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -135,6 +135,25 @@ static void *esync_get_object( HANDLE handle )
     return esync_list[entry][idx];
 }
 
+NTSTATUS esync_close( HANDLE handle )
+{
+    UINT_PTR entry, idx = handle_to_index( handle, &entry );
+    struct esync *obj;
+
+    TRACE("%p.\n", handle);
+
+    if (entry < ESYNC_LIST_ENTRIES && esync_list[entry])
+    {
+        if ((obj = interlocked_xchg_ptr( (void **)&esync_list[entry][idx], 0 )))
+        {
+            close( obj->fd );
+            RtlFreeHeap( GetProcessHeap(), 0, obj );
+            return STATUS_SUCCESS;
+        }
+    }
+
+    return STATUS_INVALID_HANDLE;
+}
 
 static NTSTATUS create_esync(int *fd, HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, int initval, int flags)
diff --git a/dlls/ntdll/esync.h b/dlls/ntdll/esync.h
index fec0b68e8d..a22618de84 100644
--- a/dlls/ntdll/esync.h
+++ b/dlls/ntdll/esync.h
@@ -19,6 +19,7 @@
  */
 
 extern int do_esync(void) DECLSPEC_HIDDEN;
+extern NTSTATUS esync_close( HANDLE handle ) DECLSPEC_HIDDEN;
 
 extern NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, LONG initial, LONG max) DECLSPEC_HIDDEN;
diff --git a/dlls/ntdll/om.c b/dlls/ntdll/om.c
index 0b56251348..6c74ce535d 100644
--- a/dlls/ntdll/om.c
+++ b/dlls/ntdll/om.c
@@ -37,6 +37,7 @@
 #include "windef.h"
 #include "winternl.h"
 #include "ntdll_misc.h"
+#include "esync.h"
 #include "wine/server.h"
 #include "wine/exception.h"
 
@@ -390,6 +391,9 @@ NTSTATUS close_handle( HANDLE handle )
     NTSTATUS ret;
     int fd = server_remove_fd_from_cache( handle );
 
+    if (do_esync())
+        esync_close( handle );
+
     SERVER_START_REQ( close_handle )
     {
         req->handle = wine_server_obj_handle( handle );
-- 
2.20.1


From e7ca5693811f4068c7a56b65827c195a9fcfeaff Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 7 Jun 2018 21:23:52 -0500
Subject: [PATCH 07/83] ntdll: Implement waiting on esync objects.

This is the most basic case: WAIT_ANY. We use poll() (actually ppoll(), for
the better granularity) to select on all of the handles that we can.
---
 dlls/ntdll/esync.c | 161 +++++++++++++++++++++++++++++++++++++++++++++
 dlls/ntdll/esync.h |   3 +
 dlls/ntdll/sync.c  |   7 ++
 3 files changed, 171 insertions(+)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 03a627a157..1b75fb8bc8 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -22,6 +22,13 @@
 #include "wine/port.h"
 
 #include <assert.h>
+#include <errno.h>
+#ifdef HAVE_POLL_H
+#include <poll.h>
+#endif
+#ifdef HAVE_SYS_POLL_H
+# include <sys/poll.h>
+#endif
 #include <stdarg.h>
 #include <stdlib.h>
 #ifdef HAVE_SYS_EVENTFD_H
@@ -239,3 +246,157 @@ NTSTATUS esync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev )
 
     return STATUS_SUCCESS;
 }
+
+#define TICKSPERSEC        10000000
+#define TICKSPERMSEC       10000
+
+static LONGLONG update_timeout( ULONGLONG end )
+{
+    LARGE_INTEGER now;
+    LONGLONG timeleft;
+
+    NtQuerySystemTime( &now );
+    timeleft = end - now.QuadPart;
+    if (timeleft < 0) timeleft = 0;
+    return timeleft;
+}
+
+static int do_poll( struct pollfd *fds, nfds_t nfds, ULONGLONG *end )
+{
+    if (end)
+    {
+        LONGLONG timeleft = update_timeout( *end );
+
+#ifdef HAVE_PPOLL
+        /* We use ppoll() if available since the time granularity is better. */
+        struct timespec tmo_p;
+        tmo_p.tv_sec = timeleft / (ULONGLONG)TICKSPERSEC;
+        tmo_p.tv_nsec = (timeleft % TICKSPERSEC) * 100;
+        return ppoll( fds, nfds, &tmo_p, NULL );
+#else
+        return poll( fds, nfds, timeleft / TICKSPERMSEC );
+#endif
+    }
+    else
+        return poll( fds, nfds, -1 );
+}
+
+/* A value of STATUS_NOT_IMPLEMENTED returned from this function means that we
+ * need to delegate to server_select(). */
+NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
+                             BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    struct esync *objs[MAXIMUM_WAIT_OBJECTS];
+    struct pollfd fds[MAXIMUM_WAIT_OBJECTS];
+    int has_esync = 0, has_server = 0;
+    LONGLONG timeleft;
+    LARGE_INTEGER now;
+    ULONGLONG end;
+    int ret;
+    int i;
+
+    NtQuerySystemTime( &now );
+    if (timeout)
+    {
+        if (timeout->QuadPart == TIMEOUT_INFINITE)
+            timeout = NULL;
+        else if (timeout->QuadPart >= 0)
+            end = timeout->QuadPart;
+        else
+            end = now.QuadPart - timeout->QuadPart;
+    }
+
+    for (i = 0; i < count; i++)
+    {
+        objs[i] = esync_get_object( handles[i] );
+        if (objs[i])
+            has_esync = 1;
+        else
+            has_server = 1;
+    }
+
+    if (has_esync && has_server)
+    {
+        FIXME("Can't wait on esync and server objects at the same time!\n");
+        /* Wait on just the eventfds; it's the best we can do. */
+    }
+    else if (has_server)
+    {
+        /* It's just server objects, so delegate to the server. */
+        return STATUS_NOT_IMPLEMENTED;
+    }
+
+    if (TRACE_ON(esync))
+    {
+        TRACE("Waiting for %s of %d handles:", wait_any ? "any" : "all", count);
+        for (i = 0; i < count; i++)
+            DPRINTF(" %p", handles[i]);
+
+        if (!timeout)
+            DPRINTF(", timeout = INFINITE.\n");
+        else
+        {
+            timeleft = update_timeout( end );
+            DPRINTF(", timeout = %ld.%07ld sec.\n",
+                (long) timeleft / TICKSPERSEC, (long) timeleft % TICKSPERSEC);
+        }
+    }
+
+    if (wait_any || count == 1)
+    {
+        for (i = 0; i < count; i++)
+        {
+            fds[i].fd = objs[i] ? objs[i]->fd : -1;
+            fds[i].events = POLLIN;
+        }
+
+        while (1)
+        {
+            ret = do_poll( fds, count, timeout ? &end : NULL );
+            if (ret > 0)
+            {
+                /* Find out which object triggered the wait. */
+                for (i = 0; i < count; i++)
+                {
+                    if (fds[i].revents & (POLLERR | POLLHUP | POLLNVAL))
+                    {
+                        ERR("Polling on fd %d returned %#x.\n", fds[i].fd, fds[i].revents);
+                        return STATUS_INVALID_HANDLE;
+                    }
+
+                    if (objs[i])
+                    {
+                        int64_t value;
+                        ssize_t size;
+
+                        if ((size = read( fds[i].fd, &value, sizeof(value) )) == sizeof(value))
+                        {
+                            /* We found our object. */
+                            TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                            return i;
+                        }
+                    }
+                }
+
+                /* If we got here, someone else stole (or reset, etc.) whatever
+                 * we were waiting for. So keep waiting. */
+                NtQuerySystemTime( &now );
+            }
+            else if (ret == 0)
+            {
+                TRACE("Wait timed out.\n");
+                return STATUS_TIMEOUT;
+            }
+            else
+            {
+                ERR("ppoll failed: %s\n", strerror(errno));
+                return FILE_GetNtStatus();
+            }
+        }
+    }
+    else
+    {
+        FIXME("Wait-all not implemented.\n");
+        return STATUS_NOT_IMPLEMENTED;
+    }
+}
diff --git a/dlls/ntdll/esync.h b/dlls/ntdll/esync.h
index a22618de84..8f7f9b030e 100644
--- a/dlls/ntdll/esync.h
+++ b/dlls/ntdll/esync.h
@@ -25,6 +25,9 @@ extern NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, LONG initial, LONG max) DECLSPEC_HIDDEN;
 extern NTSTATUS esync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev ) DECLSPEC_HIDDEN;
 
+extern NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
+                                    BOOLEAN alertable, const LARGE_INTEGER *timeout ) DECLSPEC_HIDDEN;
+
 
 /* We have to synchronize on the fd cache CS so that our calls to receive_fd
  * don't race with theirs. It looks weird, I know.
diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index 0b1afb1e1b..602341bf36 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -1096,6 +1096,13 @@ static NTSTATUS wait_objects( DWORD count, const HANDLE *handles,
 
     if (!count || count > MAXIMUM_WAIT_OBJECTS) return STATUS_INVALID_PARAMETER_1;
 
+    if (do_esync())
+    {
+        NTSTATUS ret = esync_wait_objects( count, handles, wait_any, alertable, timeout );
+        if (ret != STATUS_NOT_IMPLEMENTED)
+            return ret;
+    }
+
     if (alertable) flags |= SELECT_ALERTABLE;
     select_op.wait.op = wait_any ? SELECT_WAIT : SELECT_WAIT_ALL;
     for (i = 0; i < count; i++) select_op.wait.handles[i] = wine_server_obj_handle( handles[i] );
-- 
2.20.1


From cb3b5458cd727a771cdaeb38598b05c7ce24c392 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 8 Jun 2018 15:33:46 -0500
Subject: [PATCH 08/83] ntdll: Create esync objects for events.

---
 dlls/ntdll/esync.c | 34 ++++++++++++++++++++++++++++++++++
 dlls/ntdll/esync.h |  2 ++
 dlls/ntdll/sync.c  |  3 +++
 3 files changed, 39 insertions(+)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 1b75fb8bc8..98e3f85515 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -76,6 +76,8 @@ int do_esync(void)
 enum esync_type
 {
     ESYNC_SEMAPHORE = 1,
+    ESYNC_AUTO_EVENT,
+    ESYNC_MANUAL_EVENT,
 };
 
 struct esync
@@ -90,6 +92,11 @@ struct semaphore
     int max;
 };
 
+struct event
+{
+    struct esync obj;
+};
+
 /* We'd like lookup to be fast. To that end, we use a static list indexed by handle.
  * This is copied and adapted from the fd cache code. */
 
@@ -247,6 +254,33 @@ NTSTATUS esync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev )
     return STATUS_SUCCESS;
 }
 
+NTSTATUS esync_create_event( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr, EVENT_TYPE type, BOOLEAN initial )
+{
+    struct event *event;
+    NTSTATUS ret;
+    int fd;
+
+    TRACE("name %s, %s-reset, initial %d.\n",
+        attr ? debugstr_us(attr->ObjectName) : "<no name>",
+        type == NotificationEvent ? "manual" : "auto", initial);
+
+    ret = create_esync( &fd, handle, access, attr, initial, 0 );
+    if (!ret || ret == STATUS_OBJECT_NAME_EXISTS)
+    {
+        event = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*event) );
+        if (!event)
+            return STATUS_NO_MEMORY;
+
+        event->obj.type = (type == NotificationEvent ? ESYNC_MANUAL_EVENT : ESYNC_AUTO_EVENT);
+        event->obj.fd = fd;
+
+        add_to_list( *handle, &event->obj);
+    }
+
+    return ret;
+}
+
 #define TICKSPERSEC        10000000
 #define TICKSPERMSEC       10000
 
diff --git a/dlls/ntdll/esync.h b/dlls/ntdll/esync.h
index 8f7f9b030e..32a259e39d 100644
--- a/dlls/ntdll/esync.h
+++ b/dlls/ntdll/esync.h
@@ -24,6 +24,8 @@ extern NTSTATUS esync_close( HANDLE handle ) DECLSPEC_HIDDEN;
 extern NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, LONG initial, LONG max) DECLSPEC_HIDDEN;
 extern NTSTATUS esync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev ) DECLSPEC_HIDDEN;
+extern NTSTATUS esync_create_event( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr, EVENT_TYPE type, BOOLEAN initial ) DECLSPEC_HIDDEN;
 
 extern NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
                                     BOOLEAN alertable, const LARGE_INTEGER *timeout ) DECLSPEC_HIDDEN;
diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index 602341bf36..bb78bc3d9b 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -365,6 +365,9 @@ NTSTATUS WINAPI NtCreateEvent( PHANDLE EventHandle, ACCESS_MASK DesiredAccess,
     data_size_t len;
     struct object_attributes *objattr;
 
+    if (do_esync())
+        return esync_create_event( EventHandle, DesiredAccess, attr, type, InitialState );
+
     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
 
     SERVER_START_REQ( create_event )
-- 
2.20.1


From b5586172c44879ee168d367105a72228fbd60eb4 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 8 Jun 2018 15:41:01 -0500
Subject: [PATCH 09/83] ntdll: Implement NtSetEvent().

---
 dlls/ntdll/esync.c | 15 +++++++++++++++
 dlls/ntdll/esync.h |  1 +
 dlls/ntdll/sync.c  |  3 +++
 3 files changed, 19 insertions(+)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 98e3f85515..39f42dbf04 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -281,6 +281,21 @@ NTSTATUS esync_create_event( HANDLE *handle, ACCESS_MASK access,
     return ret;
 }
 
+NTSTATUS esync_set_event( HANDLE handle )
+{
+    struct event *event = esync_get_object( handle );
+    static const uint64_t value = 1;
+
+    TRACE("%p.\n", handle);
+
+    if (!event) return STATUS_INVALID_HANDLE;
+
+    if (write( event->obj.fd, &value, sizeof(value) ) == -1)
+        return FILE_GetNtStatus();
+
+    return STATUS_SUCCESS;
+}
+
 #define TICKSPERSEC        10000000
 #define TICKSPERMSEC       10000
 
diff --git a/dlls/ntdll/esync.h b/dlls/ntdll/esync.h
index 32a259e39d..cd70c1480b 100644
--- a/dlls/ntdll/esync.h
+++ b/dlls/ntdll/esync.h
@@ -26,6 +26,7 @@ extern NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
 extern NTSTATUS esync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev ) DECLSPEC_HIDDEN;
 extern NTSTATUS esync_create_event( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, EVENT_TYPE type, BOOLEAN initial ) DECLSPEC_HIDDEN;
+extern NTSTATUS esync_set_event( HANDLE handle ) DECLSPEC_HIDDEN;
 
 extern NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
                                     BOOLEAN alertable, const LARGE_INTEGER *timeout ) DECLSPEC_HIDDEN;
diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index bb78bc3d9b..3f969f92d7 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -418,6 +418,9 @@ NTSTATUS WINAPI NtSetEvent( HANDLE handle, PULONG NumberOfThreadsReleased )
 {
     NTSTATUS ret;
 
+    if (do_esync())
+        return esync_set_event( handle );
+
     /* FIXME: set NumberOfThreadsReleased */
 
     SERVER_START_REQ( event_op )
-- 
2.20.1


From 967a767e2ad69543a3396daaadcc1a55e43a0445 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 8 Jun 2018 15:44:49 -0500
Subject: [PATCH 10/83] ntdll: Implement NtResetEvent().

---
 dlls/ntdll/esync.c | 15 +++++++++++++++
 dlls/ntdll/esync.h |  1 +
 dlls/ntdll/sync.c  |  3 +++
 3 files changed, 19 insertions(+)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 39f42dbf04..85e0dbc7ff 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -296,6 +296,21 @@ NTSTATUS esync_set_event( HANDLE handle )
     return STATUS_SUCCESS;
 }
 
+NTSTATUS esync_reset_event( HANDLE handle )
+{
+    struct event *event = esync_get_object( handle );
+    static uint64_t value;
+
+    TRACE("%p.\n", handle);
+
+    if (!event) return STATUS_INVALID_HANDLE;
+
+    /* we don't care about the return value */
+    read( event->obj.fd, &value, sizeof(value) );
+
+    return STATUS_SUCCESS;
+}
+
 #define TICKSPERSEC        10000000
 #define TICKSPERMSEC       10000
 
diff --git a/dlls/ntdll/esync.h b/dlls/ntdll/esync.h
index cd70c1480b..c778b316a2 100644
--- a/dlls/ntdll/esync.h
+++ b/dlls/ntdll/esync.h
@@ -27,6 +27,7 @@ extern NTSTATUS esync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev
 extern NTSTATUS esync_create_event( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, EVENT_TYPE type, BOOLEAN initial ) DECLSPEC_HIDDEN;
 extern NTSTATUS esync_set_event( HANDLE handle ) DECLSPEC_HIDDEN;
+extern NTSTATUS esync_reset_event( HANDLE handle ) DECLSPEC_HIDDEN;
 
 extern NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
                                     BOOLEAN alertable, const LARGE_INTEGER *timeout ) DECLSPEC_HIDDEN;
diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index 3f969f92d7..c645a24be8 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -440,6 +440,9 @@ NTSTATUS WINAPI NtResetEvent( HANDLE handle, PULONG NumberOfThreadsReleased )
 {
     NTSTATUS ret;
 
+    if (do_esync())
+        return esync_reset_event( handle );
+
     /* resetting an event can't release any thread... */
     if (NumberOfThreadsReleased) *NumberOfThreadsReleased = 0;
 
-- 
2.20.1


From 43a4dc81ab75be45251971900a73606b69912c60 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 8 Jun 2018 15:47:16 -0500
Subject: [PATCH 11/83] ntdll: Implement NtPulseEvent().

---
 dlls/ntdll/esync.c | 19 +++++++++++++++++++
 dlls/ntdll/esync.h |  1 +
 dlls/ntdll/sync.c  |  3 +++
 3 files changed, 23 insertions(+)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 85e0dbc7ff..667f872400 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -311,6 +311,25 @@ NTSTATUS esync_reset_event( HANDLE handle )
     return STATUS_SUCCESS;
 }
 
+NTSTATUS esync_pulse_event( HANDLE handle )
+{
+    struct event *event = esync_get_object( handle );
+    static uint64_t value = 1;
+
+    TRACE("%p.\n", handle);
+
+    if (!event) return STATUS_INVALID_HANDLE;
+
+    /* This isn't really correct; an application could miss the write.
+     * Unfortunately we can't really do much better. Fortunately this is rarely
+     * used (and publicly deprecated). */
+    if (write( event->obj.fd, &value, sizeof(value) ) == -1)
+        return FILE_GetNtStatus();
+    read( event->obj.fd, &value, sizeof(value) );
+
+    return STATUS_SUCCESS;
+}
+
 #define TICKSPERSEC        10000000
 #define TICKSPERMSEC       10000
 
diff --git a/dlls/ntdll/esync.h b/dlls/ntdll/esync.h
index c778b316a2..062781fc00 100644
--- a/dlls/ntdll/esync.h
+++ b/dlls/ntdll/esync.h
@@ -28,6 +28,7 @@ extern NTSTATUS esync_create_event( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, EVENT_TYPE type, BOOLEAN initial ) DECLSPEC_HIDDEN;
 extern NTSTATUS esync_set_event( HANDLE handle ) DECLSPEC_HIDDEN;
 extern NTSTATUS esync_reset_event( HANDLE handle ) DECLSPEC_HIDDEN;
+extern NTSTATUS esync_pulse_event( HANDLE handle ) DECLSPEC_HIDDEN;
 
 extern NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
                                     BOOLEAN alertable, const LARGE_INTEGER *timeout ) DECLSPEC_HIDDEN;
diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index c645a24be8..cc84b2637f 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -477,6 +477,9 @@ NTSTATUS WINAPI NtPulseEvent( HANDLE handle, PULONG PulseCount )
 {
     NTSTATUS ret;
 
+    if (do_esync())
+        return esync_pulse_event( handle );
+
     if (PulseCount)
       FIXME("(%p,%d)\n", handle, *PulseCount);
 
-- 
2.20.1


From ce7373b0fbe6249d4cc0b79bf56954265e5826bb Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 8 Jun 2018 15:55:39 -0500
Subject: [PATCH 12/83] ntdll: Implement waiting on events.

More specifically, implement waiting on manual-reset events. Auto-reset events already worked.
---
 dlls/ntdll/esync.c | 20 ++++++++++++++++----
 1 file changed, 16 insertions(+), 4 deletions(-)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 667f872400..e8c34bda3a 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -452,11 +452,23 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
                         int64_t value;
                         ssize_t size;
 
-                        if ((size = read( fds[i].fd, &value, sizeof(value) )) == sizeof(value))
+                        if (objs[i]->type == ESYNC_MANUAL_EVENT)
                         {
-                            /* We found our object. */
-                            TRACE("Woken up by handle %p [%d].\n", handles[i], i);
-                            return i;
+                            /* Don't grab the object, just check if it's signaled. */
+                            if (fds[i].revents & POLLIN)
+                            {
+                                TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                                return i;
+                            }
+                        }
+                        else
+                        {
+                            if ((size = read( fds[i].fd, &value, sizeof(value) )) == sizeof(value))
+                            {
+                                /* We found our object. */
+                                TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                                return i;
+                            }
                         }
                     }
                 }
-- 
2.20.1


From 26ef4e61bd5d279d22cfb90fb0cc7d0c80ef6591 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 8 Jun 2018 18:51:40 -0500
Subject: [PATCH 13/83] server: Add an object operation to grab the esync file
 descriptor.

Split off to decrease patch size.
---
 server/async.c      | 2 ++
 server/atom.c       | 1 +
 server/change.c     | 1 +
 server/clipboard.c  | 1 +
 server/completion.c | 1 +
 server/console.c    | 3 +++
 server/debugger.c   | 2 ++
 server/device.c     | 4 ++++
 server/directory.c  | 2 ++
 server/esync.c      | 1 +
 server/event.c      | 2 ++
 server/fd.c         | 4 ++++
 server/file.c       | 1 +
 server/handle.c     | 1 +
 server/hook.c       | 1 +
 server/mailslot.c   | 3 +++
 server/mapping.c    | 3 +++
 server/mutex.c      | 1 +
 server/named_pipe.c | 5 +++++
 server/object.h     | 2 ++
 server/process.c    | 3 +++
 server/queue.c      | 2 ++
 server/registry.c   | 1 +
 server/request.c    | 1 +
 server/semaphore.c  | 1 +
 server/serial.c     | 1 +
 server/signal.c     | 1 +
 server/snapshot.c   | 1 +
 server/sock.c       | 2 ++
 server/symlink.c    | 1 +
 server/thread.c     | 2 ++
 server/timer.c      | 1 +
 server/token.c      | 1 +
 server/winstation.c | 2 ++
 34 files changed, 61 insertions(+)

diff --git a/server/async.c b/server/async.c
index cadeda3ffb..0ea3b86d7e 100644
--- a/server/async.c
+++ b/server/async.c
@@ -69,6 +69,7 @@ static const struct object_ops async_ops =
     add_queue,                 /* add_queue */
     remove_queue,              /* remove_queue */
     async_signaled,            /* signaled */
+    NULL,                      /* get_esync_fd */
     async_satisfied,           /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
@@ -457,6 +458,7 @@ static const struct object_ops iosb_ops =
     no_add_queue,             /* add_queue */
     NULL,                     /* remove_queue */
     NULL,                     /* signaled */
+    NULL,                     /* get_esync_fd */
     NULL,                     /* satisfied */
     no_signal,                /* signal */
     no_get_fd,                /* get_fd */
diff --git a/server/atom.c b/server/atom.c
index 3ff75407d9..e79296f5ae 100644
--- a/server/atom.c
+++ b/server/atom.c
@@ -80,6 +80,7 @@ static const struct object_ops atom_table_ops =
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
diff --git a/server/change.c b/server/change.c
index 3dd52aa167..870665b1ad 100644
--- a/server/change.c
+++ b/server/change.c
@@ -162,6 +162,7 @@ static const struct object_ops dir_ops =
     add_queue,                /* add_queue */
     remove_queue,             /* remove_queue */
     default_fd_signaled,      /* signaled */
+    NULL,                     /* get_esync_fd */
     no_satisfied,             /* satisfied */
     no_signal,                /* signal */
     dir_get_fd,               /* get_fd */
diff --git a/server/clipboard.c b/server/clipboard.c
index 162725b2ea..8e70094de7 100644
--- a/server/clipboard.c
+++ b/server/clipboard.c
@@ -77,6 +77,7 @@ static const struct object_ops clipboard_ops =
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
diff --git a/server/completion.c b/server/completion.c
index 8b8983a157..85850835bf 100644
--- a/server/completion.c
+++ b/server/completion.c
@@ -65,6 +65,7 @@ static const struct object_ops completion_ops =
     add_queue,                 /* add_queue */
     remove_queue,              /* remove_queue */
     completion_signaled,       /* signaled */
+    NULL,                      /* get_esync_fd */
     no_satisfied,              /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
diff --git a/server/console.c b/server/console.c
index e1ae086cb7..b0038d079a 100644
--- a/server/console.c
+++ b/server/console.c
@@ -77,6 +77,7 @@ static const struct object_ops console_input_ops =
     no_add_queue,                     /* add_queue */
     NULL,                             /* remove_queue */
     NULL,                             /* signaled */
+    NULL,                             /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     console_input_get_fd,             /* get_fd */
@@ -111,6 +112,7 @@ static const struct object_ops console_input_events_ops =
     add_queue,                        /* add_queue */
     remove_queue,                     /* remove_queue */
     console_input_events_signaled,    /* signaled */
+    NULL,                             /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     no_get_fd,                        /* get_fd */
@@ -167,6 +169,7 @@ static const struct object_ops screen_buffer_ops =
     no_add_queue,                     /* add_queue */
     NULL,                             /* remove_queue */
     NULL,                             /* signaled */
+    NULL,                             /* get_esync_fd */
     NULL,                             /* satisfied */
     no_signal,                        /* signal */
     screen_buffer_get_fd,             /* get_fd */
diff --git a/server/debugger.c b/server/debugger.c
index 79b7e527f3..f424562908 100644
--- a/server/debugger.c
+++ b/server/debugger.c
@@ -74,6 +74,7 @@ static const struct object_ops debug_event_ops =
     add_queue,                     /* add_queue */
     remove_queue,                  /* remove_queue */
     debug_event_signaled,          /* signaled */
+    NULL,                          /* get_esync_fd */
     no_satisfied,                  /* satisfied */
     no_signal,                     /* signal */
     no_get_fd,                     /* get_fd */
@@ -100,6 +101,7 @@ static const struct object_ops debug_ctx_ops =
     add_queue,                     /* add_queue */
     remove_queue,                  /* remove_queue */
     debug_ctx_signaled,            /* signaled */
+    NULL,                          /* get_esync_fd */
     no_satisfied,                  /* satisfied */
     no_signal,                     /* signal */
     no_get_fd,                     /* get_fd */
diff --git a/server/device.c b/server/device.c
index ac7d88f8c2..94309ba112 100644
--- a/server/device.c
+++ b/server/device.c
@@ -65,6 +65,7 @@ static const struct object_ops irp_call_ops =
     add_queue,                        /* add_queue */
     remove_queue,                     /* remove_queue */
     irp_call_signaled,                /* signaled */
+    NULL,                             /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     no_get_fd,                        /* get_fd */
@@ -101,6 +102,7 @@ static const struct object_ops device_manager_ops =
     add_queue,                        /* add_queue */
     remove_queue,                     /* remove_queue */
     device_manager_signaled,          /* signaled */
+    NULL,                             /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     no_get_fd,                        /* get_fd */
@@ -142,6 +144,7 @@ static const struct object_ops device_ops =
     no_add_queue,                     /* add_queue */
     NULL,                             /* remove_queue */
     NULL,                             /* signaled */
+    NULL,                             /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     no_get_fd,                        /* get_fd */
@@ -187,6 +190,7 @@ static const struct object_ops device_file_ops =
     add_queue,                        /* add_queue */
     remove_queue,                     /* remove_queue */
     default_fd_signaled,              /* signaled */
+    NULL,                             /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     device_file_get_fd,               /* get_fd */
diff --git a/server/directory.c b/server/directory.c
index 6aa3a55f35..1de2b6ee06 100644
--- a/server/directory.c
+++ b/server/directory.c
@@ -57,6 +57,7 @@ static const struct object_ops object_type_ops =
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
@@ -92,6 +93,7 @@ static const struct object_ops directory_ops =
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
diff --git a/server/esync.c b/server/esync.c
index 66cae244f6..e761475678 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -53,6 +53,7 @@ static const struct object_ops esync_ops =
     no_add_queue,              /* add_queue */
     NULL,                      /* remove_queue */
     NULL,                      /* signaled */
+    NULL,                      /* get_esync_fd */
     NULL,                      /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
diff --git a/server/event.c b/server/event.c
index cfc0f6afc0..a85be8de3d 100644
--- a/server/event.c
+++ b/server/event.c
@@ -58,6 +58,7 @@ static const struct object_ops event_ops =
     add_queue,                 /* add_queue */
     remove_queue,              /* remove_queue */
     event_signaled,            /* signaled */
+    NULL,                      /* get_esync_fd */
     event_satisfied,           /* satisfied */
     event_signal,              /* signal */
     no_get_fd,                 /* get_fd */
@@ -91,6 +92,7 @@ static const struct object_ops keyed_event_ops =
     add_queue,                   /* add_queue */
     remove_queue,                /* remove_queue */
     keyed_event_signaled,        /* signaled */
+    NULL,                        /* get_esync_fd */
     no_satisfied,                /* satisfied */
     no_signal,                   /* signal */
     no_get_fd,                   /* get_fd */
diff --git a/server/fd.c b/server/fd.c
index f2d83b4d58..4c94c4918f 100644
--- a/server/fd.c
+++ b/server/fd.c
@@ -208,6 +208,7 @@ static const struct object_ops fd_ops =
     no_add_queue,             /* add_queue */
     NULL,                     /* remove_queue */
     NULL,                     /* signaled */
+    NULL,                     /* get_esync_fd */
     NULL,                     /* satisfied */
     no_signal,                /* signal */
     no_get_fd,                /* get_fd */
@@ -247,6 +248,7 @@ static const struct object_ops device_ops =
     no_add_queue,             /* add_queue */
     NULL,                     /* remove_queue */
     NULL,                     /* signaled */
+    NULL,                     /* get_esync_fd */
     NULL,                     /* satisfied */
     no_signal,                /* signal */
     no_get_fd,                /* get_fd */
@@ -285,6 +287,7 @@ static const struct object_ops inode_ops =
     no_add_queue,             /* add_queue */
     NULL,                     /* remove_queue */
     NULL,                     /* signaled */
+    NULL,                     /* get_esync_fd */
     NULL,                     /* satisfied */
     no_signal,                /* signal */
     no_get_fd,                /* get_fd */
@@ -325,6 +328,7 @@ static const struct object_ops file_lock_ops =
     add_queue,                  /* add_queue */
     remove_queue,               /* remove_queue */
     file_lock_signaled,         /* signaled */
+    NULL,                       /* get_esync_fd */
     no_satisfied,               /* satisfied */
     no_signal,                  /* signal */
     no_get_fd,                  /* get_fd */
diff --git a/server/file.c b/server/file.c
index 8d39f303bd..6268f58e20 100644
--- a/server/file.c
+++ b/server/file.c
@@ -85,6 +85,7 @@ static const struct object_ops file_ops =
     add_queue,                    /* add_queue */
     remove_queue,                 /* remove_queue */
     default_fd_signaled,          /* signaled */
+    NULL,                         /* get_esync_fd */
     no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     file_get_fd,                  /* get_fd */
diff --git a/server/handle.c b/server/handle.c
index 35ab8607c8..b8fdfffcc5 100644
--- a/server/handle.c
+++ b/server/handle.c
@@ -123,6 +123,7 @@ static const struct object_ops handle_table_ops =
     no_add_queue,                    /* add_queue */
     NULL,                            /* remove_queue */
     NULL,                            /* signaled */
+    NULL,                            /* get_esync_fd */
     NULL,                            /* satisfied */
     no_signal,                       /* signal */
     no_get_fd,                       /* get_fd */
diff --git a/server/hook.c b/server/hook.c
index 3a0e4b4d1d..1845d961e7 100644
--- a/server/hook.c
+++ b/server/hook.c
@@ -81,6 +81,7 @@ static const struct object_ops hook_table_ops =
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
diff --git a/server/mailslot.c b/server/mailslot.c
index 95308c40b0..f5cf216caa 100644
--- a/server/mailslot.c
+++ b/server/mailslot.c
@@ -79,6 +79,7 @@ static const struct object_ops mailslot_ops =
     add_queue,                 /* add_queue */
     remove_queue,              /* remove_queue */
     default_fd_signaled,       /* signaled */
+    NULL,                      /* get_esync_fd */
     no_satisfied,              /* satisfied */
     no_signal,                 /* signal */
     mailslot_get_fd,           /* get_fd */
@@ -135,6 +136,7 @@ static const struct object_ops mail_writer_ops =
     no_add_queue,               /* add_queue */
     NULL,                       /* remove_queue */
     NULL,                       /* signaled */
+    NULL,                       /* get_esync_fd */
     NULL,                       /* satisfied */
     no_signal,                  /* signal */
     mail_writer_get_fd,         /* get_fd */
@@ -192,6 +194,7 @@ static const struct object_ops mailslot_device_ops =
     no_add_queue,                   /* add_queue */
     NULL,                           /* remove_queue */
     NULL,                           /* signaled */
+    NULL,                           /* get_esync_fd */
     no_satisfied,                   /* satisfied */
     no_signal,                      /* signal */
     mailslot_device_get_fd,         /* get_fd */
diff --git a/server/mapping.c b/server/mapping.c
index 085d7aaa30..7618e2a4f7 100644
--- a/server/mapping.c
+++ b/server/mapping.c
@@ -67,6 +67,7 @@ static const struct object_ops ranges_ops =
     no_add_queue,              /* add_queue */
     NULL,                      /* remove_queue */
     NULL,                      /* signaled */
+    NULL,                      /* get_esync_fd */
     NULL,                      /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
@@ -101,6 +102,7 @@ static const struct object_ops shared_map_ops =
     no_add_queue,              /* add_queue */
     NULL,                      /* remove_queue */
     NULL,                      /* signaled */
+    NULL,                      /* get_esync_fd */
     NULL,                      /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
@@ -156,6 +158,7 @@ static const struct object_ops mapping_ops =
     no_add_queue,                /* add_queue */
     NULL,                        /* remove_queue */
     NULL,                        /* signaled */
+    NULL,                        /* get_esync_fd */
     NULL,                        /* satisfied */
     no_signal,                   /* signal */
     mapping_get_fd,              /* get_fd */
diff --git a/server/mutex.c b/server/mutex.c
index d1887e4bc4..fa5c3659c3 100644
--- a/server/mutex.c
+++ b/server/mutex.c
@@ -61,6 +61,7 @@ static const struct object_ops mutex_ops =
     add_queue,                 /* add_queue */
     remove_queue,              /* remove_queue */
     mutex_signaled,            /* signaled */
+    NULL,                      /* get_esync_fd */
     mutex_satisfied,           /* satisfied */
     mutex_signal,              /* signal */
     no_get_fd,                 /* get_fd */
diff --git a/server/named_pipe.c b/server/named_pipe.c
index 8c32ef832c..b279e5661f 100644
--- a/server/named_pipe.c
+++ b/server/named_pipe.c
@@ -118,6 +118,7 @@ static const struct object_ops named_pipe_ops =
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
@@ -160,6 +161,7 @@ static const struct object_ops pipe_server_ops =
     add_queue,                    /* add_queue */
     remove_queue,                 /* remove_queue */
     default_fd_signaled,          /* signaled */
+    NULL,                         /* get_esync_fd */
     no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     pipe_end_get_fd,              /* get_fd */
@@ -201,6 +203,7 @@ static const struct object_ops pipe_client_ops =
     add_queue,                    /* add_queue */
     remove_queue,                 /* remove_queue */
     default_fd_signaled,          /* signaled */
+    NULL,                         /* get_esync_fd */
     no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     pipe_end_get_fd,              /* get_fd */
@@ -246,6 +249,7 @@ static const struct object_ops named_pipe_device_ops =
     no_add_queue,                     /* add_queue */
     NULL,                             /* remove_queue */
     NULL,                             /* signaled */
+    NULL,                             /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     no_get_fd,                        /* get_fd */
@@ -274,6 +278,7 @@ static const struct object_ops named_pipe_device_file_ops =
     add_queue,                               /* add_queue */
     remove_queue,                            /* remove_queue */
     default_fd_signaled,                     /* signaled */
+    NULL,                                    /* get_esync_fd */
     no_satisfied,                            /* satisfied */
     no_signal,                               /* signal */
     named_pipe_device_file_get_fd,           /* get_fd */
diff --git a/server/object.h b/server/object.h
index b5c50e1cee..b3d4e33344 100644
--- a/server/object.h
+++ b/server/object.h
@@ -68,6 +68,8 @@ struct object_ops
     void (*remove_queue)(struct object *,struct wait_queue_entry *);
     /* is object signaled? */
     int  (*signaled)(struct object *,struct wait_queue_entry *);
+    /* return the esync fd for this object */
+    int (*get_esync_fd)(struct object *);
     /* wait satisfied */
     void (*satisfied)(struct object *,struct wait_queue_entry *);
     /* signal an object */
diff --git a/server/process.c b/server/process.c
index e55c8a861e..9090469ffe 100644
--- a/server/process.c
+++ b/server/process.c
@@ -74,6 +74,7 @@ static const struct object_ops process_ops =
     add_queue,                   /* add_queue */
     remove_queue,                /* remove_queue */
     process_signaled,            /* signaled */
+    NULL,                        /* get_esync_fd */
     no_satisfied,                /* satisfied */
     no_signal,                   /* signal */
     no_get_fd,                   /* get_fd */
@@ -123,6 +124,7 @@ static const struct object_ops startup_info_ops =
     add_queue,                     /* add_queue */
     remove_queue,                  /* remove_queue */
     startup_info_signaled,         /* signaled */
+    NULL,                          /* get_esync_fd */
     no_satisfied,                  /* satisfied */
     no_signal,                     /* signal */
     no_get_fd,                     /* get_fd */
@@ -166,6 +168,7 @@ static const struct object_ops job_ops =
     add_queue,                     /* add_queue */
     remove_queue,                  /* remove_queue */
     job_signaled,                  /* signaled */
+    NULL,                          /* get_esync_fd */
     no_satisfied,                  /* satisfied */
     no_signal,                     /* signal */
     no_get_fd,                     /* get_fd */
diff --git a/server/queue.c b/server/queue.c
index 545991b99c..1de8d054d2 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -171,6 +171,7 @@ static const struct object_ops msg_queue_ops =
     msg_queue_add_queue,       /* add_queue */
     msg_queue_remove_queue,    /* remove_queue */
     msg_queue_signaled,        /* signaled */
+    NULL,                      /* get_esync_fd */
     msg_queue_satisfied,       /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
@@ -206,6 +207,7 @@ static const struct object_ops thread_input_ops =
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
diff --git a/server/registry.c b/server/registry.c
index dffa3acffd..81999899a5 100644
--- a/server/registry.c
+++ b/server/registry.c
@@ -160,6 +160,7 @@ static const struct object_ops key_ops =
     no_add_queue,            /* add_queue */
     NULL,                    /* remove_queue */
     NULL,                    /* signaled */
+    NULL,                    /* get_esync_fd */
     NULL,                    /* satisfied */
     no_signal,               /* signal */
     no_get_fd,               /* get_fd */
diff --git a/server/request.c b/server/request.c
index c10c4e6526..7420e4a5a4 100644
--- a/server/request.c
+++ b/server/request.c
@@ -97,6 +97,7 @@ static const struct object_ops master_socket_ops =
     no_add_queue,                  /* add_queue */
     NULL,                          /* remove_queue */
     NULL,                          /* signaled */
+    NULL,                          /* get_esync_fd */
     NULL,                          /* satisfied */
     no_signal,                     /* signal */
     no_get_fd,                     /* get_fd */
diff --git a/server/semaphore.c b/server/semaphore.c
index 08ff1536ce..82fc8705b3 100644
--- a/server/semaphore.c
+++ b/server/semaphore.c
@@ -58,6 +58,7 @@ static const struct object_ops semaphore_ops =
     add_queue,                     /* add_queue */
     remove_queue,                  /* remove_queue */
     semaphore_signaled,            /* signaled */
+    NULL,                          /* get_esync_fd */
     semaphore_satisfied,           /* satisfied */
     semaphore_signal,              /* signal */
     no_get_fd,                     /* get_fd */
diff --git a/server/serial.c b/server/serial.c
index f0adf92f3a..4b6c9f48ec 100644
--- a/server/serial.c
+++ b/server/serial.c
@@ -92,6 +92,7 @@ static const struct object_ops serial_ops =
     add_queue,                    /* add_queue */
     remove_queue,                 /* remove_queue */
     default_fd_signaled,          /* signaled */
+    NULL,                         /* get_esync_fd */
     no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     serial_get_fd,                /* get_fd */
diff --git a/server/signal.c b/server/signal.c
index 74416fab7b..281304e653 100644
--- a/server/signal.c
+++ b/server/signal.c
@@ -67,6 +67,7 @@ static const struct object_ops handler_ops =
     no_add_queue,             /* add_queue */
     NULL,                     /* remove_queue */
     NULL,                     /* signaled */
+    NULL,                     /* get_esync_fd */
     NULL,                     /* satisfied */
     no_signal,                /* signal */
     no_get_fd,                /* get_fd */
diff --git a/server/snapshot.c b/server/snapshot.c
index e35588a136..c5da45124e 100644
--- a/server/snapshot.c
+++ b/server/snapshot.c
@@ -61,6 +61,7 @@ static const struct object_ops snapshot_ops =
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
diff --git a/server/sock.c b/server/sock.c
index 284ab9ff78..b9ac5f35da 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -144,6 +144,7 @@ static const struct object_ops sock_ops =
     add_queue,                    /* add_queue */
     remove_queue,                 /* remove_queue */
     sock_signaled,                /* signaled */
+    NULL,                         /* get_esync_fd */
     no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     sock_get_fd,                  /* get_fd */
@@ -958,6 +959,7 @@ static const struct object_ops ifchange_ops =
     add_queue,               /* add_queue */
     NULL,                    /* remove_queue */
     NULL,                    /* signaled */
+    NULL,                    /* get_esync_fd */
     no_satisfied,            /* satisfied */
     no_signal,               /* signal */
     ifchange_get_fd,         /* get_fd */
diff --git a/server/symlink.c b/server/symlink.c
index 9199bc559d..ce8db56702 100644
--- a/server/symlink.c
+++ b/server/symlink.c
@@ -60,6 +60,7 @@ static const struct object_ops symlink_ops =
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
diff --git a/server/thread.c b/server/thread.c
index 7162fc33bd..e671ad8da2 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -110,6 +110,7 @@ static const struct object_ops thread_apc_ops =
     add_queue,                  /* add_queue */
     remove_queue,               /* remove_queue */
     thread_apc_signaled,        /* signaled */
+    NULL,                       /* get_esync_fd */
     no_satisfied,               /* satisfied */
     no_signal,                  /* signal */
     no_get_fd,                  /* get_fd */
@@ -141,6 +142,7 @@ static const struct object_ops thread_ops =
     add_queue,                  /* add_queue */
     remove_queue,               /* remove_queue */
     thread_signaled,            /* signaled */
+    NULL,                       /* get_esync_fd */
     no_satisfied,               /* satisfied */
     no_signal,                  /* signal */
     no_get_fd,                  /* get_fd */
diff --git a/server/timer.c b/server/timer.c
index 3a786fb4fc..810349ae8a 100644
--- a/server/timer.c
+++ b/server/timer.c
@@ -65,6 +65,7 @@ static const struct object_ops timer_ops =
     add_queue,                 /* add_queue */
     remove_queue,              /* remove_queue */
     timer_signaled,            /* signaled */
+    NULL,                      /* get_esync_fd */
     timer_satisfied,           /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
diff --git a/server/token.c b/server/token.c
index d88f16c4ce..31f0003c61 100644
--- a/server/token.c
+++ b/server/token.c
@@ -145,6 +145,7 @@ static const struct object_ops token_ops =
     no_add_queue,              /* add_queue */
     NULL,                      /* remove_queue */
     NULL,                      /* signaled */
+    NULL,                      /* get_esync_fd */
     NULL,                      /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
diff --git a/server/winstation.c b/server/winstation.c
index a0be058652..58e2213929 100644
--- a/server/winstation.c
+++ b/server/winstation.c
@@ -65,6 +65,7 @@ static const struct object_ops winstation_ops =
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
@@ -88,6 +89,7 @@ static const struct object_ops desktop_ops =
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
-- 
2.20.1


From 0ba1a1a9c3200f84e8903d02083d0f03aa14f42d Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 8 Jun 2018 18:55:49 -0500
Subject: [PATCH 14/83] server: Add a request to get the eventfd file
 descriptor associated with a waitable handle.

---
 include/wine/server_protocol.h | 14 ++++++++++++++
 server/esync.c                 | 28 ++++++++++++++++++++++++++++
 server/protocol.def            |  6 ++++++
 server/request.h               |  5 +++++
 server/trace.c                 |  8 ++++++++
 5 files changed, 61 insertions(+)

diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index 22eec04a38..c762cbbc4b 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -5681,6 +5681,17 @@ struct create_esync_reply
 };
 
 
+struct get_esync_fd_request
+{
+    struct request_header __header;
+    obj_handle_t handle;
+};
+struct get_esync_fd_reply
+{
+    struct reply_header __header;
+};
+
+
 enum request
 {
     REQ_new_process,
@@ -5975,6 +5986,7 @@ enum request
     REQ_set_job_completion_port,
     REQ_terminate_job,
     REQ_create_esync,
+    REQ_get_esync_fd,
     REQ_NB_REQUESTS
 };
 
@@ -6274,6 +6286,7 @@ union generic_request
     struct set_job_completion_port_request set_job_completion_port_request;
     struct terminate_job_request terminate_job_request;
     struct create_esync_request create_esync_request;
+    struct get_esync_fd_request get_esync_fd_request;
 };
 union generic_reply
 {
@@ -6571,6 +6584,7 @@ union generic_reply
     struct set_job_completion_port_reply set_job_completion_port_reply;
     struct terminate_job_reply terminate_job_reply;
     struct create_esync_reply create_esync_reply;
+    struct get_esync_fd_reply get_esync_fd_reply;
 };
 
 #define SERVER_PROTOCOL_VERSION 572
diff --git a/server/esync.c b/server/esync.c
index e761475678..e775b3bd28 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -135,3 +135,31 @@ DECL_HANDLER(create_esync)
 
     if (root) release_object( root );
 }
+
+/* Retrieve a file descriptor for an esync object which will be signaled by the
+ * server. The client should only read from (i.e. wait on) this object. */
+DECL_HANDLER(get_esync_fd)
+{
+    struct object *obj;
+    int fd;
+
+    if (!(obj = get_handle_obj( current->process, req->handle, SYNCHRONIZE, NULL )))
+        return;
+
+    if (obj->ops->get_esync_fd)
+    {
+        fd = obj->ops->get_esync_fd( obj );
+        send_client_fd( current->process, fd, req->handle );
+    }
+    else
+    {
+        if (debug_level)
+        {
+            fprintf( stderr, "%04x: esync: can't wait on object: ", current->id );
+            obj->ops->dump( obj, 0 );
+        }
+        set_error( STATUS_NOT_IMPLEMENTED );
+    }
+
+    release_object( obj );
+}
diff --git a/server/protocol.def b/server/protocol.def
index 7c2887f7f4..3732e4b752 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -3873,3 +3873,9 @@ struct handle_info
 @REPLY
     obj_handle_t handle;        /* handle to the object */
 @END
+
+/* Retrieve the esync fd for an object. */
+@REQ(get_esync_fd)
+    obj_handle_t handle;        /* handle to the object */
+@REPLY
+@END
diff --git a/server/request.h b/server/request.h
index 242143d2c3..272f79dc04 100644
--- a/server/request.h
+++ b/server/request.h
@@ -404,6 +404,7 @@ DECL_HANDLER(set_job_limits);
 DECL_HANDLER(set_job_completion_port);
 DECL_HANDLER(terminate_job);
 DECL_HANDLER(create_esync);
+DECL_HANDLER(get_esync_fd);
 
 #ifdef WANT_REQUEST_HANDLERS
 
@@ -702,6 +703,7 @@ static const req_handler req_handlers[REQ_NB_REQUESTS] =
     (req_handler)req_set_job_completion_port,
     (req_handler)req_terminate_job,
     (req_handler)req_create_esync,
+    (req_handler)req_get_esync_fd,
 };
 
 C_ASSERT( sizeof(affinity_t) == 8 );
@@ -2414,6 +2416,9 @@ C_ASSERT( FIELD_OFFSET(struct create_esync_request, flags) == 20 );
 C_ASSERT( sizeof(struct create_esync_request) == 24 );
 C_ASSERT( FIELD_OFFSET(struct create_esync_reply, handle) == 8 );
 C_ASSERT( sizeof(struct create_esync_reply) == 16 );
+C_ASSERT( FIELD_OFFSET(struct get_esync_fd_request, handle) == 12 );
+C_ASSERT( sizeof(struct get_esync_fd_request) == 16 );
+C_ASSERT( sizeof(struct get_esync_fd_reply) == 8 );
 
 #endif  /* WANT_REQUEST_HANDLERS */
 
diff --git a/server/trace.c b/server/trace.c
index ce8afba720..1ff29e273d 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -4554,6 +4554,11 @@ static void dump_create_esync_reply( const struct create_esync_reply *req )
     fprintf( stderr, " handle=%04x", req->handle );
 }
 
+static void dump_get_esync_fd_request( const struct get_esync_fd_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+}
+
 static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_new_process_request,
     (dump_func)dump_exec_process_request,
@@ -4847,6 +4852,7 @@ static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_set_job_completion_port_request,
     (dump_func)dump_terminate_job_request,
     (dump_func)dump_create_esync_request,
+    (dump_func)dump_get_esync_fd_request,
 };
 
 static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {
@@ -5142,6 +5148,7 @@ static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {
     NULL,
     NULL,
     (dump_func)dump_create_esync_reply,
+    NULL,
 };
 
 static const char * const req_names[REQ_NB_REQUESTS] = {
@@ -5437,6 +5444,7 @@ static const char * const req_names[REQ_NB_REQUESTS] = {
     "set_job_completion_port",
     "terminate_job",
     "create_esync",
+    "get_esync_fd",
 };
 
 static const struct
-- 
2.20.1


From 8d6c1c90eaaa3451c4b03d7f943acbb7c15984c1 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 8 Jun 2018 18:57:12 -0500
Subject: [PATCH 15/83] server: Create eventfd file descriptors for process
 objects.

---
 server/esync.c   | 33 +++++++++++++++++++++++++++++++++
 server/esync.h   | 22 ++++++++++++++++++++++
 server/process.c | 17 ++++++++++++++++-
 server/process.h |  1 +
 4 files changed, 72 insertions(+), 1 deletion(-)
 create mode 100644 server/esync.h

diff --git a/server/esync.c b/server/esync.c
index e775b3bd28..f50366a434 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -35,6 +35,21 @@
 #include "handle.h"
 #include "request.h"
 #include "file.h"
+#include "esync.h"
+
+int do_esync(void)
+{
+#ifdef HAVE_SYS_EVENTFD_H
+    static int do_esync_cached = -1;
+
+    if (do_esync_cached == -1)
+        do_esync_cached = (getenv("WINEESYNC") != NULL);
+
+    return do_esync_cached;
+#else
+    return 0;
+#endif
+}
 
 struct esync
 {
@@ -111,6 +126,24 @@ struct esync *create_esync( struct object *root, const struct unicode_str *name,
 #endif
 }
 
+/* Create a file descriptor for an existing handle.
+ * Caller must close the handle when it's done; it's not linked to an esync
+ * server object in any way. */
+int esync_create_fd( int initval, int flags )
+{
+#ifdef HAVE_SYS_EVENTFD_H
+    int fd;
+
+    fd = eventfd( initval, flags | EFD_CLOEXEC | EFD_NONBLOCK );
+    if (fd == -1)
+        perror( "eventfd" );
+
+    return fd;
+#else
+    return -1;
+#endif
+}
+
 DECL_HANDLER(create_esync)
 {
     struct esync *esync;
diff --git a/server/esync.h b/server/esync.h
new file mode 100644
index 0000000000..f93535b7b4
--- /dev/null
+++ b/server/esync.h
@@ -0,0 +1,22 @@
+/*
+ * eventfd-based synchronization objects
+ *
+ * Copyright (C) 2018 Zebediah Figura
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+extern int do_esync(void);
+int esync_create_fd( int initval, int flags );
diff --git a/server/process.c b/server/process.c
index 9090469ffe..ea981b7690 100644
--- a/server/process.c
+++ b/server/process.c
@@ -48,6 +48,7 @@
 #include "request.h"
 #include "user.h"
 #include "security.h"
+#include "esync.h"
 
 /* process structure */
 
@@ -64,6 +65,7 @@ static int process_signaled( struct object *obj, struct wait_queue_entry *entry
 static unsigned int process_map_access( struct object *obj, unsigned int access );
 static void process_poll_event( struct fd *fd, int event );
 static void process_destroy( struct object *obj );
+static int process_get_esync_fd( struct object *obj );
 static void terminate_process( struct process *process, struct thread *skip, int exit_code );
 
 static const struct object_ops process_ops =
@@ -74,7 +76,7 @@ static const struct object_ops process_ops =
     add_queue,                   /* add_queue */
     remove_queue,                /* remove_queue */
     process_signaled,            /* signaled */
-    NULL,                        /* get_esync_fd */
+    process_get_esync_fd,        /* get_esync_fd */
     no_satisfied,                /* satisfied */
     no_signal,                   /* signal */
     no_get_fd,                   /* get_fd */
@@ -525,6 +527,7 @@ struct process *create_process( int fd, struct process *parent, int inherit_all,
     process->trace_data      = 0;
     process->rawinput_mouse  = NULL;
     process->rawinput_kbd    = NULL;
+    process->esync_fd        = -1;
     list_init( &process->thread_list );
     list_init( &process->locks );
     list_init( &process->asyncs );
@@ -574,6 +577,9 @@ struct process *create_process( int fd, struct process *parent, int inherit_all,
     if (!token_assign_label( process->token, security_high_label_sid ))
         goto error;
 
+    if (do_esync())
+        process->esync_fd = esync_create_fd( 0, 0 );
+
     set_fd_events( process->msg_fd, POLLIN );  /* start listening to events */
     return process;
 
@@ -622,6 +628,9 @@ static void process_destroy( struct object *obj )
     if (process->id) free_ptid( process->id );
     if (process->token) release_object( process->token );
     free( process->dir_cache );
+
+    if (do_esync())
+        close( process->esync_fd );
 }
 
 /* dump a process on stdout for debugging purposes */
@@ -639,6 +648,12 @@ static int process_signaled( struct object *obj, struct wait_queue_entry *entry
     return !process->running_threads;
 }
 
+static int process_get_esync_fd( struct object *obj )
+{
+    struct process *process = (struct process *)obj;
+    return process->esync_fd;
+}
+
 static unsigned int process_map_access( struct object *obj, unsigned int access )
 {
     if (access & GENERIC_READ)    access |= STANDARD_RIGHTS_READ | PROCESS_QUERY_INFORMATION | PROCESS_VM_READ;
diff --git a/server/process.h b/server/process.h
index 4566a04b48..1d5299a08b 100644
--- a/server/process.h
+++ b/server/process.h
@@ -96,6 +96,7 @@ struct process
     struct list          rawinput_devices;/* list of registered rawinput devices */
     const struct rawinput_device *rawinput_mouse; /* rawinput mouse device, if any */
     const struct rawinput_device *rawinput_kbd;   /* rawinput keyboard device, if any */
+    int                  esync_fd;        /* esync file descriptor (signaled on exit) */
 };
 
 struct process_snapshot
-- 
2.20.1


From b45004f2cc4d5f487337bc329b10696d1554a312 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 8 Jun 2018 19:25:05 -0500
Subject: [PATCH 16/83] ntdll, server: Implement waiting on server-bound
 objects.

The code here is sort of self-explanatory, but since I split it up over
several patches I'll provide a quick explanation. The basic principle is
that we can create an eventfd descriptor for any synchronizable handle, and
signal it on the server side whenever a wakeup would be triggered. This means
not only that we can wait simultaneously on esync primitives and on other
primitives, but that we can do it all in "user-mode", i.e. without having to
make a server call.

With this patch we break waiting on svcctl.exe.
---
 dlls/ntdll/esync.c | 68 +++++++++++++++++++++++++++++++++++++++++++---
 server/esync.c     | 15 ++++++++++
 server/esync.h     |  1 +
 server/thread.c    |  4 +++
 4 files changed, 84 insertions(+), 4 deletions(-)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index e8c34bda3a..870e42840b 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -78,6 +78,7 @@ enum esync_type
     ESYNC_SEMAPHORE = 1,
     ESYNC_AUTO_EVENT,
     ESYNC_MANUAL_EVENT,
+    ESYNC_MANUAL_SERVER,
 };
 
 struct esync
@@ -149,6 +150,63 @@ static void *esync_get_object( HANDLE handle )
     return esync_list[entry][idx];
 }
 
+/* Gets a waitable object. This is either a proper esync object (i.e. an event,
+ * semaphore, etc. created using create_esync) or a generic synchronizable
+ * server-side object which the server will signal (e.g. a process, thread,
+ * message queue, etc.) */
+static NTSTATUS get_waitable_object( HANDLE handle, struct esync **obj )
+{
+    obj_handle_t fd_handle;
+    struct esync *esync;
+    sigset_t sigset;
+    NTSTATUS ret;
+    int fd;
+
+    if ((*obj = esync_get_object( handle ))) return STATUS_SUCCESS;
+
+    /* We need to try grabbing it from the server. */
+    server_enter_uninterrupted_section( &fd_cache_section, &sigset );
+    if (!(esync = esync_get_object( handle )))
+    {
+        SERVER_START_REQ( get_esync_fd )
+        {
+            req->handle = wine_server_obj_handle( handle );
+            if (!(ret = wine_server_call( req )))
+            {
+                fd = receive_fd( &fd_handle );
+                assert( wine_server_ptr_handle(fd_handle) == handle );
+            }
+        }
+        SERVER_END_REQ;
+    }
+    server_leave_uninterrupted_section( &fd_cache_section, &sigset );
+
+    if (esync)
+    {
+        /* We managed to grab it while in the CS; return it. */
+        *obj = esync;
+        return STATUS_SUCCESS;
+    }
+
+    if (ret)
+    {
+        WARN("Failed to retrieve fd for handle %p, status %#x.\n", handle, ret);
+        *obj = NULL;
+        return ret;
+    }
+
+    TRACE("Got fd %d for handle %p.\n", fd, handle);
+
+    esync = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*esync) );
+    esync->fd = fd;
+    esync->type = ESYNC_MANUAL_SERVER;
+
+    add_to_list( handle, esync );
+
+    *obj = esync;
+    return ret;
+}
+
 NTSTATUS esync_close( HANDLE handle )
 {
     UINT_PTR entry, idx = handle_to_index( handle, &entry );
@@ -391,11 +449,13 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
 
     for (i = 0; i < count; i++)
     {
-        objs[i] = esync_get_object( handles[i] );
-        if (objs[i])
+        ret = get_waitable_object( handles[i], &objs[i] );
+        if (ret == STATUS_SUCCESS)
             has_esync = 1;
-        else
+        else if (ret == STATUS_NOT_IMPLEMENTED)
             has_server = 1;
+        else
+            return ret;
     }
 
     if (has_esync && has_server)
@@ -452,7 +512,7 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
                         int64_t value;
                         ssize_t size;
 
-                        if (objs[i]->type == ESYNC_MANUAL_EVENT)
+                        if (objs[i]->type == ESYNC_MANUAL_EVENT || objs[i]->type == ESYNC_MANUAL_SERVER)
                         {
                             /* Don't grab the object, just check if it's signaled. */
                             if (fds[i].revents & POLLIN)
diff --git a/server/esync.c b/server/esync.c
index f50366a434..2e93493af1 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -144,6 +144,21 @@ int esync_create_fd( int initval, int flags )
 #endif
 }
 
+/* Wake up a server-side esync object. */
+void esync_wake_up( struct object *obj )
+{
+    static const uint64_t value = 1;
+    int fd;
+
+    if (obj->ops->get_esync_fd)
+    {
+        fd = obj->ops->get_esync_fd( obj );
+
+        if (write( fd, &value, sizeof(value) ) == -1)
+            perror( "esync: write" );
+    }
+}
+
 DECL_HANDLER(create_esync)
 {
     struct esync *esync;
diff --git a/server/esync.h b/server/esync.h
index f93535b7b4..bbfe0aef8f 100644
--- a/server/esync.h
+++ b/server/esync.h
@@ -20,3 +20,4 @@
 
 extern int do_esync(void);
 int esync_create_fd( int initval, int flags );
+void esync_wake_up( struct object *obj );
diff --git a/server/thread.c b/server/thread.c
index e671ad8da2..f5ad0f066c 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -51,6 +51,7 @@
 #include "request.h"
 #include "user.h"
 #include "security.h"
+#include "esync.h"
 
 
 #ifdef __i386__
@@ -919,6 +920,9 @@ void wake_up( struct object *obj, int max )
     struct list *ptr;
     int ret;
 
+    if (do_esync())
+        esync_wake_up( obj );
+
     LIST_FOR_EACH( ptr, &obj->wait_queue )
     {
         struct wait_queue_entry *entry = LIST_ENTRY( ptr, struct wait_queue_entry, entry );
-- 
2.20.1


From 9f3ff601ab4066f76b291644295184fb3c1747c2 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 8 Jun 2018 21:01:24 -0500
Subject: [PATCH 17/83] server: Create eventfd file descriptors for event
 objects.

We still need this, since there are some events which the server signals.

This lets system processes shut down.
---
 server/esync.c |  8 ++++++++
 server/esync.h |  1 +
 server/event.c | 28 ++++++++++++++++++++++++++--
 3 files changed, 35 insertions(+), 2 deletions(-)

diff --git a/server/esync.c b/server/esync.c
index 2e93493af1..e933d289b4 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -159,6 +159,14 @@ void esync_wake_up( struct object *obj )
     }
 }
 
+void esync_clear( int fd )
+{
+    uint64_t value;
+
+    /* we don't care about the return value */
+    read( fd, &value, sizeof(value) );
+}
+
 DECL_HANDLER(create_esync)
 {
     struct esync *esync;
diff --git a/server/esync.h b/server/esync.h
index bbfe0aef8f..054a771901 100644
--- a/server/esync.h
+++ b/server/esync.h
@@ -21,3 +21,4 @@
 extern int do_esync(void);
 int esync_create_fd( int initval, int flags );
 void esync_wake_up( struct object *obj );
+void esync_clear( int fd );
diff --git a/server/event.c b/server/event.c
index a85be8de3d..41b4d6e054 100644
--- a/server/event.c
+++ b/server/event.c
@@ -35,20 +35,24 @@
 #include "thread.h"
 #include "request.h"
 #include "security.h"
+#include "esync.h"
 
 struct event
 {
     struct object  obj;             /* object header */
     int            manual_reset;    /* is it a manual reset event? */
     int            signaled;        /* event has been signaled */
+    int            esync_fd;        /* esync file descriptor */
 };
 
 static void event_dump( struct object *obj, int verbose );
 static struct object_type *event_get_type( struct object *obj );
 static int event_signaled( struct object *obj, struct wait_queue_entry *entry );
+static int event_get_esync_fd( struct object *obj );
 static void event_satisfied( struct object *obj, struct wait_queue_entry *entry );
 static unsigned int event_map_access( struct object *obj, unsigned int access );
 static int event_signal( struct object *obj, unsigned int access);
+static void event_destroy( struct object *obj );
 
 static const struct object_ops event_ops =
 {
@@ -58,7 +62,7 @@ static const struct object_ops event_ops =
     add_queue,                 /* add_queue */
     remove_queue,              /* remove_queue */
     event_signaled,            /* signaled */
-    NULL,                      /* get_esync_fd */
+    event_get_esync_fd,        /* get_esync_fd */
     event_satisfied,           /* satisfied */
     event_signal,              /* signal */
     no_get_fd,                 /* get_fd */
@@ -70,7 +74,7 @@ static const struct object_ops event_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_close_handle,           /* close_handle */
-    no_destroy                 /* destroy */
+    event_destroy              /* destroy */
 };
 
 
@@ -121,6 +125,9 @@ struct event *create_event( struct object *root, const struct unicode_str *name,
             /* initialize it if it didn't already exist */
             event->manual_reset = manual_reset;
             event->signaled     = initial_state;
+
+            if (do_esync())
+                event->esync_fd = esync_create_fd( initial_state, 0 );
         }
     }
     return event;
@@ -149,6 +156,9 @@ void set_event( struct event *event )
 void reset_event( struct event *event )
 {
     event->signaled = 0;
+
+    if (do_esync())
+        esync_clear( event->esync_fd );
 }
 
 static void event_dump( struct object *obj, int verbose )
@@ -173,6 +183,12 @@ static int event_signaled( struct object *obj, struct wait_queue_entry *entry )
     return event->signaled;
 }
 
+static int event_get_esync_fd( struct object *obj )
+{
+    struct event *event = (struct event *)obj;
+    return event->esync_fd;
+}
+
 static void event_satisfied( struct object *obj, struct wait_queue_entry *entry )
 {
     struct event *event = (struct event *)obj;
@@ -204,6 +220,14 @@ static int event_signal( struct object *obj, unsigned int access )
     return 1;
 }
 
+static void event_destroy( struct object *obj )
+{
+    struct event *event = (struct event *)obj;
+
+    if (do_esync())
+        close( event->esync_fd );
+}
+
 struct keyed_event *create_keyed_event( struct object *root, const struct unicode_str *name,
                                         unsigned int attr, const struct security_descriptor *sd )
 {
-- 
2.20.1


From 687c64bb5faae67f64b4bde9a6906f172da9cc5a Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 8 Jun 2018 21:43:37 -0500
Subject: [PATCH 18/83] server: Allow (re)setting esync events on the server
 side.

Some server calls pass an event handle, most notably asyncs. We need to be
able to handle these correctly. Accordingly we pass them along to esync if
it turns out the underlying object is actually an esync object.

In an ideal world we'd just convert all instances of events on the server
side to use esyncs instead. But we want to keep esync perfectly configurable,
so this is how we do it.
---
 server/esync.c | 22 +++++++++++++++++++++-
 server/esync.h |  6 ++++++
 server/event.c | 15 +++++++++++++++
 3 files changed, 42 insertions(+), 1 deletion(-)

diff --git a/server/esync.c b/server/esync.c
index e933d289b4..4682163687 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -60,7 +60,7 @@ struct esync
 static void esync_dump( struct object *obj, int verbose );
 static void esync_destroy( struct object *obj );
 
-static const struct object_ops esync_ops =
+const struct object_ops esync_ops =
 {
     sizeof(struct esync),      /* size */
     esync_dump,                /* dump */
@@ -167,6 +167,26 @@ void esync_clear( int fd )
     read( fd, &value, sizeof(value) );
 }
 
+/* Server-side event support. */
+void esync_set_event( struct esync *esync )
+{
+    static const uint64_t value = 1;
+
+    assert( esync->obj.ops == &esync_ops );
+    if (write( esync->fd, &value, sizeof(value) ) == -1)
+        perror( "esync: write" );
+}
+
+void esync_reset_event( struct esync *esync )
+{
+    static uint64_t value = 1;
+
+    assert( esync->obj.ops == &esync_ops );
+
+    /* we don't care about the return value */
+    read( esync->fd, &value, sizeof(value) );
+}
+
 DECL_HANDLER(create_esync)
 {
     struct esync *esync;
diff --git a/server/esync.h b/server/esync.h
index 054a771901..2687c72e41 100644
--- a/server/esync.h
+++ b/server/esync.h
@@ -22,3 +22,9 @@ extern int do_esync(void);
 int esync_create_fd( int initval, int flags );
 void esync_wake_up( struct object *obj );
 void esync_clear( int fd );
+
+struct esync;
+
+extern const struct object_ops esync_ops;
+void esync_set_event( struct esync *esync );
+void esync_reset_event( struct esync *esync );
diff --git a/server/event.c b/server/event.c
index 41b4d6e054..0ae35de81c 100644
--- a/server/event.c
+++ b/server/event.c
@@ -135,6 +135,10 @@ struct event *create_event( struct object *root, const struct unicode_str *name,
 
 struct event *get_event_obj( struct process *process, obj_handle_t handle, unsigned int access )
 {
+    struct object *obj;
+    if (do_esync() && (obj = get_handle_obj( process, handle, access, &esync_ops)))
+        return (struct event *)obj; /* even though it's not an event */
+
     return (struct event *)get_handle_obj( process, handle, access, &event_ops );
 }
 
@@ -148,6 +152,12 @@ void pulse_event( struct event *event )
 
 void set_event( struct event *event )
 {
+    if (do_esync() && event->obj.ops == &esync_ops)
+    {
+        esync_set_event( (struct esync *)event );
+        return;
+    }
+
     event->signaled = 1;
     /* wake up all waiters if manual reset, a single one otherwise */
     wake_up( &event->obj, !event->manual_reset );
@@ -155,6 +165,11 @@ void set_event( struct event *event )
 
 void reset_event( struct event *event )
 {
+    if (do_esync() && event->obj.ops == &esync_ops)
+    {
+        esync_reset_event( (struct esync *)event );
+        return;
+    }
     event->signaled = 0;
 
     if (do_esync())
-- 
2.20.1


From 18a36f99a8c6c6e8b6625ccdb0f3bc31df5f77af Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 8 Jun 2018 21:58:37 -0500
Subject: [PATCH 19/83] ntdll: Try again if poll() returns EINTR.

I originally had this return STATUS_USER_APC, but that isn't correct. The
server code here is a bit confusing, but only the thread that waits *during*
the suspend should receive STATUS_USER_APC (and I imagine that it really
should receive STATUS_KERNEL_APC instead). The thread that is suspended
should just keep on waiting.

Besides, we could be suspended for reasons other than to deliver a system
APC.
---
 dlls/ntdll/esync.c | 32 +++++++++++++++++++++-----------
 1 file changed, 21 insertions(+), 11 deletions(-)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 870e42840b..f77c84a18f 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -404,22 +404,32 @@ static LONGLONG update_timeout( ULONGLONG end )
 
 static int do_poll( struct pollfd *fds, nfds_t nfds, ULONGLONG *end )
 {
-    if (end)
+    int ret;
+
+    do
     {
-        LONGLONG timeleft = update_timeout( *end );
+        if (end)
+        {
+            LONGLONG timeleft = update_timeout( *end );
 
 #ifdef HAVE_PPOLL
-        /* We use ppoll() if available since the time granularity is better. */
-        struct timespec tmo_p;
-        tmo_p.tv_sec = timeleft / (ULONGLONG)TICKSPERSEC;
-        tmo_p.tv_nsec = (timeleft % TICKSPERSEC) * 100;
-        return ppoll( fds, nfds, &tmo_p, NULL );
+            /* We use ppoll() if available since the time granularity is better. */
+            struct timespec tmo_p;
+            tmo_p.tv_sec = timeleft / (ULONGLONG)TICKSPERSEC;
+            tmo_p.tv_nsec = (timeleft % TICKSPERSEC) * 100;
+            ret = ppoll( fds, nfds, &tmo_p, NULL );
 #else
-        return poll( fds, nfds, timeleft / TICKSPERMSEC );
+            ret = poll( fds, nfds, timeleft / TICKSPERMSEC );
 #endif
-    }
-    else
-        return poll( fds, nfds, -1 );
+        }
+        else
+            ret = poll( fds, nfds, -1 );
+
+    /* If we receive EINTR we were probably suspended (SIGUSR1), possibly for a
+     * system APC. The right thing to do is just try again. */
+    } while (ret < 0 && errno == EINTR);
+
+    return ret;
 }
 
 /* A value of STATUS_NOT_IMPLEMENTED returned from this function means that we
-- 
2.20.1


From 9a014eaf9dda704cfab940cc07f6bbc19a646c15 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 8 Jun 2018 22:04:29 -0500
Subject: [PATCH 20/83] server: Create eventfd file descriptors for thread
 objects.

---
 server/thread.c | 16 +++++++++++++++-
 server/thread.h |  1 +
 2 files changed, 16 insertions(+), 1 deletion(-)

diff --git a/server/thread.c b/server/thread.c
index f5ad0f066c..722c133847 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -131,6 +131,7 @@ static const struct object_ops thread_apc_ops =
 
 static void dump_thread( struct object *obj, int verbose );
 static int thread_signaled( struct object *obj, struct wait_queue_entry *entry );
+static int thread_get_esync_fd( struct object *obj );
 static unsigned int thread_map_access( struct object *obj, unsigned int access );
 static void thread_poll_event( struct fd *fd, int event );
 static void destroy_thread( struct object *obj );
@@ -143,7 +144,7 @@ static const struct object_ops thread_ops =
     add_queue,                  /* add_queue */
     remove_queue,               /* remove_queue */
     thread_signaled,            /* signaled */
-    NULL,                       /* get_esync_fd */
+    thread_get_esync_fd,        /* get_esync_fd */
     no_satisfied,               /* satisfied */
     no_signal,                  /* signal */
     no_get_fd,                  /* get_fd */
@@ -202,6 +203,7 @@ static inline void init_thread_structure( struct thread *thread )
     thread->suspend         = 0;
     thread->desktop_users   = 0;
     thread->token           = NULL;
+    thread->esync_fd        = -1;
 
     thread->creation_time = current_time;
     thread->exit_time     = 0;
@@ -286,6 +288,9 @@ struct thread *create_thread( int fd, struct process *process, const struct secu
         return NULL;
     }
 
+    if (do_esync())
+        thread->esync_fd = esync_create_fd( 0, 0 );
+
     set_fd_events( thread->request_fd, POLLIN );  /* start listening to events */
     add_process_thread( thread->process, thread );
     return thread;
@@ -352,6 +357,9 @@ static void destroy_thread( struct object *obj )
     release_object( thread->process );
     if (thread->id) free_ptid( thread->id );
     if (thread->token) release_object( thread->token );
+
+    if (do_esync())
+        close( thread->esync_fd );
 }
 
 /* dump a thread on stdout for debugging purposes */
@@ -370,6 +378,12 @@ static int thread_signaled( struct object *obj, struct wait_queue_entry *entry )
     return (mythread->state == TERMINATED);
 }
 
+static int thread_get_esync_fd( struct object *obj )
+{
+    struct thread *thread = (struct thread *)obj;
+    return thread->esync_fd;
+}
+
 static unsigned int thread_map_access( struct object *obj, unsigned int access )
 {
     if (access & GENERIC_READ)    access |= STANDARD_RIGHTS_READ | THREAD_QUERY_INFORMATION | THREAD_GET_CONTEXT;
diff --git a/server/thread.h b/server/thread.h
index e4332df4ab..fc3ca4b701 100644
--- a/server/thread.h
+++ b/server/thread.h
@@ -89,6 +89,7 @@ struct thread
     timeout_t              creation_time; /* Thread creation time */
     timeout_t              exit_time;     /* Thread exit time */
     struct token          *token;         /* security token associated with this thread */
+    int                    esync_fd;      /* esync file descriptor (signalled on exit) */
 };
 
 struct thread_snapshot
-- 
2.20.1


From 5c5b32bdc2c168627c6a46ea34912d393f3b4dd6 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 8 Jun 2018 23:30:17 -0500
Subject: [PATCH 21/83] rpcrt4: Avoid closing the server thread handle while it
 is being waited on.

This, or something like this, should go upstream. This is invalid behaviour.
---
 dlls/rpcrt4/rpc_server.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/dlls/rpcrt4/rpc_server.c b/dlls/rpcrt4/rpc_server.c
index 91de3b95fa..af79dc56cf 100644
--- a/dlls/rpcrt4/rpc_server.c
+++ b/dlls/rpcrt4/rpc_server.c
@@ -702,10 +702,6 @@ static DWORD CALLBACK RPCRT4_server_thread(LPVOID the_arg)
   }
   LeaveCriticalSection(&cps->cs);
 
-  EnterCriticalSection(&listen_cs);
-  CloseHandle(cps->server_thread);
-  cps->server_thread = NULL;
-  LeaveCriticalSection(&listen_cs);
   TRACE("done\n");
   return 0;
 }
@@ -1573,7 +1569,10 @@ RPC_STATUS WINAPI RpcMgmtWaitServerListen( void )
       LIST_FOR_EACH_ENTRY(protseq, &protseqs, RpcServerProtseq, entry)
       {
           if ((wait_thread = protseq->server_thread))
+          {
+              protseq->server_thread = NULL;
               break;
+          }
       }
       LeaveCriticalSection(&server_cs);
       if (!wait_thread)
@@ -1582,6 +1581,7 @@ RPC_STATUS WINAPI RpcMgmtWaitServerListen( void )
       TRACE("waiting for thread %u\n", GetThreadId(wait_thread));
       LeaveCriticalSection(&listen_cs);
       WaitForSingleObject(wait_thread, INFINITE);
+      CloseHandle(wait_thread);
       EnterCriticalSection(&listen_cs);
   }
   if (listen_done_event == event)
-- 
2.20.1


From d2bb56fc148c03af004cd0da21d91fbabda2920c Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 8 Jun 2018 23:41:54 -0500
Subject: [PATCH 22/83] server: Create eventfd file descriptors for message
 queues.

Note that we don't have to worry about races here, because a thread can only
check its own queue.
---
 server/queue.c | 24 +++++++++++++++++++++++-
 1 file changed, 23 insertions(+), 1 deletion(-)

diff --git a/server/queue.c b/server/queue.c
index 1de8d054d2..a0393a4fcb 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -43,6 +43,7 @@
 #include "process.h"
 #include "request.h"
 #include "user.h"
+#include "esync.h"
 
 #define WM_NCMOUSEFIRST WM_NCMOUSEMOVE
 #define WM_NCMOUSELAST  (WM_NCMOUSEFIRST+(WM_MOUSELAST-WM_MOUSEFIRST))
@@ -140,6 +141,7 @@ struct msg_queue
     struct thread_input   *input;           /* thread input descriptor */
     struct hook_table     *hooks;           /* hook table */
     timeout_t              last_get_msg;    /* time of last get message call */
+    int                    esync_fd;        /* esync file descriptor (signalled on message) */
 };
 
 struct hotkey
@@ -156,6 +158,7 @@ static void msg_queue_dump( struct object *obj, int verbose );
 static int msg_queue_add_queue( struct object *obj, struct wait_queue_entry *entry );
 static void msg_queue_remove_queue( struct object *obj, struct wait_queue_entry *entry );
 static int msg_queue_signaled( struct object *obj, struct wait_queue_entry *entry );
+static int msg_queue_get_esync_fd( struct object *obj );
 static void msg_queue_satisfied( struct object *obj, struct wait_queue_entry *entry );
 static void msg_queue_destroy( struct object *obj );
 static void msg_queue_poll_event( struct fd *fd, int event );
@@ -171,7 +174,7 @@ static const struct object_ops msg_queue_ops =
     msg_queue_add_queue,       /* add_queue */
     msg_queue_remove_queue,    /* remove_queue */
     msg_queue_signaled,        /* signaled */
-    NULL,                      /* get_esync_fd */
+    msg_queue_get_esync_fd,    /* get_esync_fd */
     msg_queue_satisfied,       /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
@@ -300,12 +303,16 @@ static struct msg_queue *create_msg_queue( struct thread *thread, struct thread_
         queue->input           = (struct thread_input *)grab_object( input );
         queue->hooks           = NULL;
         queue->last_get_msg    = current_time;
+        queue->esync_fd        = -1;
         list_init( &queue->send_result );
         list_init( &queue->callback_result );
         list_init( &queue->pending_timers );
         list_init( &queue->expired_timers );
         for (i = 0; i < NB_MSG_KINDS; i++) list_init( &queue->msg_list[i] );
 
+        if (do_esync())
+            queue->esync_fd = esync_create_fd( 0, 0 );
+
         thread->queue = queue;
     }
     if (new_input) release_object( new_input );
@@ -461,6 +468,9 @@ static inline void clear_queue_bits( struct msg_queue *queue, unsigned int bits
 {
     queue->wake_bits &= ~bits;
     queue->changed_bits &= ~bits;
+
+    if (do_esync() && !is_signaled( queue ))
+        esync_clear( queue->esync_fd );
 }
 
 /* check whether msg is a keyboard message */
@@ -965,6 +975,12 @@ static int msg_queue_signaled( struct object *obj, struct wait_queue_entry *entr
     return ret || is_signaled( queue );
 }
 
+static int msg_queue_get_esync_fd( struct object *obj )
+{
+    struct msg_queue *queue = (struct msg_queue *)obj;
+    return queue->esync_fd;
+}
+
 static void msg_queue_satisfied( struct object *obj, struct wait_queue_entry *entry )
 {
     struct msg_queue *queue = (struct msg_queue *)obj;
@@ -1008,6 +1024,9 @@ static void msg_queue_destroy( struct object *obj )
     release_object( queue->input );
     if (queue->hooks) release_object( queue->hooks );
     if (queue->fd) release_object( queue->fd );
+
+    if (do_esync())
+        close( queue->esync_fd );
 }
 
 static void msg_queue_poll_event( struct fd *fd, int event )
@@ -2238,6 +2257,9 @@ DECL_HANDLER(get_queue_status)
         reply->wake_bits    = queue->wake_bits;
         reply->changed_bits = queue->changed_bits;
         queue->changed_bits &= ~req->clear_bits;
+
+        if (do_esync() && !is_signaled( queue ))
+            esync_clear( queue->esync_fd );
     }
     else reply->wake_bits = reply->changed_bits = 0;
 }
-- 
2.20.1


From 56d25683ee1aa4ceccc43cf58e6a0fbbe096f010 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Tue, 12 Jun 2018 10:01:08 -0500
Subject: [PATCH 23/83] ntdll, wineandroid.drv, winemac.drv, winex11.drv: Store
 the thread's queue fd in ntdll.

I originally had esync grab it from the server in order to avoid touching the USER drivers, but this doesn't really work since we might perform a MsgWait before ever doing any operations which might initialize the USER driver's thread data. Doing it this way also has the advantage that we won't use extra file descriptors.

In any case I haven't bothered to guard this code with do_esync(); it'd require adding that function to each USER driver and it's pretty obvious it's not going to affect anything if esync is disabled.
---
 dlls/ntdll/esync.c             | 6 ++++++
 dlls/ntdll/ntdll.spec          | 2 ++
 dlls/ntdll/ntdll_misc.h        | 1 +
 dlls/ntdll/thread.c            | 2 ++
 dlls/wineandroid.drv/window.c  | 3 +++
 dlls/winemac.drv/macdrv_main.c | 3 +++
 dlls/winex11.drv/x11drv_main.c | 3 +++
 7 files changed, 20 insertions(+)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index f77c84a18f..c4faf69a13 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -73,6 +73,12 @@ int do_esync(void)
 #endif
 }
 
+/* Entry point for drivers to set queue fd. */
+void __wine_esync_set_queue_fd( int fd )
+{
+    ntdll_get_thread_data()->esync_queue_fd = fd;
+}
+
 enum esync_type
 {
     ESYNC_SEMAPHORE = 1,
diff --git a/dlls/ntdll/ntdll.spec b/dlls/ntdll/ntdll.spec
index 649774f48a..fe96472cb8 100644
--- a/dlls/ntdll/ntdll.spec
+++ b/dlls/ntdll/ntdll.spec
@@ -1522,3 +1522,5 @@
 # Filesystem
 @ cdecl wine_nt_to_unix_file_name(ptr ptr long long)
 @ cdecl wine_unix_to_nt_file_name(ptr ptr)
+
+@ cdecl __wine_esync_set_queue_fd(long)
diff --git a/dlls/ntdll/ntdll_misc.h b/dlls/ntdll/ntdll_misc.h
index effcd4ce7a..ffe2788175 100644
--- a/dlls/ntdll/ntdll_misc.h
+++ b/dlls/ntdll/ntdll_misc.h
@@ -238,6 +238,7 @@ struct ntdll_thread_data
     int                wait_fd[2];    /* fd for sleeping server requests */
     BOOL               wow64_redir;   /* Wow64 filesystem redirection flag */
     pthread_t          pthread_id;    /* pthread thread id */
+    int                esync_queue_fd;/* fd to wait on for driver events */
 };
 
 C_ASSERT( sizeof(struct ntdll_thread_data) <= sizeof(((TEB *)0)->GdiTebBatch) );
diff --git a/dlls/ntdll/thread.c b/dlls/ntdll/thread.c
index 9f4a08fdb9..212cd92836 100644
--- a/dlls/ntdll/thread.c
+++ b/dlls/ntdll/thread.c
@@ -232,6 +232,7 @@ void thread_init(void)
     thread_data->wait_fd[0] = -1;
     thread_data->wait_fd[1] = -1;
     thread_data->debug_info = &debug_info;
+    thread_data->esync_queue_fd = -1;
 
     signal_init_thread( teb );
     virtual_init_threading();
@@ -522,6 +523,7 @@ NTSTATUS WINAPI RtlCreateUserThread( HANDLE process, SECURITY_DESCRIPTOR *descr,
     thread_data->wait_fd[0]  = -1;
     thread_data->wait_fd[1]  = -1;
     thread_data->start_stack = (char *)teb->Tib.StackBase;
+    thread_data->esync_queue_fd = -1;
 
     pthread_attr_init( &attr );
     pthread_attr_setstack( &attr, teb->DeallocationStack,
diff --git a/dlls/wineandroid.drv/window.c b/dlls/wineandroid.drv/window.c
index eb05aaf283..2fc258dfd9 100644
--- a/dlls/wineandroid.drv/window.c
+++ b/dlls/wineandroid.drv/window.c
@@ -364,6 +364,8 @@ jboolean motion_event( JNIEnv *env, jobject obj, jint win, jint action, jint x,
 }
 
 
+extern void __wine_esync_set_queue_fd( int fd );
+
 /***********************************************************************
  *           init_event_queue
  */
@@ -377,6 +379,7 @@ static void init_event_queue(void)
         ERR( "could not create data\n" );
         ExitProcess(1);
     }
+    __wine_esync_set_queue_fd( event_pipe[0] );
     if (wine_server_fd_to_handle( event_pipe[0], GENERIC_READ | SYNCHRONIZE, 0, &handle ))
     {
         ERR( "Can't allocate handle for event fd\n" );
diff --git a/dlls/winemac.drv/macdrv_main.c b/dlls/winemac.drv/macdrv_main.c
index 544d448f9f..5dfa54966d 100644
--- a/dlls/winemac.drv/macdrv_main.c
+++ b/dlls/winemac.drv/macdrv_main.c
@@ -321,6 +321,7 @@ void CDECL macdrv_ThreadDetach(void)
     }
 }
 
+extern void __wine_esync_set_queue_fd( int fd );
 
 /***********************************************************************
  *              set_queue_display_fd
@@ -332,6 +333,8 @@ static void set_queue_display_fd(int fd)
     HANDLE handle;
     int ret;
 
+    __wine_esync_set_queue_fd(fd);
+
     if (wine_server_fd_to_handle(fd, GENERIC_READ | SYNCHRONIZE, 0, &handle))
     {
         MESSAGE("macdrv: Can't allocate handle for event queue fd\n");
diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index e67a3c05a9..b441834106 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -619,6 +619,7 @@ void CDECL X11DRV_ThreadDetach(void)
     }
 }
 
+extern void __wine_esync_set_queue_fd( int fd );
 
 /* store the display fd into the message queue */
 static void set_queue_display_fd( Display *display )
@@ -626,6 +627,8 @@ static void set_queue_display_fd( Display *display )
     HANDLE handle;
     int ret;
 
+    __wine_esync_set_queue_fd( ConnectionNumber(display) );
+
     if (wine_server_fd_to_handle( ConnectionNumber(display), GENERIC_READ | SYNCHRONIZE, 0, &handle ))
     {
         MESSAGE( "x11drv: Can't allocate handle for display fd\n" );
-- 
2.20.1


From aba5bd58973040a9c5e8e72ee795cdf622041fad Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 9 Jun 2018 14:44:54 -0500
Subject: [PATCH 24/83] server, ntdll: Also wait on the queue fd when waiting
 for driver events.

Normally the server handles this, by polling on the fd during its main loop.
The problem there is that the server only polls when the thread is waiting
for messages. We want to replicate that behaviour, otherwise wineserver spins
forever trying to wake up a thread that just doesn't care.

With this patch, I'm finally able to interact with winecfg. Next step is to
fix the 'drives' tab.
---
 dlls/ntdll/esync.c             | 44 ++++++++++++++++++++++++----------
 include/wine/server_protocol.h | 11 +++++++++
 server/esync.c                 |  7 ++++--
 server/event.c                 |  5 ++--
 server/object.h                |  2 +-
 server/process.c               |  5 ++--
 server/protocol.def            | 10 ++++++++
 server/queue.c                 |  5 ++--
 server/request.h               |  3 ++-
 server/thread.c                |  5 ++--
 server/trace.c                 |  7 +++++-
 11 files changed, 79 insertions(+), 25 deletions(-)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index c4faf69a13..cb206bc0f5 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -79,17 +79,9 @@ void __wine_esync_set_queue_fd( int fd )
     ntdll_get_thread_data()->esync_queue_fd = fd;
 }
 
-enum esync_type
-{
-    ESYNC_SEMAPHORE = 1,
-    ESYNC_AUTO_EVENT,
-    ESYNC_MANUAL_EVENT,
-    ESYNC_MANUAL_SERVER,
-};
-
 struct esync
 {
-    enum esync_type type;
+    enum esync_type type;   /* defined in protocol.def */
     int fd;
 };
 
@@ -163,6 +155,7 @@ static void *esync_get_object( HANDLE handle )
 static NTSTATUS get_waitable_object( HANDLE handle, struct esync **obj )
 {
     obj_handle_t fd_handle;
+    enum esync_type type;
     struct esync *esync;
     sigset_t sigset;
     NTSTATUS ret;
@@ -179,6 +172,7 @@ static NTSTATUS get_waitable_object( HANDLE handle, struct esync **obj )
             req->handle = wine_server_obj_handle( handle );
             if (!(ret = wine_server_call( req )))
             {
+                type = reply->type;
                 fd = receive_fd( &fd_handle );
                 assert( wine_server_ptr_handle(fd_handle) == handle );
             }
@@ -205,7 +199,7 @@ static NTSTATUS get_waitable_object( HANDLE handle, struct esync **obj )
 
     esync = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*esync) );
     esync->fd = fd;
-    esync->type = ESYNC_MANUAL_SERVER;
+    esync->type = type;
 
     add_to_list( handle, esync );
 
@@ -444,8 +438,10 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
                              BOOLEAN alertable, const LARGE_INTEGER *timeout )
 {
     struct esync *objs[MAXIMUM_WAIT_OBJECTS];
-    struct pollfd fds[MAXIMUM_WAIT_OBJECTS];
+    struct pollfd fds[MAXIMUM_WAIT_OBJECTS + 1];
     int has_esync = 0, has_server = 0;
+    DWORD pollcount = count;
+    BOOL msgwait = FALSE;
     LONGLONG timeleft;
     LARGE_INTEGER now;
     ULONGLONG end;
@@ -474,6 +470,15 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
             return ret;
     }
 
+    if (objs[count - 1] && objs[count - 1]->type == ESYNC_QUEUE)
+    {
+        /* Last object in the list is a queue, which means someone is using
+         * MsgWaitForMultipleObjects(). We have to wait not only for the server
+         * fd (signaled on send_message, etc.) but also the USER driver's fd
+         * (signaled on e.g. X11 events.) */
+        msgwait = TRUE;
+    }
+
     if (has_esync && has_server)
     {
         FIXME("Can't wait on esync and server objects at the same time!\n");
@@ -491,6 +496,9 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
         for (i = 0; i < count; i++)
             DPRINTF(" %p", handles[i]);
 
+        if (msgwait)
+            DPRINTF(" or driver events (fd %d)", ntdll_get_thread_data()->esync_queue_fd);
+
         if (!timeout)
             DPRINTF(", timeout = INFINITE.\n");
         else
@@ -508,10 +516,16 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
             fds[i].fd = objs[i] ? objs[i]->fd : -1;
             fds[i].events = POLLIN;
         }
+        if (msgwait)
+        {
+            fds[count].fd = ntdll_get_thread_data()->esync_queue_fd;
+            fds[count].events = POLLIN;
+            pollcount++;
+        }
 
         while (1)
         {
-            ret = do_poll( fds, count, timeout ? &end : NULL );
+            ret = do_poll( fds, pollcount, timeout ? &end : NULL );
             if (ret > 0)
             {
                 /* Find out which object triggered the wait. */
@@ -549,6 +563,12 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
                     }
                 }
 
+                if (msgwait && (fds[count].revents & POLLIN))
+                {
+                    TRACE("Woken up by driver events.\n");
+                    return count - 1;
+                }
+
                 /* If we got here, someone else stole (or reset, etc.) whatever
                  * we were waiting for. So keep waiting. */
                 NtQuerySystemTime( &now );
diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index c762cbbc4b..50b312518e 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -5689,6 +5689,17 @@ struct get_esync_fd_request
 struct get_esync_fd_reply
 {
     struct reply_header __header;
+    int          type;
+    char __pad_12[4];
+};
+
+enum esync_type
+{
+    ESYNC_SEMAPHORE = 1,
+    ESYNC_AUTO_EVENT,
+    ESYNC_MANUAL_EVENT,
+    ESYNC_MANUAL_SERVER,
+    ESYNC_QUEUE,
 };
 
 
diff --git a/server/esync.c b/server/esync.c
index 4682163687..ef02170021 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -148,11 +148,12 @@ int esync_create_fd( int initval, int flags )
 void esync_wake_up( struct object *obj )
 {
     static const uint64_t value = 1;
+    enum esync_type dummy;
     int fd;
 
     if (obj->ops->get_esync_fd)
     {
-        fd = obj->ops->get_esync_fd( obj );
+        fd = obj->ops->get_esync_fd( obj, &dummy );
 
         if (write( fd, &value, sizeof(value) ) == -1)
             perror( "esync: write" );
@@ -217,6 +218,7 @@ DECL_HANDLER(create_esync)
 DECL_HANDLER(get_esync_fd)
 {
     struct object *obj;
+    enum esync_type type;
     int fd;
 
     if (!(obj = get_handle_obj( current->process, req->handle, SYNCHRONIZE, NULL )))
@@ -224,7 +226,8 @@ DECL_HANDLER(get_esync_fd)
 
     if (obj->ops->get_esync_fd)
     {
-        fd = obj->ops->get_esync_fd( obj );
+        fd = obj->ops->get_esync_fd( obj, &type );
+        reply->type = type;
         send_client_fd( current->process, fd, req->handle );
     }
     else
diff --git a/server/event.c b/server/event.c
index 0ae35de81c..153578a67b 100644
--- a/server/event.c
+++ b/server/event.c
@@ -48,7 +48,7 @@ struct event
 static void event_dump( struct object *obj, int verbose );
 static struct object_type *event_get_type( struct object *obj );
 static int event_signaled( struct object *obj, struct wait_queue_entry *entry );
-static int event_get_esync_fd( struct object *obj );
+static int event_get_esync_fd( struct object *obj, enum esync_type *type );
 static void event_satisfied( struct object *obj, struct wait_queue_entry *entry );
 static unsigned int event_map_access( struct object *obj, unsigned int access );
 static int event_signal( struct object *obj, unsigned int access);
@@ -198,9 +198,10 @@ static int event_signaled( struct object *obj, struct wait_queue_entry *entry )
     return event->signaled;
 }
 
-static int event_get_esync_fd( struct object *obj )
+static int event_get_esync_fd( struct object *obj, enum esync_type *type )
 {
     struct event *event = (struct event *)obj;
+    *type = ESYNC_MANUAL_SERVER;    /* all server-created events are manual-reset */
     return event->esync_fd;
 }
 
diff --git a/server/object.h b/server/object.h
index b3d4e33344..70da9aebae 100644
--- a/server/object.h
+++ b/server/object.h
@@ -69,7 +69,7 @@ struct object_ops
     /* is object signaled? */
     int  (*signaled)(struct object *,struct wait_queue_entry *);
     /* return the esync fd for this object */
-    int (*get_esync_fd)(struct object *);
+    int (*get_esync_fd)(struct object *, enum esync_type *type);
     /* wait satisfied */
     void (*satisfied)(struct object *,struct wait_queue_entry *);
     /* signal an object */
diff --git a/server/process.c b/server/process.c
index ea981b7690..957e96feb3 100644
--- a/server/process.c
+++ b/server/process.c
@@ -65,7 +65,7 @@ static int process_signaled( struct object *obj, struct wait_queue_entry *entry
 static unsigned int process_map_access( struct object *obj, unsigned int access );
 static void process_poll_event( struct fd *fd, int event );
 static void process_destroy( struct object *obj );
-static int process_get_esync_fd( struct object *obj );
+static int process_get_esync_fd( struct object *obj, enum esync_type *type );
 static void terminate_process( struct process *process, struct thread *skip, int exit_code );
 
 static const struct object_ops process_ops =
@@ -648,9 +648,10 @@ static int process_signaled( struct object *obj, struct wait_queue_entry *entry
     return !process->running_threads;
 }
 
-static int process_get_esync_fd( struct object *obj )
+static int process_get_esync_fd( struct object *obj, enum esync_type *type )
 {
     struct process *process = (struct process *)obj;
+    *type = ESYNC_MANUAL_SERVER;
     return process->esync_fd;
 }
 
diff --git a/server/protocol.def b/server/protocol.def
index 3732e4b752..dcbe0e4aa5 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -3878,4 +3878,14 @@ struct handle_info
 @REQ(get_esync_fd)
     obj_handle_t handle;        /* handle to the object */
 @REPLY
+    int          type;          /* esync type (defined below) */
 @END
+
+enum esync_type
+{
+    ESYNC_SEMAPHORE = 1,
+    ESYNC_AUTO_EVENT,
+    ESYNC_MANUAL_EVENT,
+    ESYNC_MANUAL_SERVER,
+    ESYNC_QUEUE,
+};
diff --git a/server/queue.c b/server/queue.c
index a0393a4fcb..24fab78a89 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -158,7 +158,7 @@ static void msg_queue_dump( struct object *obj, int verbose );
 static int msg_queue_add_queue( struct object *obj, struct wait_queue_entry *entry );
 static void msg_queue_remove_queue( struct object *obj, struct wait_queue_entry *entry );
 static int msg_queue_signaled( struct object *obj, struct wait_queue_entry *entry );
-static int msg_queue_get_esync_fd( struct object *obj );
+static int msg_queue_get_esync_fd( struct object *obj, enum esync_type *type );
 static void msg_queue_satisfied( struct object *obj, struct wait_queue_entry *entry );
 static void msg_queue_destroy( struct object *obj );
 static void msg_queue_poll_event( struct fd *fd, int event );
@@ -975,9 +975,10 @@ static int msg_queue_signaled( struct object *obj, struct wait_queue_entry *entr
     return ret || is_signaled( queue );
 }
 
-static int msg_queue_get_esync_fd( struct object *obj )
+static int msg_queue_get_esync_fd( struct object *obj, enum esync_type *type )
 {
     struct msg_queue *queue = (struct msg_queue *)obj;
+    *type = ESYNC_QUEUE;
     return queue->esync_fd;
 }
 
diff --git a/server/request.h b/server/request.h
index 272f79dc04..ca9a83632e 100644
--- a/server/request.h
+++ b/server/request.h
@@ -2418,7 +2418,8 @@ C_ASSERT( FIELD_OFFSET(struct create_esync_reply, handle) == 8 );
 C_ASSERT( sizeof(struct create_esync_reply) == 16 );
 C_ASSERT( FIELD_OFFSET(struct get_esync_fd_request, handle) == 12 );
 C_ASSERT( sizeof(struct get_esync_fd_request) == 16 );
-C_ASSERT( sizeof(struct get_esync_fd_reply) == 8 );
+C_ASSERT( FIELD_OFFSET(struct get_esync_fd_reply, type) == 8 );
+C_ASSERT( sizeof(struct get_esync_fd_reply) == 16 );
 
 #endif  /* WANT_REQUEST_HANDLERS */
 
diff --git a/server/thread.c b/server/thread.c
index 722c133847..56bef76c5f 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -131,7 +131,7 @@ static const struct object_ops thread_apc_ops =
 
 static void dump_thread( struct object *obj, int verbose );
 static int thread_signaled( struct object *obj, struct wait_queue_entry *entry );
-static int thread_get_esync_fd( struct object *obj );
+static int thread_get_esync_fd( struct object *obj, enum esync_type *type );
 static unsigned int thread_map_access( struct object *obj, unsigned int access );
 static void thread_poll_event( struct fd *fd, int event );
 static void destroy_thread( struct object *obj );
@@ -378,9 +378,10 @@ static int thread_signaled( struct object *obj, struct wait_queue_entry *entry )
     return (mythread->state == TERMINATED);
 }
 
-static int thread_get_esync_fd( struct object *obj )
+static int thread_get_esync_fd( struct object *obj, enum esync_type *type )
 {
     struct thread *thread = (struct thread *)obj;
+    *type = ESYNC_MANUAL_SERVER;
     return thread->esync_fd;
 }
 
diff --git a/server/trace.c b/server/trace.c
index 1ff29e273d..58c5db0b10 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -4559,6 +4559,11 @@ static void dump_get_esync_fd_request( const struct get_esync_fd_request *req )
     fprintf( stderr, " handle=%04x", req->handle );
 }
 
+static void dump_get_esync_fd_reply( const struct get_esync_fd_reply *req )
+{
+    fprintf( stderr, " type=%d", req->type );
+}
+
 static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_new_process_request,
     (dump_func)dump_exec_process_request,
@@ -5148,7 +5153,7 @@ static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {
     NULL,
     NULL,
     (dump_func)dump_create_esync_reply,
-    NULL,
+    (dump_func)dump_get_esync_fd_reply,
 };
 
 static const char * const req_names[REQ_NB_REQUESTS] = {
-- 
2.20.1


From fb0391d049bcf4283bcedafcedfa938716fadab6 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 9 Jun 2018 15:39:37 -0500
Subject: [PATCH 25/83] server: Create eventfd descriptors for device manager
 objects.

We don't have to worry about synchronization here because
wine_ntoskrnl_main_loop() is only ever called from one thread per winedevice
process.

This lets drivers like mountmgr finally work, and so winecfg can open the
Drives tab.
---
 server/device.c | 24 +++++++++++++++++++++++-
 1 file changed, 23 insertions(+), 1 deletion(-)

diff --git a/server/device.c b/server/device.c
index 94309ba112..5c13a839ab 100644
--- a/server/device.c
+++ b/server/device.c
@@ -38,6 +38,7 @@
 #include "handle.h"
 #include "request.h"
 #include "process.h"
+#include "esync.h"
 
 /* IRP object */
 
@@ -88,10 +89,12 @@ struct device_manager
     struct object          obj;           /* object header */
     struct list            devices;       /* list of devices */
     struct list            requests;      /* list of pending irps across all devices */
+    int                    esync_fd;      /* esync file descriptor */
 };
 
 static void device_manager_dump( struct object *obj, int verbose );
 static int device_manager_signaled( struct object *obj, struct wait_queue_entry *entry );
+static int device_manager_get_esync_fd( struct object *obj, enum esync_type *type );
 static void device_manager_destroy( struct object *obj );
 
 static const struct object_ops device_manager_ops =
@@ -102,7 +105,7 @@ static const struct object_ops device_manager_ops =
     add_queue,                        /* add_queue */
     remove_queue,                     /* remove_queue */
     device_manager_signaled,          /* signaled */
-    NULL,                             /* get_esync_fd */
+    device_manager_get_esync_fd,      /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     no_get_fd,                        /* get_fd */
@@ -577,6 +580,9 @@ static void delete_file( struct device_file *file )
     /* terminate all pending requests */
     LIST_FOR_EACH_ENTRY_SAFE( irp, next, &file->requests, struct irp_call, dev_entry )
     {
+        if (do_esync() && file->device->manager && list_empty( &file->device->manager->requests ))
+            esync_clear( file->device->manager->esync_fd );
+
         list_remove( &irp->mgr_entry );
         set_irp_result( irp, STATUS_FILE_DELETED, NULL, 0, 0 );
     }
@@ -609,6 +615,13 @@ static int device_manager_signaled( struct object *obj, struct wait_queue_entry
     return !list_empty( &manager->requests );
 }
 
+static int device_manager_get_esync_fd( struct object *obj, enum esync_type *type )
+{
+    struct device_manager *manager = (struct device_manager *)obj;
+    *type = ESYNC_MANUAL_SERVER;
+    return manager->esync_fd;
+}
+
 static void device_manager_destroy( struct object *obj )
 {
     struct device_manager *manager = (struct device_manager *)obj;
@@ -618,6 +631,9 @@ static void device_manager_destroy( struct object *obj )
     {
         struct device *device = LIST_ENTRY( ptr, struct device, entry );
         delete_device( device );
+
+        if (do_esync())
+            close( manager->esync_fd );
     }
 }
 
@@ -629,6 +645,9 @@ static struct device_manager *create_device_manager(void)
     {
         list_init( &manager->devices );
         list_init( &manager->requests );
+
+        if (do_esync())
+            manager->esync_fd = esync_create_fd( 0, 0 );
     }
     return manager;
 }
@@ -735,6 +754,9 @@ DECL_HANDLER(get_next_device_request)
             iosb->in_size = 0;
             list_remove( &irp->mgr_entry );
             list_init( &irp->mgr_entry );
+
+            if (do_esync() && list_empty( &manager->requests ))
+                esync_clear( manager->esync_fd );
         }
     }
     else set_error( STATUS_PENDING );
-- 
2.20.1


From d373280f85d30aa2b9096c22fffdb71b05fe2e47 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 9 Jun 2018 15:48:46 -0500
Subject: [PATCH 26/83] ntdll: Create esync objects for mutexes.

---
 dlls/ntdll/esync.c             | 39 ++++++++++++++++++++++++++++++++++
 dlls/ntdll/esync.h             |  2 ++
 dlls/ntdll/sync.c              |  3 +++
 include/wine/server_protocol.h |  1 +
 server/protocol.def            |  1 +
 5 files changed, 46 insertions(+)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index cb206bc0f5..64947c22e3 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -96,6 +96,13 @@ struct event
     struct esync obj;
 };
 
+struct mutex
+{
+    struct esync obj;
+    DWORD tid;
+    int count;    /* recursion count */
+};
+
 /* We'd like lookup to be fast. To that end, we use a static list indexed by handle.
  * This is copied and adapted from the fd cache code. */
 
@@ -388,6 +395,38 @@ NTSTATUS esync_pulse_event( HANDLE handle )
     return STATUS_SUCCESS;
 }
 
+NTSTATUS esync_create_mutex( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr, BOOLEAN initial )
+{
+    struct mutex *mutex;
+    NTSTATUS ret;
+    int fd;
+
+    TRACE("name %s, initial %d.\n",
+        attr ? debugstr_us(attr->ObjectName) : "<no name>", initial);
+
+    ret = create_esync( &fd, handle, access, attr, initial ? 0 : 1, 0 );
+    if (!ret || ret == STATUS_OBJECT_NAME_EXISTS)
+    {
+        mutex = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*mutex) );
+        if (!mutex)
+            return STATUS_NO_MEMORY;
+
+        /* can't take ownership of the mutex if we didn't create it */
+        if (ret == STATUS_OBJECT_NAME_EXISTS)
+            initial = FALSE;
+
+        mutex->obj.type = ESYNC_MUTEX;
+        mutex->obj.fd = fd;
+        mutex->tid = initial ? GetCurrentThreadId() : 0;
+        mutex->count = initial ? 1 : 0;
+
+        add_to_list( *handle, &mutex->obj);
+    }
+
+    return ret;
+}
+
 #define TICKSPERSEC        10000000
 #define TICKSPERMSEC       10000
 
diff --git a/dlls/ntdll/esync.h b/dlls/ntdll/esync.h
index 062781fc00..ee81852ef9 100644
--- a/dlls/ntdll/esync.h
+++ b/dlls/ntdll/esync.h
@@ -29,6 +29,8 @@ extern NTSTATUS esync_create_event( HANDLE *handle, ACCESS_MASK access,
 extern NTSTATUS esync_set_event( HANDLE handle ) DECLSPEC_HIDDEN;
 extern NTSTATUS esync_reset_event( HANDLE handle ) DECLSPEC_HIDDEN;
 extern NTSTATUS esync_pulse_event( HANDLE handle ) DECLSPEC_HIDDEN;
+extern NTSTATUS esync_create_mutex( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr, BOOLEAN initial ) DECLSPEC_HIDDEN;
 
 extern NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
                                     BOOLEAN alertable, const LARGE_INTEGER *timeout ) DECLSPEC_HIDDEN;
diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index cc84b2637f..ec35b3a4bc 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -545,6 +545,9 @@ NTSTATUS WINAPI NtCreateMutant(OUT HANDLE* MutantHandle,
     data_size_t len;
     struct object_attributes *objattr;
 
+    if (do_esync())
+        return esync_create_mutex( MutantHandle, access, attr, InitialOwner );
+
     if ((status = alloc_object_attributes( attr, &objattr, &len ))) return status;
 
     SERVER_START_REQ( create_mutex )
diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index 50b312518e..f50334bf7a 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -5698,6 +5698,7 @@ enum esync_type
     ESYNC_SEMAPHORE = 1,
     ESYNC_AUTO_EVENT,
     ESYNC_MANUAL_EVENT,
+    ESYNC_MUTEX,
     ESYNC_MANUAL_SERVER,
     ESYNC_QUEUE,
 };
diff --git a/server/protocol.def b/server/protocol.def
index dcbe0e4aa5..a7c6ffdd01 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -3886,6 +3886,7 @@ enum esync_type
     ESYNC_SEMAPHORE = 1,
     ESYNC_AUTO_EVENT,
     ESYNC_MANUAL_EVENT,
+    ESYNC_MUTEX,
     ESYNC_MANUAL_SERVER,
     ESYNC_QUEUE,
 };
-- 
2.20.1


From c2c24cf5fb9bf050c6c09029de37715297fdf1e5 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 9 Jun 2018 15:57:48 -0500
Subject: [PATCH 27/83] ntdll: Implement NtReleaseMutant().

---
 dlls/ntdll/esync.c | 31 +++++++++++++++++++++++++++++++
 dlls/ntdll/esync.h |  1 +
 dlls/ntdll/sync.c  |  3 +++
 3 files changed, 35 insertions(+)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 64947c22e3..f228d2150c 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -427,6 +427,37 @@ NTSTATUS esync_create_mutex( HANDLE *handle, ACCESS_MASK access,
     return ret;
 }
 
+NTSTATUS esync_release_mutex( HANDLE *handle, LONG *prev )
+{
+    struct mutex *mutex = esync_get_object( handle );
+    static const uint64_t value = 1;
+
+    TRACE("%p, %p.\n", handle, prev);
+
+    if (!mutex) return STATUS_INVALID_HANDLE;
+
+    /* This is thread-safe, because the only thread that can change the tid to
+     * or from our tid is ours. */
+    if (mutex->tid != GetCurrentThreadId()) return STATUS_MUTANT_NOT_OWNED;
+
+    if (prev) *prev = mutex->count;
+
+    mutex->count--;
+
+    if (!mutex->count)
+    {
+        /* This is also thread-safe, as long as signaling the file is the last
+         * thing we do. Other threads don't care about the tid if it isn't
+         * theirs. */
+        mutex->tid = 0;
+
+        if (write( mutex->obj.fd, &value, sizeof(value) ) == -1)
+            return FILE_GetNtStatus();
+    }
+
+    return STATUS_SUCCESS;
+}
+
 #define TICKSPERSEC        10000000
 #define TICKSPERMSEC       10000
 
diff --git a/dlls/ntdll/esync.h b/dlls/ntdll/esync.h
index ee81852ef9..37fbfb234c 100644
--- a/dlls/ntdll/esync.h
+++ b/dlls/ntdll/esync.h
@@ -31,6 +31,7 @@ extern NTSTATUS esync_reset_event( HANDLE handle ) DECLSPEC_HIDDEN;
 extern NTSTATUS esync_pulse_event( HANDLE handle ) DECLSPEC_HIDDEN;
 extern NTSTATUS esync_create_mutex( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, BOOLEAN initial ) DECLSPEC_HIDDEN;
+extern NTSTATUS esync_release_mutex( HANDLE *handle, LONG *prev ) DECLSPEC_HIDDEN;
 
 extern NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
                                     BOOLEAN alertable, const LARGE_INTEGER *timeout ) DECLSPEC_HIDDEN;
diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index ec35b3a4bc..dc345a1b55 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -596,6 +596,9 @@ NTSTATUS WINAPI NtReleaseMutant( IN HANDLE handle, OUT PLONG prev_count OPTIONAL
 {
     NTSTATUS    status;
 
+    if (do_esync())
+        return esync_release_mutex( handle, prev_count );
+
     SERVER_START_REQ( release_mutex )
     {
         req->handle = wine_server_obj_handle( handle );
-- 
2.20.1


From 7f3956027bcb43e0524e111779c4f433ba3e6efc Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 9 Jun 2018 16:05:02 -0500
Subject: [PATCH 28/83] ntdll: Implement waiting on mutexes.

---
 dlls/ntdll/esync.c | 32 +++++++++++++++++++++++++++++---
 1 file changed, 29 insertions(+), 3 deletions(-)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index f228d2150c..7f81715d8f 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -583,7 +583,25 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
     {
         for (i = 0; i < count; i++)
         {
-            fds[i].fd = objs[i] ? objs[i]->fd : -1;
+            struct esync *obj = objs[i];
+
+            if (obj && obj->type == ESYNC_MUTEX)
+            {
+                /* If we already own the mutex, return immediately. */
+                /* Note: This violates the assumption that the *first* object
+                 * to be signaled will be returned. If that becomes a problem,
+                 * we can always check the state of each object before waiting. */
+                struct mutex *mutex = (struct mutex *)obj;
+
+                if (mutex->tid == GetCurrentThreadId())
+                {
+                    TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                    mutex->count++;
+                    return i;
+                }
+            }
+
+            fds[i].fd = obj ? obj->fd : -1;
             fds[i].events = POLLIN;
         }
         if (msgwait)
@@ -601,18 +619,20 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
                 /* Find out which object triggered the wait. */
                 for (i = 0; i < count; i++)
                 {
+                    struct esync *obj = objs[i];
+
                     if (fds[i].revents & (POLLERR | POLLHUP | POLLNVAL))
                     {
                         ERR("Polling on fd %d returned %#x.\n", fds[i].fd, fds[i].revents);
                         return STATUS_INVALID_HANDLE;
                     }
 
-                    if (objs[i])
+                    if (obj)
                     {
                         int64_t value;
                         ssize_t size;
 
-                        if (objs[i]->type == ESYNC_MANUAL_EVENT || objs[i]->type == ESYNC_MANUAL_SERVER)
+                        if (obj->type == ESYNC_MANUAL_EVENT || obj->type == ESYNC_MANUAL_SERVER)
                         {
                             /* Don't grab the object, just check if it's signaled. */
                             if (fds[i].revents & POLLIN)
@@ -627,6 +647,12 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
                             {
                                 /* We found our object. */
                                 TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                                if (obj->type == ESYNC_MUTEX)
+                                {
+                                    struct mutex *mutex = (struct mutex *)obj;
+                                    mutex->tid = GetCurrentThreadId();
+                                    mutex->count = 1;
+                                }
                                 return i;
                             }
                         }
-- 
2.20.1


From 425c848f8986888585fef0cda8a10b486fc1b640 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 9 Jun 2018 20:21:00 -0500
Subject: [PATCH 29/83] ntdll: Implement wait-all.

Most of the comments I would put here are covered in the code. I will just
amend:

Mutexes are extremely annoying. Microsoft should never have let you grab a
mutex more than once.
---
 dlls/ntdll/esync.c | 162 +++++++++++++++++++++++++++++++++++++++++----
 1 file changed, 149 insertions(+), 13 deletions(-)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 7f81715d8f..7859b19743 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -515,8 +515,10 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
     LONGLONG timeleft;
     LARGE_INTEGER now;
     ULONGLONG end;
+    int64_t value;
+    ssize_t size;
+    int i, j;
     int ret;
-    int i;
 
     NtQuerySystemTime( &now );
     if (timeout)
@@ -629,9 +631,6 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
 
                     if (obj)
                     {
-                        int64_t value;
-                        ssize_t size;
-
                         if (obj->type == ESYNC_MANUAL_EVENT || obj->type == ESYNC_MANUAL_SERVER)
                         {
                             /* Don't grab the object, just check if it's signaled. */
@@ -669,21 +668,158 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
                  * we were waiting for. So keep waiting. */
                 NtQuerySystemTime( &now );
             }
-            else if (ret == 0)
+            else
+                goto err;
+        }
+    }
+    else
+    {
+        /* Wait-all is a little trickier to implement correctly. Fortunately,
+         * it's not as common.
+         *
+         * The idea is basically just to wait in sequence on every object in the
+         * set. Then when we're done, try to grab them all in a tight loop. If
+         * that fails, release any resources we've grabbed (and yes, we can
+         * reliably do thisit's just mutexes and semaphores that we have to
+         * put back, and in both cases we just put back 1), and if any of that
+         * fails we start over.
+         *
+         * What makes this inherently bad is that we might temporarily grab a
+         * resource incorrectly. Hopefully it'll be quick (and hey, it won't
+         * block on wineserver) so nobody will notice. Besides, consider: if
+         * object A becomes signaled but someone grabs it before we can grab it
+         * and everything else, then they could just as well have grabbed it
+         * before it became signaled. Similarly if object A was signaled and we
+         * were blocking on object B, then B becomes available and someone grabs
+         * A before we can, then they might have grabbed A before B became
+         * signaled. In either case anyone who tries to wait on A or B will be
+         * waiting for an instant while we put things back. */
+
+        while (1)
+        {
+tryagain:
+            /* First step: try to poll on each object in sequence. */
+            fds[0].events = POLLIN;
+            for (i = 0; i < count; i++)
             {
-                TRACE("Wait timed out.\n");
-                return STATUS_TIMEOUT;
+                struct esync *obj = objs[i];
+
+                fds[0].fd = obj ? obj->fd : -1;
+
+                if (obj && obj->type == ESYNC_MUTEX)
+                {
+                    /* It might be ours. */
+                    struct mutex *mutex = (struct mutex *)obj;
+
+                    if (mutex->tid == GetCurrentThreadId())
+                        continue;
+                }
+
+                ret = do_poll( fds, 1, timeout ? &end : NULL );
+                if (ret <= 0)
+                    goto err;
+
+                if (fds[0].revents & (POLLHUP | POLLERR | POLLNVAL))
+                {
+                    ERR("Polling on fd %d returned %#x.\n", fds[0].fd, fds[0].revents);
+                    return STATUS_INVALID_HANDLE;
+                }
             }
-            else
+
+            /* Don't forget to wait for driver messages. */
+            if (msgwait)
             {
-                ERR("ppoll failed: %s\n", strerror(errno));
-                return FILE_GetNtStatus();
+                fds[0].fd = ntdll_get_thread_data()->esync_queue_fd;
+                ret = do_poll( fds, 1, timeout ? &end : NULL );
+                if (ret <= 0)
+                    goto err;
             }
-        }
+
+            /* If we got here and we haven't timed out, that means all of the
+             * handles were signaled. Check to make sure they still are. */
+            for (i = 0; i < count; i++)
+            {
+                fds[i].fd = objs[i] ? objs[i]->fd : -1;
+                fds[i].events = POLLIN;
+            }
+            if (msgwait)
+            {
+                fds[count].fd = ntdll_get_thread_data()->esync_queue_fd;
+                fds[count].events = POLLIN;
+                pollcount++;
+            }
+
+            /* Poll everything to see if they're still signaled. */
+            ret = poll( fds, pollcount, 0 );
+            if (ret == pollcount)
+            {
+                /* Quick, grab everything. */
+                for (i = 0; i < pollcount; i++)
+                {
+                    struct esync *obj = objs[i];
+
+                    switch (obj->type)
+                    {
+                    case ESYNC_MUTEX:
+                    {
+                        struct mutex *mutex = (struct mutex *)obj;
+                        if (mutex->tid == GetCurrentThreadId())
+                            break;
+                        /* otherwise fall through */
+                    }
+                    case ESYNC_SEMAPHORE:
+                    case ESYNC_AUTO_EVENT:
+                        if ((size = read( fds[i].fd, &value, sizeof(value) )) != sizeof(value))
+                        {
+                            /* We were too slow. Put everything back. */
+                            value = 1;
+                            for (j = i; j >= 0; j--)
+                            {
+                                if (write( obj->fd, &value, sizeof(value) ) == -1)
+                                    return FILE_GetNtStatus();
+                            }
+
+                            goto tryagain;  /* break out of two loops and a switch */
+                        }
+                        break;
+                    default:
+                        /* If a manual-reset event changed between there and
+                         * here, it's shouldn't be a problem. */
+                        break;
+                    }
+                }
+
+                /* If we got here, we successfully waited on every object. */
+                /* Make sure to let ourselves know that we grabbed the mutexes. */
+                for (i = 0; i < count; i++)
+                {
+                    if (objs[i]->type == ESYNC_MUTEX)
+                    {
+                        struct mutex *mutex = (struct mutex *)objs[i];
+                        mutex->tid = GetCurrentThreadId();
+                        mutex->count++;
+                    }
+                }
+                TRACE("Wait successful.\n");
+                return STATUS_SUCCESS;
+            }
+
+            /* If we got here, ppoll() returned less than all of our objects.
+             * So loop back to the beginning and try again. */
+        } /* while(1) */
+    } /* else (wait-all) */
+
+err:
+    /* We should only get here if poll() failed. */
+
+    if (ret == 0)
+    {
+        TRACE("Wait timed out.\n");
+        return STATUS_TIMEOUT;
     }
     else
     {
-        FIXME("Wait-all not implemented.\n");
-        return STATUS_NOT_IMPLEMENTED;
+        ERR("ppoll failed: %s\n", strerror(errno));
+        return FILE_GetNtStatus();
     }
 }
-- 
2.20.1


From 483d9186ed4e069c97efb5ac8049206105949d5e Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 9 Jun 2018 22:44:57 -0500
Subject: [PATCH 30/83] esync: Add a README.

---
 README.esync | 184 +++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 184 insertions(+)
 create mode 100644 README.esync

diff --git a/README.esync b/README.esync
new file mode 100644
index 0000000000..8fcb969011
--- /dev/null
+++ b/README.esync
@@ -0,0 +1,184 @@
+This is eventfd-based synchronization, or 'esync' for short. Turn it on with
+WINEESYNC=1 (note that it checks the presence and not the value); debug it
+with +esync.
+
+The aim is to execute all synchronization operations in "user-space", that is,
+without going through wineserver. We do this using Linux's eventfd
+facility. The main impetus to using eventfd is so that we can poll multiple
+objects at once; in particular we can't do this with futexes, or pthread
+semaphores, or the like. The only way I know of to wait on any of multiple
+objects is to use select/poll/epoll to wait on multiple fds, and eventfd gives
+us those fds in a quite usable way.
+
+Whenever a semaphore, event, or mutex is created, we have the server, instead
+of creating a traditional server-side event/semaphore/mutex, instead create an
+'esync' primitive. These live in esync.c and are very slim objects; in fact,
+they don't even know what type of primitive they are. The server is involved
+at all because we still need a way of creating named objects, passing handles
+to another process, etc.
+
+The server creates an eventfd file descriptor with the requested parameters
+and passes it back to ntdll. ntdll creates an object of the appropriate type,
+then caches it in a table. This table is copied almost wholesale from the fd
+cache code in server.c.
+
+Specific operations follow quite straightforwardly from eventfd:
+
+* To release an object, or set an event, we simply write() to it.
+* An object is signalled if read() succeeds on it. Notably, we create all
+  eventfd descriptors with O_NONBLOCK, so that we can atomically check if an
+  object is signalled and grab it if it is. This also lets us reset events.
+* For objects whose state should not be reset upon waitinge.g. manual-reset
+  eventswe simply check for the POLLIN flag instead of reading.
+* Semaphores are handled by the EFD_SEMAPHORE flag. This matches up quite well
+  (although with some difficulties; see below).
+* Mutexes store their owner thread locally. This isn't reliable information if
+  a different process's thread owns the mutex, but this doesn't mattera
+  thread should only care whether it owns the mutex, so it knows whether to
+  try waiting on it or simply to increase the recursion count.
+
+The interesting part about esync is that (almost) all waits happen in ntdll,
+including those on server-bound objects. The idea here is that on the server
+side, for any waitable object, we create an eventfd file descriptor (not an
+esync primitive), and then pass it to ntdll if the program tries to wait on
+it. These are cached too, so only the first wait will require a round trip to
+the server. Then the server signals the file descriptor as appropriate, and
+thereby wakes up the client. So far this is implemented for processes,
+threads, message queues (difficult; see below), and device managers (necessary
+for drivers to work). All of these are necessarily server-bound, so we
+wouldn't really gain anything by signalling on the client side instead. Of
+course, except possibly for message queues, it's not likely that any program
+(cutting-edge D3D game or not) is going to be causing a great wineserver load
+by waiting on any of these objects; the motivation was rather to provide a way
+to wait on ntdll-bound and server-bound objects at the same time.
+
+Some cases are still passed to the server, and there's probably no reason not
+to keep them that way. Those that I noticed while testing include: async
+objects, which are internal to the file APIs and never exposed to userspace,
+startup_info objects, which are internal to the loader and signalled when a
+process starts, and keyed events, which are exposed through an ntdll API
+(although not through kernel32) but can't be mixed with other objects (you
+have to use NtWaitForKeyedEvent()). Other cases include: named pipes, debug
+events, sockets, and timers. It's unlikely we'll want to optimize debug events
+or sockets (or any of the other, rather rare, objects), but it is possible
+we'll want to optimize named pipes or timers.
+
+There were two sort of complications when working out the above. The first one
+was events. The trouble is that (1) the server actually creates some events by
+itself and (2) the server sometimes manipulates events passed by the
+client. Resolving the first case was easy enough, and merely entailed creating
+eventfd descriptors for the events the same way as for processes and threads
+(note that we don't really lose anything this way; the events include
+"LowMemoryCondition" and the event that signals system processes to shut
+down). For the second case I basically had to hook the server-side event
+functions to redirect to esync versions if the event was actually an esync
+primitive.
+
+The second complication was message queues. The difficulty here is that X11
+signals events by writing into a pipe (at least I think it's a pipe?), and so
+as a result wineserver has to poll on that descriptor. In theory we could just
+let wineserver do so and then signal us as appropriate, except that wineserver
+only polls on the pipe when the thread is waiting for events (otherwise we'd
+get e.g. keyboard input while the thread is doing something else, and spin
+forever trying to wake up a thread that doesn't care). The obvious solution is
+just to poll on that fd ourselves, and that's what I didit's just that
+getting the fd from wineserver was kind of ugly, and the code for waiting was
+also kind of ugly basically because we have to wait on both X11's fd and the
+"normal" process/thread-style wineserver fd that we use to signal sent
+messages. The upshot about the whole thing was that races are basically
+impossible, since a thread can only wait on its own queue.
+
+I had kind of figured that APCs just wouldn't work, but then poll() spat EINTR
+at me and I realized that this wasn't necessarily true. It seems that the
+server will suspend a thread when trying to deliver a system APC to a thread
+that's not waiting, and since the server has no idea that we're waiting it
+just suspends us. This of course interrupts poll(), which complains at us, and
+it turns out that just returning STATUS_USER_APC in that case is enough to
+make rpcrt4 happy.
+
+There are a couple things that this infrastructure can't handle, although
+surprisingly there aren't that many. In particular:
+* We can't return the previous count on a semaphore, since we have no way to
+  query the count on a semaphore through eventfd. Currently the code lies and
+  returns 1 every time. We can make this work (in a single process, or [if
+  necessary] in multiple processes through shared memory) by keeping a count
+  locally. We can't guarantee that it's the exact count at the moment the
+  semaphore was released, but I guess any program that runs into that race
+  shouldn't be depending on that fact anyway.
+* Similarly, we can't enforce the maximum count on a semaphore, since we have
+  no way to get the current count and subsequently compare it with the
+  maximum.
+* We can't use NtQueryMutant to get the mutant's owner or count if it lives in
+  a different process. If necessary we can use shared memory to make this
+  work, I guess, but see below.
+* User APCs don't work. However, it's not impossible to make them work; in
+  particular I think this could be relatively easily implemented by waiting on
+  another internal file descriptor when we execute an alertable wait.
+* Implementing wait-all, i.e. WaitForMultipleObjects(..., TRUE, ...), is not
+  exactly possible the way we'd like it to be possible. In theory that
+  function should wait until it knows all objects are available, then grab
+  them all at once atomically. The server (like the kernel) can do this
+  because the server is single-threaded and can't race with itself. We can't
+  do this in ntdll, though. The approach I've taken I've laid out in great
+  detail in the relevant patch, but for a quick summary we poll on each object
+  until it's signaled (but don't grab it), check them all again, and if
+  they're all signaled we try to grab them all at once in a tight loop, and if
+  we fail on any of them we reset the count on whatever we shouldn't have
+  consumed. Such a blip would necessarily be very quick.
+* The whole patchset only works on Linux, where eventfd is available. However,
+  it should be possible to make it work on a Mac, since eventfd is just a
+  quicker, easier way to use pipes (i.e. instead of writing 1 to the fd you'd
+  write 1 byte; instead of reading a 64-bit value from the fd you'd read as
+  many bytes as you can carry, which is admittedly less than 2**64 but
+  can probably be something reasonable.) It's also possible, although I
+  haven't yet looked, to use some different kind of synchronization
+  primitives, but pipes would be easiest to tack onto this framework.
+* We might hit the maximum number of open fd's. On my system the soft limit is
+  1024 and the hard limit is 1048576. I'm inclined to hope this won't be an
+  issue, since a hypothetical Linux port of any application might just as well
+  use the same number of eventfds.
+* PulseEvent() can't work the way it's supposed to work. Fortunately it's rare
+  and deprecated. It's also explicitly mentioned on MSDN that a thread can
+  miss the notification for a kernel APC, so in a sense we're not necessarily
+  doing anything wrong.
+
+There are some things that are perfectly implementable but that I just haven't
+done yet:
+* NtOpen* (aka Open*). This is just a matter of adding another open_esync
+  request analogous to those for other server primitives.
+* NtQuery*. This can be done to some degree (the difficulties are outlined
+  above). That said, these APIs aren't exposed through kernel32 in any way, so
+  I doubt anyone is going to be using them.
+* SignalObjectAndWait(). The server combines this into a single operation, but
+  according to MSDN it doesn't need to be atomic, so we can just signal the
+  appropriate object and wait, and woe betide anyone who gets in the way of
+  those two operations.
+* Other synchronizable server primitives. It's unlikely we'll need any of
+  these, except perhaps named pipes (which would honestly be rather difficult)
+  and (maybe) timers.
+
+This patchset was inspired by Daniel Santos' "hybrid synchronization"
+patchset. My idea was to create a framework whereby even contended waits could
+be executed in userspace, eliminating a lot of the complexity that his
+synchronization primitives used. I do however owe some significant gratitude
+toward him for setting me on the right path.
+
+I've tried to maximize code separation, both to make any potential rebases
+easier and to ensure that esync is only active when configured. All code in
+existing source files is guarded with "if (do_esync())", and generally that
+condition is followed by "return esync_version_of_this_method(...);", where
+the latter lives in esync.c and is declared in esync.h. I've also tried to
+make the patchset very clear and readableto write it as if I were going to
+submit it upstream. (Some intermediate patches do break things, which Wine is
+generally against, but I think it's for the better in this case.) I have cut
+some corners, though; there is some error checking missing, or implicit
+assumptions that the program is behaving correctly.
+
+I've tried to be careful about races. There are a lot of comments whose
+purpose are basically to assure me that races are impossible. In most cases we
+don't have to worry about races since all of the low-level synchronization is
+done by the kernel.
+
+Anyway, yeah, this is esync. Use it if you like.
+
+--Zebediah Figura
\ No newline at end of file
-- 
2.20.1


From 1f10b4c9c97c9ece2f7651329c91052a8614610e Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 9 Jun 2018 23:34:27 -0500
Subject: [PATCH 31/83] ntdll: Implement NtSignalAndWaitForSingleObject().

---
 dlls/ntdll/esync.c | 28 ++++++++++++++++++++++++++++
 dlls/ntdll/esync.h |  2 ++
 dlls/ntdll/sync.c  |  3 +++
 3 files changed, 33 insertions(+)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 7859b19743..79d3c2df08 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -823,3 +823,31 @@ err:
         return FILE_GetNtStatus();
     }
 }
+
+NTSTATUS esync_signal_and_wait( HANDLE signal, HANDLE wait, BOOLEAN alertable,
+    const LARGE_INTEGER *timeout )
+{
+    struct esync *obj = esync_get_object( signal );
+    NTSTATUS ret;
+
+    if (!obj) return STATUS_INVALID_HANDLE;
+
+    switch (obj->type)
+    {
+    case ESYNC_SEMAPHORE:
+        ret = esync_release_semaphore( signal, 1, NULL );
+        break;
+    case ESYNC_AUTO_EVENT:
+    case ESYNC_MANUAL_EVENT:
+        ret = esync_set_event( signal );
+        break;
+    case ESYNC_MUTEX:
+        ret = esync_release_mutex( signal, NULL );
+        break;
+    default:
+        return STATUS_OBJECT_TYPE_MISMATCH;
+    }
+    if (ret) return ret;
+
+    return esync_wait_objects( 1, &wait, TRUE, alertable, timeout );
+}
diff --git a/dlls/ntdll/esync.h b/dlls/ntdll/esync.h
index 37fbfb234c..979c3d81e2 100644
--- a/dlls/ntdll/esync.h
+++ b/dlls/ntdll/esync.h
@@ -35,6 +35,8 @@ extern NTSTATUS esync_release_mutex( HANDLE *handle, LONG *prev ) DECLSPEC_HIDDE
 
 extern NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
                                     BOOLEAN alertable, const LARGE_INTEGER *timeout ) DECLSPEC_HIDDEN;
+extern NTSTATUS esync_signal_and_wait( HANDLE signal, HANDLE wait,
+    BOOLEAN alertable, const LARGE_INTEGER *timeout ) DECLSPEC_HIDDEN;
 
 
 /* We have to synchronize on the fd cache CS so that our calls to receive_fd
diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index dc345a1b55..7239c29985 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -1157,6 +1157,9 @@ NTSTATUS WINAPI NtSignalAndWaitForSingleObject( HANDLE hSignalObject, HANDLE hWa
     select_op_t select_op;
     UINT flags = SELECT_INTERRUPTIBLE;
 
+    if (do_esync())
+        return esync_signal_and_wait( hSignalObject, hWaitObject, alertable, timeout );
+
     if (!hSignalObject) return STATUS_INVALID_HANDLE;
 
     if (alertable) flags |= SELECT_ALERTABLE;
-- 
2.20.1


From 10cda993286a72a2b17a3ccf32c0e03b421e1847 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 10 Jun 2018 16:11:54 -0500
Subject: [PATCH 32/83] server, ntdll: Also store the esync type in the server.

And validate it there while we're at it.

We need to do this because CreateEvent() ignores the passed-in parameter
when opening an existing event.
---
 dlls/ntdll/esync.c             | 23 +++++++++++++++--------
 include/wine/server_protocol.h |  4 +++-
 server/esync.c                 | 28 ++++++++++++++++++++++++----
 server/protocol.def            |  2 ++
 server/request.h               |  4 +++-
 server/trace.c                 |  2 ++
 6 files changed, 49 insertions(+), 14 deletions(-)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 79d3c2df08..0b373e36ed 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -234,8 +234,10 @@ NTSTATUS esync_close( HANDLE handle )
     return STATUS_INVALID_HANDLE;
 }
 
-static NTSTATUS create_esync(int *fd, HANDLE *handle, ACCESS_MASK access,
-    const OBJECT_ATTRIBUTES *attr, int initval, int flags)
+/* type is an in-out parameter; if the object already existed it returns the
+ * actual type. */
+static NTSTATUS create_esync(enum esync_type *type, int *fd, HANDLE *handle,
+    ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr, int initval, int flags)
 {
     NTSTATUS ret;
     data_size_t len;
@@ -253,11 +255,13 @@ static NTSTATUS create_esync(int *fd, HANDLE *handle, ACCESS_MASK access,
         req->access  = access;
         req->initval = initval;
         req->flags   = flags;
+        req->type    = *type;
         wine_server_add_data( req, objattr, len );
         ret = wine_server_call( req );
         if (!ret || ret == STATUS_OBJECT_NAME_EXISTS)
         {
             *handle = wine_server_ptr_handle( reply->handle );
+            *type = reply->type;
             *fd = receive_fd( &fd_handle );
             assert( wine_server_ptr_handle(fd_handle) == *handle );
         }
@@ -274,6 +278,7 @@ static NTSTATUS create_esync(int *fd, HANDLE *handle, ACCESS_MASK access,
 NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, LONG initial, LONG max)
 {
+    enum esync_type type = ESYNC_SEMAPHORE;
     struct semaphore *semaphore;
     NTSTATUS ret;
     int fd = -1;
@@ -281,7 +286,7 @@ NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
     TRACE("name %s, initial %d, max %d.\n",
         attr ? debugstr_us(attr->ObjectName) : "<no name>", initial, max);
 
-    ret = create_esync( &fd, handle, access, attr, initial, EFD_SEMAPHORE );
+    ret = create_esync( &type, &fd, handle, access, attr, initial, EFD_SEMAPHORE );
     if (!ret || ret == STATUS_OBJECT_NAME_EXISTS)
     {
         semaphore = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*semaphore) );
@@ -320,24 +325,25 @@ NTSTATUS esync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev )
 }
 
 NTSTATUS esync_create_event( HANDLE *handle, ACCESS_MASK access,
-    const OBJECT_ATTRIBUTES *attr, EVENT_TYPE type, BOOLEAN initial )
+    const OBJECT_ATTRIBUTES *attr, EVENT_TYPE event_type, BOOLEAN initial )
 {
+    enum esync_type type = (event_type == SynchronizationEvent ? ESYNC_AUTO_EVENT : ESYNC_MANUAL_EVENT);
     struct event *event;
     NTSTATUS ret;
     int fd;
 
     TRACE("name %s, %s-reset, initial %d.\n",
         attr ? debugstr_us(attr->ObjectName) : "<no name>",
-        type == NotificationEvent ? "manual" : "auto", initial);
+        event_type == NotificationEvent ? "manual" : "auto", initial);
 
-    ret = create_esync( &fd, handle, access, attr, initial, 0 );
+    ret = create_esync( &type, &fd, handle, access, attr, initial, 0 );
     if (!ret || ret == STATUS_OBJECT_NAME_EXISTS)
     {
         event = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*event) );
         if (!event)
             return STATUS_NO_MEMORY;
 
-        event->obj.type = (type == NotificationEvent ? ESYNC_MANUAL_EVENT : ESYNC_AUTO_EVENT);
+        event->obj.type = type; /* note that the server might give us the real type */
         event->obj.fd = fd;
 
         add_to_list( *handle, &event->obj);
@@ -398,6 +404,7 @@ NTSTATUS esync_pulse_event( HANDLE handle )
 NTSTATUS esync_create_mutex( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, BOOLEAN initial )
 {
+    enum esync_type type = ESYNC_MUTEX;
     struct mutex *mutex;
     NTSTATUS ret;
     int fd;
@@ -405,7 +412,7 @@ NTSTATUS esync_create_mutex( HANDLE *handle, ACCESS_MASK access,
     TRACE("name %s, initial %d.\n",
         attr ? debugstr_us(attr->ObjectName) : "<no name>", initial);
 
-    ret = create_esync( &fd, handle, access, attr, initial ? 0 : 1, 0 );
+    ret = create_esync( &type, &fd, handle, access, attr, initial ? 0 : 1, 0 );
     if (!ret || ret == STATUS_OBJECT_NAME_EXISTS)
     {
         mutex = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*mutex) );
diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index f50334bf7a..b16a9190c2 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -5671,13 +5671,15 @@ struct create_esync_request
     unsigned int access;
     int          initval;
     int          flags;
+    int          type;
     /* VARARG(objattr,object_attributes); */
+    char __pad_28[4];
 };
 struct create_esync_reply
 {
     struct reply_header __header;
     obj_handle_t handle;
-    char __pad_12[4];
+    int          type;
 };
 
 
diff --git a/server/esync.c b/server/esync.c
index ef02170021..6cc212e2b9 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -55,6 +55,7 @@ struct esync
 {
     struct object   obj;    /* object header */
     int             fd;     /* eventfd file descriptor */
+    enum esync_type type;
 };
 
 static void esync_dump( struct object *obj, int verbose );
@@ -96,9 +97,16 @@ static void esync_destroy( struct object *obj )
     close( esync->fd );
 }
 
-struct esync *create_esync( struct object *root, const struct unicode_str *name,
-                            unsigned int attr, int initval, int flags,
-                            const struct security_descriptor *sd )
+static int type_matches( enum esync_type type1, enum esync_type type2 )
+{
+    return (type1 == type2) ||
+           ((type1 == ESYNC_AUTO_EVENT || type1 == ESYNC_MANUAL_EVENT) &&
+            (type2 == ESYNC_AUTO_EVENT || type2 == ESYNC_MANUAL_EVENT));
+}
+
+static struct esync *create_esync( struct object *root, const struct unicode_str *name,
+    unsigned int attr, int initval, int flags, enum esync_type type,
+    const struct security_descriptor *sd )
 {
 #ifdef HAVE_SYS_EVENTFD_H
     struct esync *esync;
@@ -116,6 +124,17 @@ struct esync *create_esync( struct object *root, const struct unicode_str *name,
                 release_object( esync );
                 return NULL;
             }
+            esync->type = type;
+        }
+        else
+        {
+            /* validate the type */
+            if (!type_matches( type, esync->type ))
+            {
+                release_object( &esync->obj );
+                set_error( STATUS_OBJECT_TYPE_MISMATCH );
+                return NULL;
+            }
         }
     }
     return esync;
@@ -198,7 +217,7 @@ DECL_HANDLER(create_esync)
 
     if (!objattr) return;
 
-    if ((esync = create_esync( root, &name, objattr->attributes, req->initval, req->flags, sd )))
+    if ((esync = create_esync( root, &name, objattr->attributes, req->initval, req->flags, req->type, sd )))
     {
         if (get_error() == STATUS_OBJECT_NAME_EXISTS)
             reply->handle = alloc_handle( current->process, esync, req->access, objattr->attributes );
@@ -206,6 +225,7 @@ DECL_HANDLER(create_esync)
             reply->handle = alloc_handle_no_access_check( current->process, esync,
                                                           req->access, objattr->attributes );
 
+        reply->type = esync->type;
         send_client_fd( current->process, esync->fd, reply->handle );
         release_object( esync );
     }
diff --git a/server/protocol.def b/server/protocol.def
index a7c6ffdd01..4819124e56 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -3869,9 +3869,11 @@ struct handle_info
     unsigned int access;        /* wanted access rights */
     int          initval;       /* initial value */
     int          flags;         /* flags (EFD_SEMAPHORE or 0) */
+    int          type;          /* type of esync object (see below) */
     VARARG(objattr,object_attributes); /* object attributes */
 @REPLY
     obj_handle_t handle;        /* handle to the object */
+    int          type;          /* type of esync object (see below) */
 @END
 
 /* Retrieve the esync fd for an object. */
diff --git a/server/request.h b/server/request.h
index ca9a83632e..1295fb8304 100644
--- a/server/request.h
+++ b/server/request.h
@@ -2413,8 +2413,10 @@ C_ASSERT( sizeof(struct terminate_job_request) == 24 );
 C_ASSERT( FIELD_OFFSET(struct create_esync_request, access) == 12 );
 C_ASSERT( FIELD_OFFSET(struct create_esync_request, initval) == 16 );
 C_ASSERT( FIELD_OFFSET(struct create_esync_request, flags) == 20 );
-C_ASSERT( sizeof(struct create_esync_request) == 24 );
+C_ASSERT( FIELD_OFFSET(struct create_esync_request, type) == 24 );
+C_ASSERT( sizeof(struct create_esync_request) == 32 );
 C_ASSERT( FIELD_OFFSET(struct create_esync_reply, handle) == 8 );
+C_ASSERT( FIELD_OFFSET(struct create_esync_reply, type) == 12 );
 C_ASSERT( sizeof(struct create_esync_reply) == 16 );
 C_ASSERT( FIELD_OFFSET(struct get_esync_fd_request, handle) == 12 );
 C_ASSERT( sizeof(struct get_esync_fd_request) == 16 );
diff --git a/server/trace.c b/server/trace.c
index 58c5db0b10..e9f188f785 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -4546,12 +4546,14 @@ static void dump_create_esync_request( const struct create_esync_request *req )
     fprintf( stderr, " access=%08x", req->access );
     fprintf( stderr, ", initval=%d", req->initval );
     fprintf( stderr, ", flags=%d", req->flags );
+    fprintf( stderr, ", type=%d", req->type );
     dump_varargs_object_attributes( ", objattr=", cur_size );
 }
 
 static void dump_create_esync_reply( const struct create_esync_reply *req )
 {
     fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, ", type=%d", req->type );
 }
 
 static void dump_get_esync_fd_request( const struct get_esync_fd_request *req )
-- 
2.20.1


From 55d12cdb7afd754a74969779237250ebc6307c1a Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 10 Jun 2018 00:29:27 -0500
Subject: [PATCH 33/83] ntdll, server: Implement NtOpenSemaphore().

---
 dlls/ntdll/esync.c             | 60 ++++++++++++++++++++++++++++++++++
 dlls/ntdll/esync.h             |  2 ++
 dlls/ntdll/sync.c              |  3 ++
 include/wine/server_protocol.h | 21 ++++++++++++
 server/esync.c                 | 30 +++++++++++++++++
 server/protocol.def            | 12 +++++++
 server/request.h               | 10 ++++++
 server/trace.c                 | 18 ++++++++++
 8 files changed, 156 insertions(+)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 0b373e36ed..f840b57171 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -275,6 +275,37 @@ static NTSTATUS create_esync(enum esync_type *type, int *fd, HANDLE *handle,
     return ret;
 }
 
+static NTSTATUS open_esync( enum esync_type *type, int *fd, HANDLE *handle,
+    ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
+{
+    NTSTATUS ret;
+    obj_handle_t fd_handle;
+    sigset_t sigset;
+
+    server_enter_uninterrupted_section( &fd_cache_section, &sigset );
+    SERVER_START_REQ( open_esync )
+    {
+        req->access     = access;
+        req->attributes = attr->Attributes;
+        req->rootdir    = wine_server_obj_handle( attr->RootDirectory );
+        req->type       = *type;
+        if (attr->ObjectName)
+            wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
+        if (!(ret = wine_server_call( req )))
+        {
+            *handle = wine_server_ptr_handle( reply->handle );
+            *type = reply->type;
+            *fd = receive_fd( &fd_handle );
+            assert( wine_server_ptr_handle(fd_handle) == *handle );
+        }
+    }
+    SERVER_END_REQ;
+    server_leave_uninterrupted_section( &fd_cache_section, &sigset );
+
+    TRACE("-> handle %p, fd %d.\n", *handle, *fd);
+    return ret;
+}
+
 NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, LONG initial, LONG max)
 {
@@ -303,6 +334,35 @@ NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
     return ret;
 }
 
+NTSTATUS esync_open_semaphore( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr )
+{
+    enum esync_type type = ESYNC_SEMAPHORE;
+    struct semaphore *semaphore;
+    NTSTATUS ret;
+    int fd = -1;
+
+    TRACE("name %s.\n", debugstr_us(attr->ObjectName));
+
+    ret = open_esync( &type, &fd, handle, access, attr );
+    if (!ret)
+    {
+        semaphore = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*semaphore) );
+        if (!semaphore)
+            return STATUS_NO_MEMORY;
+
+        semaphore->obj.type = ESYNC_SEMAPHORE;
+        semaphore->obj.fd = fd;
+
+        FIXME("Attempt to open a semaphore, this will not work.\n");
+        semaphore->max = 0xdeadbeef;
+
+        add_to_list( *handle, &semaphore->obj );
+    }
+
+    return ret;
+}
+
 NTSTATUS esync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev )
 {
     struct semaphore *semaphore = esync_get_object( handle );
diff --git a/dlls/ntdll/esync.h b/dlls/ntdll/esync.h
index 979c3d81e2..73bb3c1cfc 100644
--- a/dlls/ntdll/esync.h
+++ b/dlls/ntdll/esync.h
@@ -32,6 +32,8 @@ extern NTSTATUS esync_pulse_event( HANDLE handle ) DECLSPEC_HIDDEN;
 extern NTSTATUS esync_create_mutex( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, BOOLEAN initial ) DECLSPEC_HIDDEN;
 extern NTSTATUS esync_release_mutex( HANDLE *handle, LONG *prev ) DECLSPEC_HIDDEN;
+extern NTSTATUS esync_open_semaphore( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr ) DECLSPEC_HIDDEN;
 
 extern NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
                                     BOOLEAN alertable, const LARGE_INTEGER *timeout ) DECLSPEC_HIDDEN;
diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index 7239c29985..e94158ffb3 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -279,6 +279,9 @@ NTSTATUS WINAPI NtOpenSemaphore( HANDLE *handle, ACCESS_MASK access, const OBJEC
 
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
+    if (do_esync())
+        return esync_open_semaphore( handle, access, attr );
+
     SERVER_START_REQ( open_semaphore )
     {
         req->access     = access;
diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index b16a9190c2..d25db2e800 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -5683,6 +5683,24 @@ struct create_esync_reply
 };
 
 
+struct open_esync_request
+{
+    struct request_header __header;
+    unsigned int access;
+    unsigned int attributes;
+    obj_handle_t rootdir;
+    int          type;
+    /* VARARG(name,unicode_str); */
+    char __pad_28[4];
+};
+struct open_esync_reply
+{
+    struct reply_header __header;
+    obj_handle_t handle;
+    int          type;
+};
+
+
 struct get_esync_fd_request
 {
     struct request_header __header;
@@ -6000,6 +6018,7 @@ enum request
     REQ_set_job_completion_port,
     REQ_terminate_job,
     REQ_create_esync,
+    REQ_open_esync,
     REQ_get_esync_fd,
     REQ_NB_REQUESTS
 };
@@ -6300,6 +6319,7 @@ union generic_request
     struct set_job_completion_port_request set_job_completion_port_request;
     struct terminate_job_request terminate_job_request;
     struct create_esync_request create_esync_request;
+    struct open_esync_request open_esync_request;
     struct get_esync_fd_request get_esync_fd_request;
 };
 union generic_reply
@@ -6598,6 +6618,7 @@ union generic_reply
     struct set_job_completion_port_reply set_job_completion_port_reply;
     struct terminate_job_reply terminate_job_reply;
     struct create_esync_reply create_esync_reply;
+    struct open_esync_reply open_esync_reply;
     struct get_esync_fd_reply get_esync_fd_reply;
 };
 
diff --git a/server/esync.c b/server/esync.c
index 6cc212e2b9..2c89152f15 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -233,6 +233,36 @@ DECL_HANDLER(create_esync)
     if (root) release_object( root );
 }
 
+DECL_HANDLER(open_esync)
+{
+    struct unicode_str name = get_req_unicode_str();
+
+    reply->handle = open_object( current->process, req->rootdir, req->access,
+                                 &esync_ops, &name, req->attributes );
+
+    /* send over the fd */
+    if (reply->handle)
+    {
+        struct esync *esync;
+
+        if (!(esync = (struct esync *)get_handle_obj( current->process, reply->handle,
+                                                      0, &esync_ops )))
+            return;
+
+        if (!type_matches( req->type, esync->type ))
+        {
+            set_error( STATUS_OBJECT_TYPE_MISMATCH );
+            release_object( esync );
+            return;
+        }
+
+        reply->type = esync->type;
+
+        send_client_fd( current->process, esync->fd, reply->handle );
+        release_object( esync );
+    }
+}
+
 /* Retrieve a file descriptor for an esync object which will be signaled by the
  * server. The client should only read from (i.e. wait on) this object. */
 DECL_HANDLER(get_esync_fd)
diff --git a/server/protocol.def b/server/protocol.def
index 4819124e56..460df2e070 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -3876,6 +3876,18 @@ struct handle_info
     int          type;          /* type of esync object (see below) */
 @END
 
+/* Open an esync object */
+@REQ(open_esync)
+    unsigned int access;        /* wanted access rights */
+    unsigned int attributes;    /* object attributes */
+    obj_handle_t rootdir;       /* root directory */
+    int          type;          /* type of esync object (above) */
+    VARARG(name,unicode_str);   /* object name */
+@REPLY
+    obj_handle_t handle;        /* handle to the event */
+    int          type;          /* type of esync object (above) */
+@END
+
 /* Retrieve the esync fd for an object. */
 @REQ(get_esync_fd)
     obj_handle_t handle;        /* handle to the object */
diff --git a/server/request.h b/server/request.h
index 1295fb8304..326c196d67 100644
--- a/server/request.h
+++ b/server/request.h
@@ -404,6 +404,7 @@ DECL_HANDLER(set_job_limits);
 DECL_HANDLER(set_job_completion_port);
 DECL_HANDLER(terminate_job);
 DECL_HANDLER(create_esync);
+DECL_HANDLER(open_esync);
 DECL_HANDLER(get_esync_fd);
 
 #ifdef WANT_REQUEST_HANDLERS
@@ -703,6 +704,7 @@ static const req_handler req_handlers[REQ_NB_REQUESTS] =
     (req_handler)req_set_job_completion_port,
     (req_handler)req_terminate_job,
     (req_handler)req_create_esync,
+    (req_handler)req_open_esync,
     (req_handler)req_get_esync_fd,
 };
 
@@ -2418,6 +2420,14 @@ C_ASSERT( sizeof(struct create_esync_request) == 32 );
 C_ASSERT( FIELD_OFFSET(struct create_esync_reply, handle) == 8 );
 C_ASSERT( FIELD_OFFSET(struct create_esync_reply, type) == 12 );
 C_ASSERT( sizeof(struct create_esync_reply) == 16 );
+C_ASSERT( FIELD_OFFSET(struct open_esync_request, access) == 12 );
+C_ASSERT( FIELD_OFFSET(struct open_esync_request, attributes) == 16 );
+C_ASSERT( FIELD_OFFSET(struct open_esync_request, rootdir) == 20 );
+C_ASSERT( FIELD_OFFSET(struct open_esync_request, type) == 24 );
+C_ASSERT( sizeof(struct open_esync_request) == 32 );
+C_ASSERT( FIELD_OFFSET(struct open_esync_reply, handle) == 8 );
+C_ASSERT( FIELD_OFFSET(struct open_esync_reply, type) == 12 );
+C_ASSERT( sizeof(struct open_esync_reply) == 16 );
 C_ASSERT( FIELD_OFFSET(struct get_esync_fd_request, handle) == 12 );
 C_ASSERT( sizeof(struct get_esync_fd_request) == 16 );
 C_ASSERT( FIELD_OFFSET(struct get_esync_fd_reply, type) == 8 );
diff --git a/server/trace.c b/server/trace.c
index e9f188f785..3554d408fb 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -4556,6 +4556,21 @@ static void dump_create_esync_reply( const struct create_esync_reply *req )
     fprintf( stderr, ", type=%d", req->type );
 }
 
+static void dump_open_esync_request( const struct open_esync_request *req )
+{
+    fprintf( stderr, " access=%08x", req->access );
+    fprintf( stderr, ", attributes=%08x", req->attributes );
+    fprintf( stderr, ", rootdir=%04x", req->rootdir );
+    fprintf( stderr, ", type=%d", req->type );
+    dump_varargs_unicode_str( ", name=", cur_size );
+}
+
+static void dump_open_esync_reply( const struct open_esync_reply *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, ", type=%d", req->type );
+}
+
 static void dump_get_esync_fd_request( const struct get_esync_fd_request *req )
 {
     fprintf( stderr, " handle=%04x", req->handle );
@@ -4859,6 +4874,7 @@ static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_set_job_completion_port_request,
     (dump_func)dump_terminate_job_request,
     (dump_func)dump_create_esync_request,
+    (dump_func)dump_open_esync_request,
     (dump_func)dump_get_esync_fd_request,
 };
 
@@ -5155,6 +5171,7 @@ static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {
     NULL,
     NULL,
     (dump_func)dump_create_esync_reply,
+    (dump_func)dump_open_esync_reply,
     (dump_func)dump_get_esync_fd_reply,
 };
 
@@ -5451,6 +5468,7 @@ static const char * const req_names[REQ_NB_REQUESTS] = {
     "set_job_completion_port",
     "terminate_job",
     "create_esync",
+    "open_esync",
     "get_esync_fd",
 };
 
-- 
2.20.1


From 3dd261f28214828adc712fd297887ef8a5492909 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 10 Jun 2018 00:42:15 -0500
Subject: [PATCH 34/83] ntdll: Implement NtOpenEvent().

---
 dlls/ntdll/esync.c | 26 ++++++++++++++++++++++++++
 dlls/ntdll/esync.h |  2 ++
 dlls/ntdll/sync.c  |  3 +++
 3 files changed, 31 insertions(+)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index f840b57171..cc6b50816f 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -412,6 +412,32 @@ NTSTATUS esync_create_event( HANDLE *handle, ACCESS_MASK access,
     return ret;
 }
 
+NTSTATUS esync_open_event( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr )
+{
+    enum esync_type type = ESYNC_AUTO_EVENT;
+    struct event *event;
+    NTSTATUS ret;
+    int fd;
+
+    TRACE("name %s.\n", debugstr_us(attr->ObjectName));
+
+    ret = open_esync( &type, &fd, handle, access, attr );
+    if (!ret)
+    {
+        event = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*event) );
+        if (!event)
+            return STATUS_NO_MEMORY;
+
+        event->obj.type = type;
+        event->obj.fd = fd;
+
+        add_to_list( *handle, &event->obj );
+    }
+
+    return ret;
+}
+
 NTSTATUS esync_set_event( HANDLE handle )
 {
     struct event *event = esync_get_object( handle );
diff --git a/dlls/ntdll/esync.h b/dlls/ntdll/esync.h
index 73bb3c1cfc..f2134fc9af 100644
--- a/dlls/ntdll/esync.h
+++ b/dlls/ntdll/esync.h
@@ -34,6 +34,8 @@ extern NTSTATUS esync_create_mutex( HANDLE *handle, ACCESS_MASK access,
 extern NTSTATUS esync_release_mutex( HANDLE *handle, LONG *prev ) DECLSPEC_HIDDEN;
 extern NTSTATUS esync_open_semaphore( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr ) DECLSPEC_HIDDEN;
+extern NTSTATUS esync_open_event( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr ) DECLSPEC_HIDDEN;
 
 extern NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
                                     BOOLEAN alertable, const LARGE_INTEGER *timeout ) DECLSPEC_HIDDEN;
diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index e94158ffb3..c0121316a8 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -398,6 +398,9 @@ NTSTATUS WINAPI NtOpenEvent( HANDLE *handle, ACCESS_MASK access, const OBJECT_AT
 
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
+    if (do_esync())
+        return esync_open_event( handle, access, attr );
+
     SERVER_START_REQ( open_event )
     {
         req->access     = access;
-- 
2.20.1


From ed7ae76956500602d395db1db1732408db01d4c3 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 10 Jun 2018 00:44:54 -0500
Subject: [PATCH 35/83] ntdll: Implement NtOpenMutant().

---
 dlls/ntdll/esync.c | 30 ++++++++++++++++++++++++++++++
 dlls/ntdll/esync.h |  2 ++
 dlls/ntdll/sync.c  |  3 +++
 3 files changed, 35 insertions(+)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index cc6b50816f..01aed5c83a 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -520,6 +520,36 @@ NTSTATUS esync_create_mutex( HANDLE *handle, ACCESS_MASK access,
     return ret;
 }
 
+NTSTATUS esync_open_mutex( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr )
+{
+    enum esync_type type = ESYNC_MUTEX;
+    struct mutex *mutex;
+    NTSTATUS ret;
+    int fd;
+
+    TRACE("name %s.\n", debugstr_us(attr->ObjectName));
+
+    ret = open_esync( &type, &fd, handle, access, attr );
+    if (!ret)
+    {
+        mutex = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*mutex) );
+        if (!mutex)
+            return STATUS_NO_MEMORY;
+
+        mutex->obj.type = ESYNC_MUTEX;
+        mutex->obj.fd = fd;
+
+        FIXME("Attempt to open a mutex; this will not work.\n");
+        mutex->tid = 0;
+        mutex->count = 0;
+
+        add_to_list( *handle, &mutex->obj );
+    }
+
+    return ret;
+}
+
 NTSTATUS esync_release_mutex( HANDLE *handle, LONG *prev )
 {
     struct mutex *mutex = esync_get_object( handle );
diff --git a/dlls/ntdll/esync.h b/dlls/ntdll/esync.h
index f2134fc9af..ba9e9ec4ac 100644
--- a/dlls/ntdll/esync.h
+++ b/dlls/ntdll/esync.h
@@ -36,6 +36,8 @@ extern NTSTATUS esync_open_semaphore( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr ) DECLSPEC_HIDDEN;
 extern NTSTATUS esync_open_event( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr ) DECLSPEC_HIDDEN;
+extern NTSTATUS esync_open_mutex( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr ) DECLSPEC_HIDDEN;
 
 extern NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
                                     BOOLEAN alertable, const LARGE_INTEGER *timeout ) DECLSPEC_HIDDEN;
diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index c0121316a8..e13c6a247b 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -580,6 +580,9 @@ NTSTATUS WINAPI NtOpenMutant( HANDLE *handle, ACCESS_MASK access, const OBJECT_A
 
     if ((status = validate_open_object_attributes( attr ))) return status;
 
+    if (do_esync())
+        return esync_open_mutex( handle, access, attr );
+
     SERVER_START_REQ( open_mutex )
     {
         req->access  = access;
-- 
2.20.1


From 86c97312a75ed40c43998f2fe96289221f9ddd27 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 10 Jun 2018 12:08:51 -0500
Subject: [PATCH 36/83] ntdll: Record the current count of a semaphore locally.

And check it against the maximum, and return it if requested.

Of course, this won't work across processes.

This should be thread-safe.
---
 dlls/ntdll/esync.c | 39 ++++++++++++++++++++++++++++++++++-----
 1 file changed, 34 insertions(+), 5 deletions(-)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 01aed5c83a..d69baecec6 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -89,6 +89,7 @@ struct semaphore
 {
     struct esync obj;
     int max;
+    int count;
 };
 
 struct event
@@ -327,6 +328,7 @@ NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
         semaphore->obj.type = ESYNC_SEMAPHORE;
         semaphore->obj.fd = fd;
         semaphore->max = max;
+        semaphore->count = initial;
 
         add_to_list( *handle, &semaphore->obj );
     }
@@ -355,6 +357,7 @@ NTSTATUS esync_open_semaphore( HANDLE *handle, ACCESS_MASK access,
         semaphore->obj.fd = fd;
 
         FIXME("Attempt to open a semaphore, this will not work.\n");
+        semaphore->count = 0;
         semaphore->max = 0xdeadbeef;
 
         add_to_list( *handle, &semaphore->obj );
@@ -367,16 +370,27 @@ NTSTATUS esync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev )
 {
     struct semaphore *semaphore = esync_get_object( handle );
     uint64_t count64 = count;
+    ULONG current;
 
     TRACE("%p, %d, %p.\n", handle, count, prev);
 
     if (!semaphore) return STATUS_INVALID_HANDLE;
 
-    if (prev)
+    /* FIXME: This won't work across processes. In that case it may be best to
+     * use shared memory. */
+    do
     {
-        FIXME("Can't write previous value.\n");
-        *prev = 1;
-    }
+        current = semaphore->count;
+
+        if (count + current > semaphore->max)
+            return STATUS_SEMAPHORE_LIMIT_EXCEEDED;
+    } while (interlocked_cmpxchg( &semaphore->count, count + current, current ) != current);
+
+    if (prev) *prev = current;
+
+    /* We don't have to worry about a race between increasing the count and
+     * write(). The fact that we were able to increase the count means that we
+     * have permission to actually write that many releases to the semaphore. */
 
     if (write( semaphore->obj.fd, &count64, sizeof(count64) ) == -1)
         return FILE_GetNtStatus();
@@ -775,6 +789,15 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
                                     mutex->tid = GetCurrentThreadId();
                                     mutex->count = 1;
                                 }
+                                else if (obj->type == ESYNC_SEMAPHORE)
+                                {
+                                    struct semaphore *semaphore = (struct semaphore *)obj;
+                                    /* We don't have to worry about a race between this and read();
+                                     * the fact that we were able to grab it at all means the count
+                                     * is nonzero, and if someone else grabbed it then the count
+                                     * must have been >= 2, etc. */
+                                    interlocked_xchg_add( &semaphore->count, -1 );
+                                }
                                 return i;
                             }
                         }
@@ -913,7 +936,8 @@ tryagain:
                 }
 
                 /* If we got here, we successfully waited on every object. */
-                /* Make sure to let ourselves know that we grabbed the mutexes. */
+                /* Make sure to let ourselves know that we grabbed the mutexes
+                 * and semaphores. */
                 for (i = 0; i < count; i++)
                 {
                     if (objs[i]->type == ESYNC_MUTEX)
@@ -922,6 +946,11 @@ tryagain:
                         mutex->tid = GetCurrentThreadId();
                         mutex->count++;
                     }
+                    else if (objs[i]->type == ESYNC_SEMAPHORE)
+                    {
+                        struct semaphore *semaphore = (struct semaphore *)objs[i];
+                        interlocked_xchg_add( &semaphore->count, -1 );
+                    }
                 }
                 TRACE("Wait successful.\n");
                 return STATUS_SUCCESS;
-- 
2.20.1


From 17e00a36aef72fab678e970e0bd9defa2add58b8 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 10 Jun 2018 19:08:18 -0500
Subject: [PATCH 37/83] server: Implement esync_map_access().

---
 server/esync.c | 13 ++++++++++++-
 1 file changed, 12 insertions(+), 1 deletion(-)

diff --git a/server/esync.c b/server/esync.c
index 2c89152f15..63f8258429 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -59,6 +59,7 @@ struct esync
 };
 
 static void esync_dump( struct object *obj, int verbose );
+static unsigned int esync_map_access( struct object *obj, unsigned int access );
 static void esync_destroy( struct object *obj );
 
 const struct object_ops esync_ops =
@@ -73,7 +74,7 @@ const struct object_ops esync_ops =
     NULL,                      /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
-    no_map_access,             /* map_access */
+    esync_map_access,          /* map_access */
     default_get_sd,            /* get_sd */
     default_set_sd,            /* set_sd */
     no_lookup_name,            /* lookup_name */
@@ -91,6 +92,16 @@ static void esync_dump( struct object *obj, int verbose )
     fprintf( stderr, "esync fd=%d\n", esync->fd );
 }
 
+static unsigned int esync_map_access( struct object *obj, unsigned int access )
+{
+    /* Sync objects have the same flags. */
+    if (access & GENERIC_READ)    access |= STANDARD_RIGHTS_READ | EVENT_QUERY_STATE;
+    if (access & GENERIC_WRITE)   access |= STANDARD_RIGHTS_WRITE | EVENT_MODIFY_STATE;
+    if (access & GENERIC_EXECUTE) access |= STANDARD_RIGHTS_EXECUTE | SYNCHRONIZE;
+    if (access & GENERIC_ALL)     access |= STANDARD_RIGHTS_ALL | EVENT_QUERY_STATE | EVENT_MODIFY_STATE;
+    return access & ~(GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL);
+}
+
 static void esync_destroy( struct object *obj )
 {
     struct esync *esync = (struct esync *)obj;
-- 
2.20.1


From e12eedd451693b55f0e783d089a0344ede64b7ad Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 11 Jun 2018 16:43:24 -0500
Subject: [PATCH 38/83] server: Alter conditions in is_queue_hung().

Unusually, I've elected not to guard this with do_esync(). I think this is a better way of checking for a hung queue in general, both because it's simpler and because it makes more sense: a queue is hung if it has messages it hasn't processed, not necessarily if it isn't actively waiting for messages. For example, a queue could be not associated with a window, and only waiting for messages when it makes sense to do so (due to some internal program logic). Or a thread could elect to poll its message queue with, say, GetQueueStatus(), and only get messages when there are messages to process.

And, of course, this stops esync threads from being considered hung, since obviously the server has no idea that they are indeed waiting on their own queue. Normally nobody cares about this, but as of f6b0ce3c the server refuses to deliver hooks to a hung queue, and so we need to avoid a queue being wrongly considered hung.
---
 server/queue.c | 12 +-----------
 1 file changed, 1 insertion(+), 11 deletions(-)

diff --git a/server/queue.c b/server/queue.c
index 24fab78a89..d88edb0f73 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -910,17 +910,7 @@ static void cleanup_results( struct msg_queue *queue )
 /* check if the thread owning the queue is hung (not checking for messages) */
 static int is_queue_hung( struct msg_queue *queue )
 {
-    struct wait_queue_entry *entry;
-
-    if (current_time - queue->last_get_msg <= 5 * TICKS_PER_SEC)
-        return 0;  /* less than 5 seconds since last get message -> not hung */
-
-    LIST_FOR_EACH_ENTRY( entry, &queue->obj.wait_queue, struct wait_queue_entry, entry )
-    {
-        if (get_wait_queue_thread(entry)->queue == queue)
-            return 0;  /* thread is waiting on queue -> not hung */
-    }
-    return 1;
+    return is_signaled( queue ) && (current_time - queue->last_get_msg > 5 * TICKS_PER_SEC);
 }
 
 static int msg_queue_add_queue( struct object *obj, struct wait_queue_entry *entry )
-- 
2.20.1


From c5a7bc7d9da3bdcb7ac32a0a4486ef86c7fb7a33 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 13 Jun 2018 14:33:38 -0500
Subject: [PATCH 39/83] ntdll, server: Allow DuplicateHandle() to succeed by
 implementing esync_get_esync_fd().

Note that this only works for events.
---
 dlls/ntdll/esync.c | 45 ++++++++++++++++++++++++++++++++++++++++++---
 server/esync.c     | 10 +++++++++-
 2 files changed, 51 insertions(+), 4 deletions(-)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index d69baecec6..f63553a0c2 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -205,9 +205,48 @@ static NTSTATUS get_waitable_object( HANDLE handle, struct esync **obj )
 
     TRACE("Got fd %d for handle %p.\n", fd, handle);
 
-    esync = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*esync) );
-    esync->fd = fd;
-    esync->type = type;
+    switch (type)
+    {
+    case ESYNC_SEMAPHORE:
+    {
+        struct semaphore *semaphore = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*semaphore) );
+        semaphore->obj.type = ESYNC_SEMAPHORE;
+        semaphore->obj.fd = fd;
+
+        FIXME("Attempt to duplicate a semaphore; this will not work.\n");
+        semaphore->max = 0xdeadbeef;
+        semaphore->count = 0;
+        esync = &semaphore->obj;
+        break;
+    }
+    case ESYNC_AUTO_EVENT:
+    case ESYNC_MANUAL_EVENT:
+    {
+        struct event *event = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*event) );
+        event->obj.type = type;
+        event->obj.fd = fd;
+        esync = &event->obj;
+        break;
+    }
+    case ESYNC_MUTEX:
+    {
+        struct mutex *mutex = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*mutex) );
+        mutex->obj.type = type;
+        mutex->obj.fd = fd;
+
+        FIXME("Attempt to duplicate a mutex; this will not work.\n");
+        mutex->tid = 0;
+        mutex->count = 0;
+        esync = &mutex->obj;
+        break;
+    }
+    case ESYNC_MANUAL_SERVER:
+    case ESYNC_QUEUE:
+        esync = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*esync) );
+        esync->fd = fd;
+        esync->type = type;
+        break;
+    }
 
     add_to_list( handle, esync );
 
diff --git a/server/esync.c b/server/esync.c
index 63f8258429..399011ff0b 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -59,6 +59,7 @@ struct esync
 };
 
 static void esync_dump( struct object *obj, int verbose );
+static int esync_get_esync_fd( struct object *obj, enum esync_type *type );
 static unsigned int esync_map_access( struct object *obj, unsigned int access );
 static void esync_destroy( struct object *obj );
 
@@ -70,7 +71,7 @@ const struct object_ops esync_ops =
     no_add_queue,              /* add_queue */
     NULL,                      /* remove_queue */
     NULL,                      /* signaled */
-    NULL,                      /* get_esync_fd */
+    esync_get_esync_fd,        /* get_esync_fd */
     NULL,                      /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
@@ -92,6 +93,13 @@ static void esync_dump( struct object *obj, int verbose )
     fprintf( stderr, "esync fd=%d\n", esync->fd );
 }
 
+static int esync_get_esync_fd( struct object *obj, enum esync_type *type )
+{
+    struct esync *esync = (struct esync *)obj;
+    *type = esync->type;
+    return esync->fd;
+}
+
 static unsigned int esync_map_access( struct object *obj, unsigned int access )
 {
     /* Sync objects have the same flags. */
-- 
2.20.1


From 7cece62ba6995b22a8c7deadda8c7de3a4be2bb8 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 15 Jun 2018 11:01:44 -0500
Subject: [PATCH 40/83] server: Create eventfd descriptors for timers.

---
 dlls/ntdll/esync.c             |  1 +
 include/wine/server_protocol.h |  1 +
 server/protocol.def            |  1 +
 server/timer.c                 | 18 +++++++++++++++++-
 4 files changed, 20 insertions(+), 1 deletion(-)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index f63553a0c2..6409678e55 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -240,6 +240,7 @@ static NTSTATUS get_waitable_object( HANDLE handle, struct esync **obj )
         esync = &mutex->obj;
         break;
     }
+    case ESYNC_AUTO_SERVER:
     case ESYNC_MANUAL_SERVER:
     case ESYNC_QUEUE:
         esync = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*esync) );
diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index d25db2e800..bfe43d1689 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -5719,6 +5719,7 @@ enum esync_type
     ESYNC_AUTO_EVENT,
     ESYNC_MANUAL_EVENT,
     ESYNC_MUTEX,
+    ESYNC_AUTO_SERVER,
     ESYNC_MANUAL_SERVER,
     ESYNC_QUEUE,
 };
diff --git a/server/protocol.def b/server/protocol.def
index 460df2e070..5d8d1245d0 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -3901,6 +3901,7 @@ enum esync_type
     ESYNC_AUTO_EVENT,
     ESYNC_MANUAL_EVENT,
     ESYNC_MUTEX,
+    ESYNC_AUTO_SERVER,
     ESYNC_MANUAL_SERVER,
     ESYNC_QUEUE,
 };
diff --git a/server/timer.c b/server/timer.c
index 810349ae8a..3ee821c308 100644
--- a/server/timer.c
+++ b/server/timer.c
@@ -36,6 +36,7 @@
 #include "file.h"
 #include "handle.h"
 #include "request.h"
+#include "esync.h"
 
 struct timer
 {
@@ -48,11 +49,13 @@ struct timer
     struct thread       *thread;    /* thread that set the APC function */
     client_ptr_t         callback;  /* callback APC function */
     client_ptr_t         arg;       /* callback argument */
+    int                  esync_fd;  /* esync file descriptor */
 };
 
 static void timer_dump( struct object *obj, int verbose );
 static struct object_type *timer_get_type( struct object *obj );
 static int timer_signaled( struct object *obj, struct wait_queue_entry *entry );
+static int timer_get_esync_fd( struct object *obj, enum esync_type *type );
 static void timer_satisfied( struct object *obj, struct wait_queue_entry *entry );
 static unsigned int timer_map_access( struct object *obj, unsigned int access );
 static void timer_destroy( struct object *obj );
@@ -65,7 +68,7 @@ static const struct object_ops timer_ops =
     add_queue,                 /* add_queue */
     remove_queue,              /* remove_queue */
     timer_signaled,            /* signaled */
-    NULL,                      /* get_esync_fd */
+    timer_get_esync_fd,        /* get_esync_fd */
     timer_satisfied,           /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
@@ -98,6 +101,9 @@ static struct timer *create_timer( struct object *root, const struct unicode_str
             timer->period   = 0;
             timer->timeout  = NULL;
             timer->thread   = NULL;
+
+            if (do_esync())
+                timer->esync_fd = esync_create_fd( 0, 0 );
         }
     }
     return timer;
@@ -170,6 +176,9 @@ static int set_timer( struct timer *timer, timeout_t expire, unsigned int period
     {
         period = 0;  /* period doesn't make any sense for a manual timer */
         timer->signaled = 0;
+
+        if (do_esync())
+            esync_clear( timer->esync_fd );
     }
     timer->when     = (expire <= 0) ? current_time - expire : max( expire, current_time );
     timer->period   = period;
@@ -202,6 +211,13 @@ static int timer_signaled( struct object *obj, struct wait_queue_entry *entry )
     return timer->signaled;
 }
 
+static int timer_get_esync_fd( struct object *obj, enum esync_type *type )
+{
+    struct timer *timer = (struct timer *)obj;
+    *type = timer->manual ? ESYNC_MANUAL_SERVER : ESYNC_AUTO_SERVER;
+    return timer->esync_fd;
+}
+
 static void timer_satisfied( struct object *obj, struct wait_queue_entry *entry )
 {
     struct timer *timer = (struct timer *)obj;
-- 
2.20.1


From 2f36933d5776f48f3c8d20a626f97fc4c90dcdd2 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 10 Jun 2018 23:12:16 -0500
Subject: [PATCH 41/83] server: Allocate shared memory segments for semaphores
 and mutexes.

As has been described in the README, these two objects have state that can't
be expressed (or read from) the eventfd descriptor. Namely, for semaphores
we need to know the current lock count, and for mutexes we need to know the
 owner tid and the recursion count. To make these work across processes, we
store them in a global shared memory section.

This patch has no effect by itself; it's for separation.

We use the WINEPREFIX dir to discriminate shm sections for simultaneously
running servers; this is based off of code in libwine (specifically
init_server_dir()).
---
 include/wine/server_protocol.h |  4 +++
 server/esync.c                 | 65 ++++++++++++++++++++++++++++++++++
 server/esync.h                 |  1 +
 server/main.c                  |  4 +++
 server/protocol.def            |  2 ++
 server/request.h               |  6 ++--
 server/trace.c                 |  2 ++
 7 files changed, 82 insertions(+), 2 deletions(-)

diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index bfe43d1689..9c7469093a 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -5680,6 +5680,8 @@ struct create_esync_reply
     struct reply_header __header;
     obj_handle_t handle;
     int          type;
+    unsigned int shm_idx;
+    char __pad_20[4];
 };
 
 
@@ -5698,6 +5700,8 @@ struct open_esync_reply
     struct reply_header __header;
     obj_handle_t handle;
     int          type;
+    unsigned int shm_idx;
+    char __pad_20[4];
 };
 
 
diff --git a/server/esync.c b/server/esync.c
index 399011ff0b..f1a46afc23 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -21,16 +21,25 @@
 #include "config.h"
 #include "wine/port.h"
 
+#include <fcntl.h>
 #include <stdio.h>
 #include <stdarg.h>
 #ifdef HAVE_SYS_EVENTFD_H
 # include <sys/eventfd.h>
 #endif
+#ifdef HAVE_SYS_MMAN_H
+# include <sys/mman.h>
+#endif
+#ifdef HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#include <unistd.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "windef.h"
 #include "winternl.h"
+#include "wine/library.h"
 
 #include "handle.h"
 #include "request.h"
@@ -51,11 +60,46 @@ int do_esync(void)
 #endif
 }
 
+static char shm_name[29];
+static int shm_fd;
+static off_t shm_size;
+
+static void shm_cleanup(void)
+{
+    close( shm_fd );
+    if (shm_unlink( shm_name ) == -1)
+        perror( "shm_unlink" );
+}
+
+void esync_init(void)
+{
+    struct stat st;
+
+    if (stat( wine_get_config_dir(), &st ) == -1)
+        fatal_error( "cannot stat %s\n", wine_get_config_dir() );
+
+    if (st.st_ino != (unsigned long)st.st_ino)
+        sprintf( shm_name, "/wine-%lx%08lx-esync", (unsigned long)((unsigned long long)st.st_ino >> 32), (unsigned long)st.st_ino );
+    else
+        sprintf( shm_name, "/wine-%lx-esync", (unsigned long)st.st_ino );
+
+    shm_fd = shm_open( shm_name, O_RDWR | O_CREAT | O_EXCL, 0644 );
+    if (shm_fd == -1)
+        perror( "shm_open" );
+
+    shm_size = sysconf( _SC_PAGESIZE );
+    if (ftruncate( shm_fd, shm_size ) == -1)
+        perror( "ftruncate" );
+
+    atexit( shm_cleanup );
+}
+
 struct esync
 {
     struct object   obj;    /* object header */
     int             fd;     /* eventfd file descriptor */
     enum esync_type type;
+    unsigned int    shm_idx;    /* index into the shared memory section */
 };
 
 static void esync_dump( struct object *obj, int verbose );
@@ -144,6 +188,25 @@ static struct esync *create_esync( struct object *root, const struct unicode_str
                 return NULL;
             }
             esync->type = type;
+            if (type == ESYNC_SEMAPHORE || type == ESYNC_MUTEX)
+            {
+                /* Use the fd as index, since that'll be unique across all
+                 * processes, but should hopefully end up also allowing reuse. */
+                esync->shm_idx = esync->fd + 1; /* we keep index 0 reserved */
+                while (esync->shm_idx * 8 >= shm_size)
+                {
+                    /* Better expand the shm section. */
+                    shm_size += sysconf( _SC_PAGESIZE );
+                    if (ftruncate( shm_fd, shm_size ) == -1)
+                    {
+                        fprintf( stderr, "esync: couldn't expand %s to size %ld: ",
+                            shm_name, shm_size );
+                        perror( "ftruncate" );
+                    }
+                }
+            }
+            else
+                esync->shm_idx = 0;
         }
         else
         {
@@ -245,6 +308,7 @@ DECL_HANDLER(create_esync)
                                                           req->access, objattr->attributes );
 
         reply->type = esync->type;
+        reply->shm_idx = esync->shm_idx;
         send_client_fd( current->process, esync->fd, reply->handle );
         release_object( esync );
     }
@@ -276,6 +340,7 @@ DECL_HANDLER(open_esync)
         }
 
         reply->type = esync->type;
+        reply->shm_idx = esync->shm_idx;
 
         send_client_fd( current->process, esync->fd, reply->handle );
         release_object( esync );
diff --git a/server/esync.h b/server/esync.h
index 2687c72e41..aeb58c5469 100644
--- a/server/esync.h
+++ b/server/esync.h
@@ -19,6 +19,7 @@
  */
 
 extern int do_esync(void);
+void esync_init(void);
 int esync_create_fd( int initval, int flags );
 void esync_wake_up( struct object *obj );
 void esync_clear( int fd );
diff --git a/server/main.c b/server/main.c
index 7aed338e96..20d3c48c4d 100644
--- a/server/main.c
+++ b/server/main.c
@@ -36,6 +36,7 @@
 #include "file.h"
 #include "thread.h"
 #include "request.h"
+#include "esync.h"
 #include "wine/library.h"
 
 /* command-line options */
@@ -141,6 +142,9 @@ int main( int argc, char *argv[] )
     sock_init();
     open_master_socket();
 
+    if (do_esync())
+        esync_init();
+
     if (debug_level) fprintf( stderr, "wineserver: starting (pid=%ld)\n", (long) getpid() );
     init_signals();
     init_directories();
diff --git a/server/protocol.def b/server/protocol.def
index 5d8d1245d0..962ee32536 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -3874,6 +3874,7 @@ struct handle_info
 @REPLY
     obj_handle_t handle;        /* handle to the object */
     int          type;          /* type of esync object (see below) */
+    unsigned int shm_idx;       /* this object's index into the shm section */
 @END
 
 /* Open an esync object */
@@ -3886,6 +3887,7 @@ struct handle_info
 @REPLY
     obj_handle_t handle;        /* handle to the event */
     int          type;          /* type of esync object (above) */
+    unsigned int shm_idx;       /* this object's index into the shm section */
 @END
 
 /* Retrieve the esync fd for an object. */
diff --git a/server/request.h b/server/request.h
index 326c196d67..271d092fcf 100644
--- a/server/request.h
+++ b/server/request.h
@@ -2419,7 +2419,8 @@ C_ASSERT( FIELD_OFFSET(struct create_esync_request, type) == 24 );
 C_ASSERT( sizeof(struct create_esync_request) == 32 );
 C_ASSERT( FIELD_OFFSET(struct create_esync_reply, handle) == 8 );
 C_ASSERT( FIELD_OFFSET(struct create_esync_reply, type) == 12 );
-C_ASSERT( sizeof(struct create_esync_reply) == 16 );
+C_ASSERT( FIELD_OFFSET(struct create_esync_reply, shm_idx) == 16 );
+C_ASSERT( sizeof(struct create_esync_reply) == 24 );
 C_ASSERT( FIELD_OFFSET(struct open_esync_request, access) == 12 );
 C_ASSERT( FIELD_OFFSET(struct open_esync_request, attributes) == 16 );
 C_ASSERT( FIELD_OFFSET(struct open_esync_request, rootdir) == 20 );
@@ -2427,7 +2428,8 @@ C_ASSERT( FIELD_OFFSET(struct open_esync_request, type) == 24 );
 C_ASSERT( sizeof(struct open_esync_request) == 32 );
 C_ASSERT( FIELD_OFFSET(struct open_esync_reply, handle) == 8 );
 C_ASSERT( FIELD_OFFSET(struct open_esync_reply, type) == 12 );
-C_ASSERT( sizeof(struct open_esync_reply) == 16 );
+C_ASSERT( FIELD_OFFSET(struct open_esync_reply, shm_idx) == 16 );
+C_ASSERT( sizeof(struct open_esync_reply) == 24 );
 C_ASSERT( FIELD_OFFSET(struct get_esync_fd_request, handle) == 12 );
 C_ASSERT( sizeof(struct get_esync_fd_request) == 16 );
 C_ASSERT( FIELD_OFFSET(struct get_esync_fd_reply, type) == 8 );
diff --git a/server/trace.c b/server/trace.c
index 3554d408fb..c24948cf8a 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -4554,6 +4554,7 @@ static void dump_create_esync_reply( const struct create_esync_reply *req )
 {
     fprintf( stderr, " handle=%04x", req->handle );
     fprintf( stderr, ", type=%d", req->type );
+    fprintf( stderr, ", shm_idx=%08x", req->shm_idx );
 }
 
 static void dump_open_esync_request( const struct open_esync_request *req )
@@ -4569,6 +4570,7 @@ static void dump_open_esync_reply( const struct open_esync_reply *req )
 {
     fprintf( stderr, " handle=%04x", req->handle );
     fprintf( stderr, ", type=%d", req->type );
+    fprintf( stderr, ", shm_idx=%08x", req->shm_idx );
 }
 
 static void dump_get_esync_fd_request( const struct get_esync_fd_request *req )
-- 
2.20.1


From 430fe0be4f4104672e2104e6032906a0d046d3e8 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 11 Jun 2018 13:10:36 -0500
Subject: [PATCH 42/83] ntdll: Use shared memory segments to store semaphore
 and mutex state.

This patch is pretty big, because it restructures the underlying esync
objects. Instead of wrapping a struct esync, the semaphore and mutex structs
are now contained within it, as a pointer to shared memory. This also means
that we can move a lot of common code to create_esync() and open_esync()
since now we don't have to allocate separate structures.
---
 dlls/ntdll/esync.c  | 349 +++++++++++++++++++-------------------------
 dlls/ntdll/esync.h  |   1 +
 dlls/ntdll/thread.c |   4 +
 3 files changed, 155 insertions(+), 199 deletions(-)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 6409678e55..6a54405488 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -31,6 +31,7 @@
 #endif
 #include <stdarg.h>
 #include <stdlib.h>
+#include <stdio.h>
 #ifdef HAVE_SYS_EVENTFD_H
 # include <sys/eventfd.h>
 #endif
@@ -83,27 +84,75 @@ struct esync
 {
     enum esync_type type;   /* defined in protocol.def */
     int fd;
+    void *shm;              /* pointer to shm section */
 };
 
 struct semaphore
 {
-    struct esync obj;
     int max;
     int count;
 };
 
-struct event
-{
-    struct esync obj;
-};
-
 struct mutex
 {
-    struct esync obj;
     DWORD tid;
     int count;    /* recursion count */
 };
 
+static char shm_name[29];
+static int shm_fd;
+static void **shm_addrs;
+static int shm_addrs_size;  /* length of the allocated shm_addrs array */
+static long pagesize;
+
+void esync_init(void)
+{
+    struct stat st;
+
+    if (stat( wine_get_config_dir(), &st ) == -1)
+        ERR("Cannot stat %s\n", wine_get_config_dir());
+
+    if (st.st_ino != (unsigned long)st.st_ino)
+        sprintf( shm_name, "/wine-%lx%08lx-esync", (unsigned long)((unsigned long long)st.st_ino >> 32), (unsigned long)st.st_ino );
+    else
+        sprintf( shm_name, "/wine-%lx-esync", (unsigned long)st.st_ino );
+
+    if ((shm_fd = shm_open( shm_name, O_RDWR, 0644 )) == -1)
+        ERR("Failed to initialize shared memory: %s\n", strerror( errno ));
+
+    pagesize = sysconf( _SC_PAGESIZE );
+
+    shm_addrs = RtlAllocateHeap( GetProcessHeap(), HEAP_ZERO_MEMORY, 128 * sizeof(shm_addrs[0]) );
+    shm_addrs_size = 128;
+}
+
+static void *get_shm( unsigned int idx )
+{
+    int entry  = (idx * 8) / pagesize;
+    int offset = (idx * 8) % pagesize;
+
+    if (entry >= shm_addrs_size)
+    {
+        shm_addrs_size *= 2;
+        if (!(shm_addrs = RtlReAllocateHeap( GetProcessHeap(), HEAP_ZERO_MEMORY, shm_addrs, shm_addrs_size )))
+            ERR("Failed to grow shm_addrs array to size %d.\n", shm_addrs_size);
+    }
+
+    if (!shm_addrs[entry])
+    {
+        void *addr = mmap( NULL, pagesize, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, entry * pagesize );
+        if (addr == (void *)-1)
+            ERR("Failed to map page %d (offset %#lx).\n", entry, entry * pagesize);
+
+        TRACE("Mapping page %d at %p.\n", entry, addr);
+
+        if (interlocked_cmpxchg_ptr( &shm_addrs[entry], addr, 0 ))
+            munmap( addr, pagesize ); /* someone beat us to it */
+    }
+
+    return (void *)((unsigned long)shm_addrs[entry] + offset);
+}
+
 /* We'd like lookup to be fast. To that end, we use a static list indexed by handle.
  * This is copied and adapted from the fd cache code. */
 
@@ -205,49 +254,13 @@ static NTSTATUS get_waitable_object( HANDLE handle, struct esync **obj )
 
     TRACE("Got fd %d for handle %p.\n", fd, handle);
 
-    switch (type)
-    {
-    case ESYNC_SEMAPHORE:
-    {
-        struct semaphore *semaphore = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*semaphore) );
-        semaphore->obj.type = ESYNC_SEMAPHORE;
-        semaphore->obj.fd = fd;
-
-        FIXME("Attempt to duplicate a semaphore; this will not work.\n");
-        semaphore->max = 0xdeadbeef;
-        semaphore->count = 0;
-        esync = &semaphore->obj;
-        break;
-    }
-    case ESYNC_AUTO_EVENT:
-    case ESYNC_MANUAL_EVENT:
-    {
-        struct event *event = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*event) );
-        event->obj.type = type;
-        event->obj.fd = fd;
-        esync = &event->obj;
-        break;
-    }
-    case ESYNC_MUTEX:
-    {
-        struct mutex *mutex = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*mutex) );
-        mutex->obj.type = type;
-        mutex->obj.fd = fd;
+    esync = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*esync) );
+    esync->fd = fd;
+    esync->type = type;
 
-        FIXME("Attempt to duplicate a mutex; this will not work.\n");
-        mutex->tid = 0;
-        mutex->count = 0;
-        esync = &mutex->obj;
-        break;
-    }
-    case ESYNC_AUTO_SERVER:
-    case ESYNC_MANUAL_SERVER:
-    case ESYNC_QUEUE:
-        esync = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*esync) );
-        esync->fd = fd;
-        esync->type = type;
-        break;
-    }
+    if (type == ESYNC_SEMAPHORE || type == ESYNC_MUTEX)
+        FIXME("Attempt to duplicate a semaphore or mutex; this will not work.\n");
+    esync->shm = NULL;
 
     add_to_list( handle, esync );
 
@@ -275,16 +288,16 @@ NTSTATUS esync_close( HANDLE handle )
     return STATUS_INVALID_HANDLE;
 }
 
-/* type is an in-out parameter; if the object already existed it returns the
- * actual type. */
-static NTSTATUS create_esync(enum esync_type *type, int *fd, HANDLE *handle,
-    ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr, int initval, int flags)
+static NTSTATUS create_esync( enum esync_type type, HANDLE *handle,
+    ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr, int initval, int flags )
 {
     NTSTATUS ret;
     data_size_t len;
     struct object_attributes *objattr;
     obj_handle_t fd_handle;
+    unsigned int shm_idx;
     sigset_t sigset;
+    int fd;
 
     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
 
@@ -296,32 +309,47 @@ static NTSTATUS create_esync(enum esync_type *type, int *fd, HANDLE *handle,
         req->access  = access;
         req->initval = initval;
         req->flags   = flags;
-        req->type    = *type;
+        req->type    = type;
         wine_server_add_data( req, objattr, len );
         ret = wine_server_call( req );
         if (!ret || ret == STATUS_OBJECT_NAME_EXISTS)
         {
             *handle = wine_server_ptr_handle( reply->handle );
-            *type = reply->type;
-            *fd = receive_fd( &fd_handle );
+            type = reply->type;
+            shm_idx = reply->shm_idx;
+            fd = receive_fd( &fd_handle );
             assert( wine_server_ptr_handle(fd_handle) == *handle );
         }
     }
     SERVER_END_REQ;
     server_leave_uninterrupted_section( &fd_cache_section, &sigset );
 
-    TRACE("-> handle %p, fd %d.\n", *handle, *fd);
+    if (!ret || ret == STATUS_OBJECT_NAME_EXISTS)
+    {
+        struct esync *obj = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*obj) );
+        if (!obj) return STATUS_NO_MEMORY;
+
+        obj->type = type;
+        obj->fd = fd;
+        obj->shm = shm_idx ? get_shm( shm_idx ) : 0;
+
+        add_to_list( *handle, obj );
+
+        TRACE("-> handle %p, fd %d, shm index %d.\n", *handle, fd, shm_idx);
+    }
 
     RtlFreeHeap( GetProcessHeap(), 0, objattr );
     return ret;
 }
 
-static NTSTATUS open_esync( enum esync_type *type, int *fd, HANDLE *handle,
+static NTSTATUS open_esync( enum esync_type type, HANDLE *handle,
     ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
 {
     NTSTATUS ret;
     obj_handle_t fd_handle;
+    unsigned int shm_idx;
     sigset_t sigset;
+    int fd;
 
     server_enter_uninterrupted_section( &fd_cache_section, &sigset );
     SERVER_START_REQ( open_esync )
@@ -329,48 +357,55 @@ static NTSTATUS open_esync( enum esync_type *type, int *fd, HANDLE *handle,
         req->access     = access;
         req->attributes = attr->Attributes;
         req->rootdir    = wine_server_obj_handle( attr->RootDirectory );
-        req->type       = *type;
+        req->type       = type;
         if (attr->ObjectName)
             wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
         if (!(ret = wine_server_call( req )))
         {
             *handle = wine_server_ptr_handle( reply->handle );
-            *type = reply->type;
-            *fd = receive_fd( &fd_handle );
+            type = reply->type;
+            shm_idx = reply->shm_idx;
+            fd = receive_fd( &fd_handle );
             assert( wine_server_ptr_handle(fd_handle) == *handle );
         }
     }
     SERVER_END_REQ;
     server_leave_uninterrupted_section( &fd_cache_section, &sigset );
 
-    TRACE("-> handle %p, fd %d.\n", *handle, *fd);
+    if (!ret)
+    {
+        struct esync *obj = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*obj) );
+        if (!obj) return STATUS_NO_MEMORY;
+
+        obj->type = type;
+        obj->fd = fd;
+        obj->shm = shm_idx ? get_shm( shm_idx ) : 0;
+
+        add_to_list( *handle, obj );
+
+        TRACE("-> handle %p, fd %d.\n", *handle, fd);
+    }
     return ret;
 }
 
 NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, LONG initial, LONG max)
 {
-    enum esync_type type = ESYNC_SEMAPHORE;
-    struct semaphore *semaphore;
     NTSTATUS ret;
-    int fd = -1;
 
     TRACE("name %s, initial %d, max %d.\n",
         attr ? debugstr_us(attr->ObjectName) : "<no name>", initial, max);
 
-    ret = create_esync( &type, &fd, handle, access, attr, initial, EFD_SEMAPHORE );
-    if (!ret || ret == STATUS_OBJECT_NAME_EXISTS)
+    ret = create_esync( ESYNC_SEMAPHORE, handle, access, attr, initial, EFD_SEMAPHORE );
+    if (!ret)
     {
-        semaphore = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*semaphore) );
-        if (!semaphore)
-            return STATUS_NO_MEMORY;
-
-        semaphore->obj.type = ESYNC_SEMAPHORE;
-        semaphore->obj.fd = fd;
+        /* Initialize the shared memory portion.
+         * Note we store max here (even though we don't need to) just to keep
+         * it the same size as the mutex's shm portion. */
+        struct esync *obj = esync_get_object( *handle );
+        struct semaphore *semaphore = obj->shm;
         semaphore->max = max;
         semaphore->count = initial;
-
-        add_to_list( *handle, &semaphore->obj );
     }
 
     return ret;
@@ -379,45 +414,23 @@ NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
 NTSTATUS esync_open_semaphore( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr )
 {
-    enum esync_type type = ESYNC_SEMAPHORE;
-    struct semaphore *semaphore;
-    NTSTATUS ret;
-    int fd = -1;
-
     TRACE("name %s.\n", debugstr_us(attr->ObjectName));
 
-    ret = open_esync( &type, &fd, handle, access, attr );
-    if (!ret)
-    {
-        semaphore = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*semaphore) );
-        if (!semaphore)
-            return STATUS_NO_MEMORY;
-
-        semaphore->obj.type = ESYNC_SEMAPHORE;
-        semaphore->obj.fd = fd;
-
-        FIXME("Attempt to open a semaphore, this will not work.\n");
-        semaphore->count = 0;
-        semaphore->max = 0xdeadbeef;
-
-        add_to_list( *handle, &semaphore->obj );
-    }
-
-    return ret;
+    return open_esync( ESYNC_SEMAPHORE, handle, access, attr );
 }
 
 NTSTATUS esync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev )
 {
-    struct semaphore *semaphore = esync_get_object( handle );
+    struct esync *obj = esync_get_object( handle );
+    struct semaphore *semaphore;
     uint64_t count64 = count;
     ULONG current;
 
     TRACE("%p, %d, %p.\n", handle, count, prev);
 
-    if (!semaphore) return STATUS_INVALID_HANDLE;
+    if (!obj) return STATUS_INVALID_HANDLE;
+    semaphore = obj->shm;
 
-    /* FIXME: This won't work across processes. In that case it may be best to
-     * use shared memory. */
     do
     {
         current = semaphore->count;
@@ -432,7 +445,7 @@ NTSTATUS esync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev )
      * write(). The fact that we were able to increase the count means that we
      * have permission to actually write that many releases to the semaphore. */
 
-    if (write( semaphore->obj.fd, &count64, sizeof(count64) ) == -1)
+    if (write( obj->fd, &count64, sizeof(count64) ) == -1)
         return FILE_GetNtStatus();
 
     return STATUS_SUCCESS;
@@ -442,66 +455,32 @@ NTSTATUS esync_create_event( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, EVENT_TYPE event_type, BOOLEAN initial )
 {
     enum esync_type type = (event_type == SynchronizationEvent ? ESYNC_AUTO_EVENT : ESYNC_MANUAL_EVENT);
-    struct event *event;
-    NTSTATUS ret;
-    int fd;
 
     TRACE("name %s, %s-reset, initial %d.\n",
         attr ? debugstr_us(attr->ObjectName) : "<no name>",
         event_type == NotificationEvent ? "manual" : "auto", initial);
 
-    ret = create_esync( &type, &fd, handle, access, attr, initial, 0 );
-    if (!ret || ret == STATUS_OBJECT_NAME_EXISTS)
-    {
-        event = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*event) );
-        if (!event)
-            return STATUS_NO_MEMORY;
-
-        event->obj.type = type; /* note that the server might give us the real type */
-        event->obj.fd = fd;
-
-        add_to_list( *handle, &event->obj);
-    }
-
-    return ret;
+    return create_esync( type, handle, access, attr, initial, 0 );
 }
 
 NTSTATUS esync_open_event( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr )
 {
-    enum esync_type type = ESYNC_AUTO_EVENT;
-    struct event *event;
-    NTSTATUS ret;
-    int fd;
-
     TRACE("name %s.\n", debugstr_us(attr->ObjectName));
 
-    ret = open_esync( &type, &fd, handle, access, attr );
-    if (!ret)
-    {
-        event = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*event) );
-        if (!event)
-            return STATUS_NO_MEMORY;
-
-        event->obj.type = type;
-        event->obj.fd = fd;
-
-        add_to_list( *handle, &event->obj );
-    }
-
-    return ret;
+    return open_esync( ESYNC_AUTO_EVENT, handle, access, attr ); /* doesn't matter which */
 }
 
 NTSTATUS esync_set_event( HANDLE handle )
 {
-    struct event *event = esync_get_object( handle );
+    struct esync *obj = esync_get_object( handle );
     static const uint64_t value = 1;
 
     TRACE("%p.\n", handle);
 
-    if (!event) return STATUS_INVALID_HANDLE;
+    if (!obj) return STATUS_INVALID_HANDLE;
 
-    if (write( event->obj.fd, &value, sizeof(value) ) == -1)
+    if (write( obj->fd, &value, sizeof(value) ) == -1)
         return FILE_GetNtStatus();
 
     return STATUS_SUCCESS;
@@ -509,34 +488,34 @@ NTSTATUS esync_set_event( HANDLE handle )
 
 NTSTATUS esync_reset_event( HANDLE handle )
 {
-    struct event *event = esync_get_object( handle );
+    struct esync *obj = esync_get_object( handle );
     static uint64_t value;
 
     TRACE("%p.\n", handle);
 
-    if (!event) return STATUS_INVALID_HANDLE;
+    if (!obj) return STATUS_INVALID_HANDLE;
 
     /* we don't care about the return value */
-    read( event->obj.fd, &value, sizeof(value) );
+    read( obj->fd, &value, sizeof(value) );
 
     return STATUS_SUCCESS;
 }
 
 NTSTATUS esync_pulse_event( HANDLE handle )
 {
-    struct event *event = esync_get_object( handle );
+    struct esync *obj = esync_get_object( handle );
     static uint64_t value = 1;
 
     TRACE("%p.\n", handle);
 
-    if (!event) return STATUS_INVALID_HANDLE;
+    if (!obj) return STATUS_INVALID_HANDLE;
 
     /* This isn't really correct; an application could miss the write.
      * Unfortunately we can't really do much better. Fortunately this is rarely
      * used (and publicly deprecated). */
-    if (write( event->obj.fd, &value, sizeof(value) ) == -1)
+    if (write( obj->fd, &value, sizeof(value) ) == -1)
         return FILE_GetNtStatus();
-    read( event->obj.fd, &value, sizeof(value) );
+    read( obj->fd, &value, sizeof(value) );
 
     return STATUS_SUCCESS;
 }
@@ -544,31 +523,19 @@ NTSTATUS esync_pulse_event( HANDLE handle )
 NTSTATUS esync_create_mutex( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, BOOLEAN initial )
 {
-    enum esync_type type = ESYNC_MUTEX;
-    struct mutex *mutex;
     NTSTATUS ret;
-    int fd;
 
     TRACE("name %s, initial %d.\n",
         attr ? debugstr_us(attr->ObjectName) : "<no name>", initial);
 
-    ret = create_esync( &type, &fd, handle, access, attr, initial ? 0 : 1, 0 );
-    if (!ret || ret == STATUS_OBJECT_NAME_EXISTS)
+    ret = create_esync( ESYNC_MUTEX, handle, access, attr, initial ? 0 : 1, 0 );
+    if (!ret)
     {
-        mutex = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*mutex) );
-        if (!mutex)
-            return STATUS_NO_MEMORY;
-
-        /* can't take ownership of the mutex if we didn't create it */
-        if (ret == STATUS_OBJECT_NAME_EXISTS)
-            initial = FALSE;
-
-        mutex->obj.type = ESYNC_MUTEX;
-        mutex->obj.fd = fd;
+        /* Initialize the shared memory portion. */
+        struct esync *obj = esync_get_object( *handle );
+        struct mutex *mutex = obj->shm;
         mutex->tid = initial ? GetCurrentThreadId() : 0;
         mutex->count = initial ? 1 : 0;
-
-        add_to_list( *handle, &mutex->obj);
     }
 
     return ret;
@@ -577,41 +544,21 @@ NTSTATUS esync_create_mutex( HANDLE *handle, ACCESS_MASK access,
 NTSTATUS esync_open_mutex( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr )
 {
-    enum esync_type type = ESYNC_MUTEX;
-    struct mutex *mutex;
-    NTSTATUS ret;
-    int fd;
-
     TRACE("name %s.\n", debugstr_us(attr->ObjectName));
 
-    ret = open_esync( &type, &fd, handle, access, attr );
-    if (!ret)
-    {
-        mutex = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*mutex) );
-        if (!mutex)
-            return STATUS_NO_MEMORY;
-
-        mutex->obj.type = ESYNC_MUTEX;
-        mutex->obj.fd = fd;
-
-        FIXME("Attempt to open a mutex; this will not work.\n");
-        mutex->tid = 0;
-        mutex->count = 0;
-
-        add_to_list( *handle, &mutex->obj );
-    }
-
-    return ret;
+    return open_esync( ESYNC_MUTEX, handle, access, attr );
 }
 
 NTSTATUS esync_release_mutex( HANDLE *handle, LONG *prev )
 {
-    struct mutex *mutex = esync_get_object( handle );
+    struct esync *obj = esync_get_object( handle );
+    struct mutex *mutex;
     static const uint64_t value = 1;
 
     TRACE("%p, %p.\n", handle, prev);
 
-    if (!mutex) return STATUS_INVALID_HANDLE;
+    if (!obj) return STATUS_INVALID_HANDLE;
+    mutex = obj->shm;
 
     /* This is thread-safe, because the only thread that can change the tid to
      * or from our tid is ours. */
@@ -628,7 +575,7 @@ NTSTATUS esync_release_mutex( HANDLE *handle, LONG *prev )
          * theirs. */
         mutex->tid = 0;
 
-        if (write( mutex->obj.fd, &value, sizeof(value) ) == -1)
+        if (write( obj->fd, &value, sizeof(value) ) == -1)
             return FILE_GetNtStatus();
     }
 
@@ -770,7 +717,7 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
                 /* Note: This violates the assumption that the *first* object
                  * to be signaled will be returned. If that becomes a problem,
                  * we can always check the state of each object before waiting. */
-                struct mutex *mutex = (struct mutex *)obj;
+                struct mutex *mutex = obj->shm;
 
                 if (mutex->tid == GetCurrentThreadId())
                 {
@@ -825,13 +772,17 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
                                 TRACE("Woken up by handle %p [%d].\n", handles[i], i);
                                 if (obj->type == ESYNC_MUTEX)
                                 {
-                                    struct mutex *mutex = (struct mutex *)obj;
+                                    struct mutex *mutex = obj->shm;
+                                    /* We don't have to worry about a race between this and read();
+                                     * the fact that we grabbed it means the count is now zero,
+                                     * so nobody else can (and the only thread that can release
+                                     * it is us). */
                                     mutex->tid = GetCurrentThreadId();
                                     mutex->count = 1;
                                 }
                                 else if (obj->type == ESYNC_SEMAPHORE)
                                 {
-                                    struct semaphore *semaphore = (struct semaphore *)obj;
+                                    struct semaphore *semaphore = obj->shm;
                                     /* We don't have to worry about a race between this and read();
                                      * the fact that we were able to grab it at all means the count
                                      * is nonzero, and if someone else grabbed it then the count
@@ -895,7 +846,7 @@ tryagain:
                 if (obj && obj->type == ESYNC_MUTEX)
                 {
                     /* It might be ours. */
-                    struct mutex *mutex = (struct mutex *)obj;
+                    struct mutex *mutex = obj->shm;
 
                     if (mutex->tid == GetCurrentThreadId())
                         continue;
@@ -948,7 +899,7 @@ tryagain:
                     {
                     case ESYNC_MUTEX:
                     {
-                        struct mutex *mutex = (struct mutex *)obj;
+                        struct mutex *mutex = obj->shm;
                         if (mutex->tid == GetCurrentThreadId())
                             break;
                         /* otherwise fall through */
@@ -982,13 +933,13 @@ tryagain:
                 {
                     if (objs[i]->type == ESYNC_MUTEX)
                     {
-                        struct mutex *mutex = (struct mutex *)objs[i];
+                        struct mutex *mutex = objs[i]->shm;
                         mutex->tid = GetCurrentThreadId();
                         mutex->count++;
                     }
                     else if (objs[i]->type == ESYNC_SEMAPHORE)
                     {
-                        struct semaphore *semaphore = (struct semaphore *)objs[i];
+                        struct semaphore *semaphore = objs[i]->shm;
                         interlocked_xchg_add( &semaphore->count, -1 );
                     }
                 }
diff --git a/dlls/ntdll/esync.h b/dlls/ntdll/esync.h
index ba9e9ec4ac..0a784b0e79 100644
--- a/dlls/ntdll/esync.h
+++ b/dlls/ntdll/esync.h
@@ -19,6 +19,7 @@
  */
 
 extern int do_esync(void) DECLSPEC_HIDDEN;
+extern void esync_init(void) DECLSPEC_HIDDEN;
 extern NTSTATUS esync_close( HANDLE handle ) DECLSPEC_HIDDEN;
 
 extern NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
diff --git a/dlls/ntdll/thread.c b/dlls/ntdll/thread.c
index 212cd92836..99faf5076f 100644
--- a/dlls/ntdll/thread.c
+++ b/dlls/ntdll/thread.c
@@ -45,6 +45,7 @@
 #include "ntdll_misc.h"
 #include "ddk/wdm.h"
 #include "wine/exception.h"
+#include "esync.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(thread);
 
@@ -265,6 +266,9 @@ void thread_init(void)
 
     fill_cpu_info();
 
+    if (do_esync())
+        esync_init();
+
     NtCreateKeyedEvent( &keyed_event, GENERIC_READ | GENERIC_WRITE, NULL, 0 );
 }
 
-- 
2.20.1


From 0cb367ee0a98ac190c440580a704903fcd5aaaf7 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 15 Jun 2018 17:56:40 -0500
Subject: [PATCH 43/83] ntdll: Lock creating and opening objects with volatile
 state.

Note that this also obviates using lock cmpxchg in get_shm(), but I think
it's best to leave that there; we don't really lose anything by it.
---
 dlls/ntdll/esync.c | 38 ++++++++++++++++++++++++++++++++++++--
 1 file changed, 36 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 6a54405488..69f0eb592d 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -388,6 +388,15 @@ static NTSTATUS open_esync( enum esync_type type, HANDLE *handle,
     return ret;
 }
 
+RTL_CRITICAL_SECTION shm_init_section;
+static RTL_CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &shm_init_section,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": shm_init_section") }
+};
+RTL_CRITICAL_SECTION shm_init_section = { &critsect_debug, -1, 0, 0, 0, 0 };
+
 NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, LONG initial, LONG max)
 {
@@ -396,6 +405,15 @@ NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
     TRACE("name %s, initial %d, max %d.\n",
         attr ? debugstr_us(attr->ObjectName) : "<no name>", initial, max);
 
+    /* We need this lock to protect against a potential (though unlikely) race:
+     * if a different process tries to open a named object and manages to use
+     * it between the time we get back from the server and the time we
+     * initialize the shared memory, it'll have uninitialize values for the
+     * object's state. That requires us to be REALLY slow, but we're not taking
+     * any chances. Synchronize on the CS here so that we're sure to be ready
+     * before anyone else can open the object. */
+    RtlEnterCriticalSection( &shm_init_section );
+
     ret = create_esync( ESYNC_SEMAPHORE, handle, access, attr, initial, EFD_SEMAPHORE );
     if (!ret)
     {
@@ -408,15 +426,22 @@ NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
         semaphore->count = initial;
     }
 
+    RtlLeaveCriticalSection( &shm_init_section );
+
     return ret;
 }
 
 NTSTATUS esync_open_semaphore( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr )
 {
+    NTSTATUS ret;
+
     TRACE("name %s.\n", debugstr_us(attr->ObjectName));
 
-    return open_esync( ESYNC_SEMAPHORE, handle, access, attr );
+    RtlEnterCriticalSection( &shm_init_section );
+    ret = open_esync( ESYNC_SEMAPHORE, handle, access, attr );
+    RtlLeaveCriticalSection( &shm_init_section );
+    return ret;
 }
 
 NTSTATUS esync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev )
@@ -528,6 +553,8 @@ NTSTATUS esync_create_mutex( HANDLE *handle, ACCESS_MASK access,
     TRACE("name %s, initial %d.\n",
         attr ? debugstr_us(attr->ObjectName) : "<no name>", initial);
 
+    RtlEnterCriticalSection( &shm_init_section );
+
     ret = create_esync( ESYNC_MUTEX, handle, access, attr, initial ? 0 : 1, 0 );
     if (!ret)
     {
@@ -538,15 +565,22 @@ NTSTATUS esync_create_mutex( HANDLE *handle, ACCESS_MASK access,
         mutex->count = initial ? 1 : 0;
     }
 
+    RtlLeaveCriticalSection( &shm_init_section );
+
     return ret;
 }
 
 NTSTATUS esync_open_mutex( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr )
 {
+    NTSTATUS ret;
+
     TRACE("name %s.\n", debugstr_us(attr->ObjectName));
 
-    return open_esync( ESYNC_MUTEX, handle, access, attr );
+    RtlEnterCriticalSection( &shm_init_section );
+    ret = open_esync( ESYNC_MUTEX, handle, access, attr );
+    RtlLeaveCriticalSection( &shm_init_section );
+    return ret;
 }
 
 NTSTATUS esync_release_mutex( HANDLE *handle, LONG *prev )
-- 
2.20.1


From ff722c97519ec09668e509591a3099ec75bcddae Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 13 Jun 2018 15:08:26 -0500
Subject: [PATCH 44/83] server, ntdll: Pass the shared memory index back from
 get_esync_fd.

This should let DuplicateHandle() work completely correctly for semaphores and mutexes.
---
 dlls/ntdll/esync.c             | 6 +++---
 include/wine/server_protocol.h | 4 ++--
 server/esync.c                 | 7 +++++++
 server/protocol.def            | 1 +
 server/request.h               | 1 +
 server/trace.c                 | 1 +
 6 files changed, 15 insertions(+), 5 deletions(-)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 69f0eb592d..360a980db2 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -213,6 +213,7 @@ static NTSTATUS get_waitable_object( HANDLE handle, struct esync **obj )
 {
     obj_handle_t fd_handle;
     enum esync_type type;
+    unsigned int shm_idx;
     struct esync *esync;
     sigset_t sigset;
     NTSTATUS ret;
@@ -230,6 +231,7 @@ static NTSTATUS get_waitable_object( HANDLE handle, struct esync **obj )
             if (!(ret = wine_server_call( req )))
             {
                 type = reply->type;
+                shm_idx = reply->shm_idx;
                 fd = receive_fd( &fd_handle );
                 assert( wine_server_ptr_handle(fd_handle) == handle );
             }
@@ -258,9 +260,7 @@ static NTSTATUS get_waitable_object( HANDLE handle, struct esync **obj )
     esync->fd = fd;
     esync->type = type;
 
-    if (type == ESYNC_SEMAPHORE || type == ESYNC_MUTEX)
-        FIXME("Attempt to duplicate a semaphore or mutex; this will not work.\n");
-    esync->shm = NULL;
+    esync->shm = shm_idx ? get_shm( shm_idx ) : 0;
 
     add_to_list( handle, esync );
 
diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index 9c7469093a..1b434b7c1a 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -5714,7 +5714,7 @@ struct get_esync_fd_reply
 {
     struct reply_header __header;
     int          type;
-    char __pad_12[4];
+    unsigned int shm_idx;
 };
 
 enum esync_type
@@ -6627,6 +6627,6 @@ union generic_reply
     struct get_esync_fd_reply get_esync_fd_reply;
 };
 
-#define SERVER_PROTOCOL_VERSION 572
+#define SERVER_PROTOCOL_VERSION 573
 
 #endif /* __WINE_WINE_SERVER_PROTOCOL_H */
diff --git a/server/esync.c b/server/esync.c
index f1a46afc23..6adf996872 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -362,6 +362,13 @@ DECL_HANDLER(get_esync_fd)
     {
         fd = obj->ops->get_esync_fd( obj, &type );
         reply->type = type;
+        if (obj->ops == &esync_ops)
+        {
+            struct esync *esync = (struct esync *)obj;
+            reply->shm_idx = esync->shm_idx;
+        }
+        else
+            reply->shm_idx = 0;
         send_client_fd( current->process, fd, req->handle );
     }
     else
diff --git a/server/protocol.def b/server/protocol.def
index 962ee32536..a00ebaba10 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -3895,6 +3895,7 @@ struct handle_info
     obj_handle_t handle;        /* handle to the object */
 @REPLY
     int          type;          /* esync type (defined below) */
+    unsigned int shm_idx;       /* this object's index into the shm section */
 @END
 
 enum esync_type
diff --git a/server/request.h b/server/request.h
index 271d092fcf..4d398584e9 100644
--- a/server/request.h
+++ b/server/request.h
@@ -2433,6 +2433,7 @@ C_ASSERT( sizeof(struct open_esync_reply) == 24 );
 C_ASSERT( FIELD_OFFSET(struct get_esync_fd_request, handle) == 12 );
 C_ASSERT( sizeof(struct get_esync_fd_request) == 16 );
 C_ASSERT( FIELD_OFFSET(struct get_esync_fd_reply, type) == 8 );
+C_ASSERT( FIELD_OFFSET(struct get_esync_fd_reply, shm_idx) == 12 );
 C_ASSERT( sizeof(struct get_esync_fd_reply) == 16 );
 
 #endif  /* WANT_REQUEST_HANDLERS */
diff --git a/server/trace.c b/server/trace.c
index c24948cf8a..c3e7aab8fb 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -4581,6 +4581,7 @@ static void dump_get_esync_fd_request( const struct get_esync_fd_request *req )
 static void dump_get_esync_fd_reply( const struct get_esync_fd_reply *req )
 {
     fprintf( stderr, " type=%d", req->type );
+    fprintf( stderr, ", shm_idx=%08x", req->shm_idx );
 }
 
 static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
-- 
2.20.1


From eb5ae7e6b01612ee9e32187cd5744ca821543b35 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 15 Jun 2018 14:12:22 -0500
Subject: [PATCH 45/83] server, ntdll: Implement alertable waits.

We do this quite simply by waiting on an extra eventfd descriptor, which the server signals when a user APC is queued.
---
 dlls/ntdll/esync.c             | 94 +++++++++++++++++++++++++++++-----
 dlls/ntdll/ntdll_misc.h        |  1 +
 dlls/ntdll/thread.c            |  2 +
 include/wine/server_protocol.h | 16 +++++-
 server/esync.c                 | 20 ++++++--
 server/esync.h                 |  1 +
 server/protocol.def            |  5 ++
 server/request.h               |  4 ++
 server/thread.c                | 13 +++++
 server/thread.h                |  1 +
 server/trace.c                 |  7 +++
 11 files changed, 146 insertions(+), 18 deletions(-)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 360a980db2..395c8d3366 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -665,19 +665,43 @@ static int do_poll( struct pollfd *fds, nfds_t nfds, ULONGLONG *end )
 NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
                              BOOLEAN alertable, const LARGE_INTEGER *timeout )
 {
+    static const LARGE_INTEGER zero = {0};
+
     struct esync *objs[MAXIMUM_WAIT_OBJECTS];
-    struct pollfd fds[MAXIMUM_WAIT_OBJECTS + 1];
+    struct pollfd fds[MAXIMUM_WAIT_OBJECTS + 2];
     int has_esync = 0, has_server = 0;
-    DWORD pollcount = count;
     BOOL msgwait = FALSE;
     LONGLONG timeleft;
     LARGE_INTEGER now;
+    DWORD pollcount;
     ULONGLONG end;
     int64_t value;
     ssize_t size;
     int i, j;
     int ret;
 
+    /* Grab the APC fd if we don't already have it. */
+    if (alertable && ntdll_get_thread_data()->esync_apc_fd == -1)
+    {
+        obj_handle_t fd_handle;
+        sigset_t sigset;
+        int fd = -1;
+
+        server_enter_uninterrupted_section( &fd_cache_section, &sigset );
+        SERVER_START_REQ( get_esync_apc_fd )
+        {
+            if (!(ret = wine_server_call( req )))
+            {
+                fd = receive_fd( &fd_handle );
+                assert( fd_handle == GetCurrentThreadId() );
+            }
+        }
+        SERVER_END_REQ;
+        server_leave_uninterrupted_section( &fd_cache_section, &sigset );
+
+        ntdll_get_thread_data()->esync_apc_fd = fd;
+    }
+
     NtQuerySystemTime( &now );
     if (timeout)
     {
@@ -728,6 +752,8 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
 
         if (msgwait)
             DPRINTF(" or driver events (fd %d)", ntdll_get_thread_data()->esync_queue_fd);
+        if (alertable)
+            DPRINTF(", alertable");
 
         if (!timeout)
             DPRINTF(", timeout = INFINITE.\n");
@@ -766,10 +792,17 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
         }
         if (msgwait)
         {
-            fds[count].fd = ntdll_get_thread_data()->esync_queue_fd;
-            fds[count].events = POLLIN;
-            pollcount++;
+            fds[i].fd = ntdll_get_thread_data()->esync_queue_fd;
+            fds[i].events = POLLIN;
+            i++;
+        }
+        if (alertable)
+        {
+            fds[i].fd = ntdll_get_thread_data()->esync_apc_fd;
+            fds[i].events = POLLIN;
+            i++;
         }
+        pollcount = i;
 
         while (1)
         {
@@ -829,10 +862,18 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
                     }
                 }
 
-                if (msgwait && (fds[count].revents & POLLIN))
+                if (msgwait)
+                {
+                    if (fds[i++].revents & POLLIN)
+                    {
+                        TRACE("Woken up by driver events.\n");
+                        return count - 1;
+                    }
+                }
+                if (alertable)
                 {
-                    TRACE("Woken up by driver events.\n");
-                    return count - 1;
+                    if (fds[i++].revents & POLLIN)
+                        goto userapc;
                 }
 
                 /* If we got here, someone else stole (or reset, etc.) whatever
@@ -871,6 +912,14 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
 tryagain:
             /* First step: try to poll on each object in sequence. */
             fds[0].events = POLLIN;
+            pollcount = 1;
+            if (alertable)
+            {
+                /* We also need to wait on APCs. */
+                fds[1].fd = ntdll_get_thread_data()->esync_apc_fd;
+                fds[1].events = POLLIN;
+                pollcount++;
+            }
             for (i = 0; i < count; i++)
             {
                 struct esync *obj = objs[i];
@@ -886,9 +935,11 @@ tryagain:
                         continue;
                 }
 
-                ret = do_poll( fds, 1, timeout ? &end : NULL );
+                ret = do_poll( fds, pollcount, timeout ? &end : NULL );
                 if (ret <= 0)
                     goto err;
+                else if (alertable && (fds[1].revents & POLLIN))
+                    goto userapc;
 
                 if (fds[0].revents & (POLLHUP | POLLERR | POLLNVAL))
                 {
@@ -901,9 +952,11 @@ tryagain:
             if (msgwait)
             {
                 fds[0].fd = ntdll_get_thread_data()->esync_queue_fd;
-                ret = do_poll( fds, 1, timeout ? &end : NULL );
+                ret = do_poll( fds, pollcount, timeout ? &end : NULL );
                 if (ret <= 0)
                     goto err;
+                else if (alertable && (fds[1].revents & POLLIN))
+                    goto userapc;
             }
 
             /* If we got here and we haven't timed out, that means all of the
@@ -915,10 +968,12 @@ tryagain:
             }
             if (msgwait)
             {
-                fds[count].fd = ntdll_get_thread_data()->esync_queue_fd;
-                fds[count].events = POLLIN;
-                pollcount++;
+                fds[i].fd = ntdll_get_thread_data()->esync_queue_fd;
+                fds[i].events = POLLIN;
+                i++;
             }
+            /* There's no reason to check for APCs here. */
+            pollcount = i;
 
             /* Poll everything to see if they're still signaled. */
             ret = poll( fds, pollcount, 0 );
@@ -999,6 +1054,19 @@ err:
         ERR("ppoll failed: %s\n", strerror(errno));
         return FILE_GetNtStatus();
     }
+
+userapc:
+    TRACE("Woken up by user APC.\n");
+
+    /* We have to make a server call anyway to get the APC to execute, so just
+     * delegate down to server_select(). */
+    ret = server_select( NULL, 0, SELECT_INTERRUPTIBLE | SELECT_ALERTABLE, &zero );
+
+    /* This can happen if we received a system APC, and the APC fd was woken up
+     * before we got SIGUSR1. poll() doesn't return EINTR in that case. The
+     * right thing to do seems to be to return STATUS_USER_APC anyway. */
+    if (ret == STATUS_TIMEOUT) ret = STATUS_USER_APC;
+    return ret;
 }
 
 NTSTATUS esync_signal_and_wait( HANDLE signal, HANDLE wait, BOOLEAN alertable,
diff --git a/dlls/ntdll/ntdll_misc.h b/dlls/ntdll/ntdll_misc.h
index ffe2788175..b0c1c80e47 100644
--- a/dlls/ntdll/ntdll_misc.h
+++ b/dlls/ntdll/ntdll_misc.h
@@ -239,6 +239,7 @@ struct ntdll_thread_data
     BOOL               wow64_redir;   /* Wow64 filesystem redirection flag */
     pthread_t          pthread_id;    /* pthread thread id */
     int                esync_queue_fd;/* fd to wait on for driver events */
+    int                esync_apc_fd;  /* fd to wait on for user APCs */
 };
 
 C_ASSERT( sizeof(struct ntdll_thread_data) <= sizeof(((TEB *)0)->GdiTebBatch) );
diff --git a/dlls/ntdll/thread.c b/dlls/ntdll/thread.c
index 99faf5076f..f6c3ef8783 100644
--- a/dlls/ntdll/thread.c
+++ b/dlls/ntdll/thread.c
@@ -234,6 +234,7 @@ void thread_init(void)
     thread_data->wait_fd[1] = -1;
     thread_data->debug_info = &debug_info;
     thread_data->esync_queue_fd = -1;
+    thread_data->esync_apc_fd = -1;
 
     signal_init_thread( teb );
     virtual_init_threading();
@@ -528,6 +529,7 @@ NTSTATUS WINAPI RtlCreateUserThread( HANDLE process, SECURITY_DESCRIPTOR *descr,
     thread_data->wait_fd[1]  = -1;
     thread_data->start_stack = (char *)teb->Tib.StackBase;
     thread_data->esync_queue_fd = -1;
+    thread_data->esync_apc_fd = -1;
 
     pthread_attr_init( &attr );
     pthread_attr_setstack( &attr, teb->DeallocationStack,
diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index 1b434b7c1a..a9c97f8110 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -5717,6 +5717,17 @@ struct get_esync_fd_reply
     unsigned int shm_idx;
 };
 
+
+struct get_esync_apc_fd_request
+{
+    struct request_header __header;
+    char __pad_12[4];
+};
+struct get_esync_apc_fd_reply
+{
+    struct reply_header __header;
+};
+
 enum esync_type
 {
     ESYNC_SEMAPHORE = 1,
@@ -6025,6 +6036,7 @@ enum request
     REQ_create_esync,
     REQ_open_esync,
     REQ_get_esync_fd,
+    REQ_get_esync_apc_fd,
     REQ_NB_REQUESTS
 };
 
@@ -6326,6 +6338,7 @@ union generic_request
     struct create_esync_request create_esync_request;
     struct open_esync_request open_esync_request;
     struct get_esync_fd_request get_esync_fd_request;
+    struct get_esync_apc_fd_request get_esync_apc_fd_request;
 };
 union generic_reply
 {
@@ -6625,8 +6638,9 @@ union generic_reply
     struct create_esync_reply create_esync_reply;
     struct open_esync_reply open_esync_reply;
     struct get_esync_fd_reply get_esync_fd_reply;
+    struct get_esync_apc_fd_reply get_esync_apc_fd_reply;
 };
 
-#define SERVER_PROTOCOL_VERSION 573
+#define SERVER_PROTOCOL_VERSION 574
 
 #endif /* __WINE_WINE_SERVER_PROTOCOL_H */
diff --git a/server/esync.c b/server/esync.c
index 6adf996872..8bf6e441f1 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -245,19 +245,25 @@ int esync_create_fd( int initval, int flags )
 #endif
 }
 
+/* Wake up a specific fd. */
+void esync_wake_fd( int fd )
+{
+    static const uint64_t value = 1;
+
+    if (write( fd, &value, sizeof(value) ) == -1)
+        perror( "esync: write" );
+}
+
 /* Wake up a server-side esync object. */
 void esync_wake_up( struct object *obj )
 {
-    static const uint64_t value = 1;
     enum esync_type dummy;
     int fd;
 
     if (obj->ops->get_esync_fd)
     {
         fd = obj->ops->get_esync_fd( obj, &dummy );
-
-        if (write( fd, &value, sizeof(value) ) == -1)
-            perror( "esync: write" );
+        esync_wake_fd( fd );
     }
 }
 
@@ -383,3 +389,9 @@ DECL_HANDLER(get_esync_fd)
 
     release_object( obj );
 }
+
+/* Return the fd used for waiting on user APCs. */
+DECL_HANDLER(get_esync_apc_fd)
+{
+    send_client_fd( current->process, current->esync_apc_fd, current->id );
+}
diff --git a/server/esync.h b/server/esync.h
index aeb58c5469..cea025d930 100644
--- a/server/esync.h
+++ b/server/esync.h
@@ -21,6 +21,7 @@
 extern int do_esync(void);
 void esync_init(void);
 int esync_create_fd( int initval, int flags );
+void esync_wake_fd( int fd );
 void esync_wake_up( struct object *obj );
 void esync_clear( int fd );
 
diff --git a/server/protocol.def b/server/protocol.def
index a00ebaba10..721df0bd19 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -3898,6 +3898,11 @@ struct handle_info
     unsigned int shm_idx;       /* this object's index into the shm section */
 @END
 
+/* Retrieve the fd to wait on for user APCs. */
+@REQ(get_esync_apc_fd)
+@REPLY
+@END
+
 enum esync_type
 {
     ESYNC_SEMAPHORE = 1,
diff --git a/server/request.h b/server/request.h
index 4d398584e9..b3c31367d2 100644
--- a/server/request.h
+++ b/server/request.h
@@ -406,6 +406,7 @@ DECL_HANDLER(terminate_job);
 DECL_HANDLER(create_esync);
 DECL_HANDLER(open_esync);
 DECL_HANDLER(get_esync_fd);
+DECL_HANDLER(get_esync_apc_fd);
 
 #ifdef WANT_REQUEST_HANDLERS
 
@@ -706,6 +707,7 @@ static const req_handler req_handlers[REQ_NB_REQUESTS] =
     (req_handler)req_create_esync,
     (req_handler)req_open_esync,
     (req_handler)req_get_esync_fd,
+    (req_handler)req_get_esync_apc_fd,
 };
 
 C_ASSERT( sizeof(affinity_t) == 8 );
@@ -2435,6 +2437,8 @@ C_ASSERT( sizeof(struct get_esync_fd_request) == 16 );
 C_ASSERT( FIELD_OFFSET(struct get_esync_fd_reply, type) == 8 );
 C_ASSERT( FIELD_OFFSET(struct get_esync_fd_reply, shm_idx) == 12 );
 C_ASSERT( sizeof(struct get_esync_fd_reply) == 16 );
+C_ASSERT( sizeof(struct get_esync_apc_fd_request) == 16 );
+C_ASSERT( sizeof(struct get_esync_apc_fd_reply) == 8 );
 
 #endif  /* WANT_REQUEST_HANDLERS */
 
diff --git a/server/thread.c b/server/thread.c
index 56bef76c5f..f04fb3e772 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -204,6 +204,7 @@ static inline void init_thread_structure( struct thread *thread )
     thread->desktop_users   = 0;
     thread->token           = NULL;
     thread->esync_fd        = -1;
+    thread->esync_apc_fd    = -1;
 
     thread->creation_time = current_time;
     thread->exit_time     = 0;
@@ -289,7 +290,10 @@ struct thread *create_thread( int fd, struct process *process, const struct secu
     }
 
     if (do_esync())
+    {
         thread->esync_fd = esync_create_fd( 0, 0 );
+        thread->esync_apc_fd = esync_create_fd( 0, 0 );
+    }
 
     set_fd_events( thread->request_fd, POLLIN );  /* start listening to events */
     add_process_thread( thread->process, thread );
@@ -1022,8 +1026,13 @@ static int queue_apc( struct process *process, struct thread *thread, struct thr
     grab_object( apc );
     list_add_tail( queue, &apc->entry );
     if (!list_prev( queue, &apc->entry ))  /* first one */
+    {
         wake_thread( thread );
 
+        if (do_esync())
+            esync_wake_fd( thread->esync_apc_fd );
+    }
+
     return 1;
 }
 
@@ -1070,6 +1079,10 @@ static struct thread_apc *thread_dequeue_apc( struct thread *thread, int system_
         apc = LIST_ENTRY( ptr, struct thread_apc, entry );
         list_remove( ptr );
     }
+
+    if (do_esync() && list_empty( &thread->system_apc ) && list_empty( &thread->user_apc ))
+        esync_clear( thread->esync_apc_fd );
+
     return apc;
 }
 
diff --git a/server/thread.h b/server/thread.h
index fc3ca4b701..773d67c714 100644
--- a/server/thread.h
+++ b/server/thread.h
@@ -90,6 +90,7 @@ struct thread
     timeout_t              exit_time;     /* Thread exit time */
     struct token          *token;         /* security token associated with this thread */
     int                    esync_fd;      /* esync file descriptor (signalled on exit) */
+    int                    esync_apc_fd;  /* esync apc fd (signalled when APCs are present) */
 };
 
 struct thread_snapshot
diff --git a/server/trace.c b/server/trace.c
index c3e7aab8fb..c06ae1a674 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -4584,6 +4584,10 @@ static void dump_get_esync_fd_reply( const struct get_esync_fd_reply *req )
     fprintf( stderr, ", shm_idx=%08x", req->shm_idx );
 }
 
+static void dump_get_esync_apc_fd_request( const struct get_esync_apc_fd_request *req )
+{
+}
+
 static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_new_process_request,
     (dump_func)dump_exec_process_request,
@@ -4879,6 +4883,7 @@ static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_create_esync_request,
     (dump_func)dump_open_esync_request,
     (dump_func)dump_get_esync_fd_request,
+    (dump_func)dump_get_esync_apc_fd_request,
 };
 
 static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {
@@ -5176,6 +5181,7 @@ static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_create_esync_reply,
     (dump_func)dump_open_esync_reply,
     (dump_func)dump_get_esync_fd_reply,
+    NULL,
 };
 
 static const char * const req_names[REQ_NB_REQUESTS] = {
@@ -5473,6 +5479,7 @@ static const char * const req_names[REQ_NB_REQUESTS] = {
     "create_esync",
     "open_esync",
     "get_esync_fd",
+    "get_esync_apc_fd",
 };
 
 static const struct
-- 
2.20.1


From 35793fd5f9dc2cfafe9d3250b7ba97f0b5ecfbad Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 10 Jun 2018 13:53:08 -0500
Subject: [PATCH 46/83] esync: Update README.

---
 README.esync | 48 +++++++++++++++++-------------------------------
 1 file changed, 17 insertions(+), 31 deletions(-)

diff --git a/README.esync b/README.esync
index 8fcb969011..627cc3f481 100644
--- a/README.esync
+++ b/README.esync
@@ -88,32 +88,23 @@ also kind of ugly basically because we have to wait on both X11's fd and the
 messages. The upshot about the whole thing was that races are basically
 impossible, since a thread can only wait on its own queue.
 
-I had kind of figured that APCs just wouldn't work, but then poll() spat EINTR
-at me and I realized that this wasn't necessarily true. It seems that the
-server will suspend a thread when trying to deliver a system APC to a thread
-that's not waiting, and since the server has no idea that we're waiting it
-just suspends us. This of course interrupts poll(), which complains at us, and
-it turns out that just returning STATUS_USER_APC in that case is enough to
-make rpcrt4 happy.
+System APCs already work, since the server will forcibly suspend a thread if
+it's not already waiting, and so we just need to check for EINTR from
+poll(). User APCs and alertable waits are implemented in a similar style to
+message queues (well, sort of): whenever someone executes an alertable wait,
+we add an additional eventfd to the list, which the server signals when an APC
+arrives. If that eventfd gets signaled, we hand it off to the server to take
+care of, and return STATUS_USER_APC.
+
+Originally I kept the volatile state of semaphores and mutexes inside a
+variable local to the handle, with the knowledge that this would break if
+someone tried to open the handle elsewhere or duplicate it. It did, and so now
+this state is stored inside shared memory. This is of the POSIX variety, is
+allocated by the server (but never mapped there) and lives under the path
+"/wine-esync".
 
 There are a couple things that this infrastructure can't handle, although
 surprisingly there aren't that many. In particular:
-* We can't return the previous count on a semaphore, since we have no way to
-  query the count on a semaphore through eventfd. Currently the code lies and
-  returns 1 every time. We can make this work (in a single process, or [if
-  necessary] in multiple processes through shared memory) by keeping a count
-  locally. We can't guarantee that it's the exact count at the moment the
-  semaphore was released, but I guess any program that runs into that race
-  shouldn't be depending on that fact anyway.
-* Similarly, we can't enforce the maximum count on a semaphore, since we have
-  no way to get the current count and subsequently compare it with the
-  maximum.
-* We can't use NtQueryMutant to get the mutant's owner or count if it lives in
-  a different process. If necessary we can use shared memory to make this
-  work, I guess, but see below.
-* User APCs don't work. However, it's not impossible to make them work; in
-  particular I think this could be relatively easily implemented by waiting on
-  another internal file descriptor when we execute an alertable wait.
 * Implementing wait-all, i.e. WaitForMultipleObjects(..., TRUE, ...), is not
   exactly possible the way we'd like it to be possible. In theory that
   function should wait until it knows all objects are available, then grab
@@ -144,18 +135,13 @@ surprisingly there aren't that many. In particular:
 
 There are some things that are perfectly implementable but that I just haven't
 done yet:
-* NtOpen* (aka Open*). This is just a matter of adding another open_esync
-  request analogous to those for other server primitives.
-* NtQuery*. This can be done to some degree (the difficulties are outlined
-  above). That said, these APIs aren't exposed through kernel32 in any way, so
+* NtQuery*. That said, these APIs aren't exposed through kernel32 in any way, so
   I doubt anyone is going to be using them.
-* SignalObjectAndWait(). The server combines this into a single operation, but
-  according to MSDN it doesn't need to be atomic, so we can just signal the
-  appropriate object and wait, and woe betide anyone who gets in the way of
-  those two operations.
 * Other synchronizable server primitives. It's unlikely we'll need any of
   these, except perhaps named pipes (which would honestly be rather difficult)
   and (maybe) timers.
+* Access masks. We'd need to store these inside ntdll, and validate them when
+  someone tries to execute esync operations.
 
 This patchset was inspired by Daniel Santos' "hybrid synchronization"
 patchset. My idea was to create a framework whereby even contended waits could
-- 
2.20.1


From bde443a404a999db34a5c13b09805e7d98662633 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 13 Jun 2018 22:25:40 -0500
Subject: [PATCH 47/83] kernel32/tests: Mark some existing tests as failing
 under esync.

---
 dlls/kernel32/tests/sync.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/dlls/kernel32/tests/sync.c b/dlls/kernel32/tests/sync.c
index f7be51e972..aebb25d659 100644
--- a/dlls/kernel32/tests/sync.c
+++ b/dlls/kernel32/tests/sync.c
@@ -218,7 +218,8 @@ todo_wine
     SetLastError(0xdeadbeef);
     hOpened = OpenMutexA(GENERIC_READ | GENERIC_WRITE, FALSE, "WineTestMutex");
     ok(hOpened != NULL, "OpenMutex failed with error %d\n", GetLastError());
-    wait_ret = WaitForSingleObject(hOpened, INFINITE);
+    wait_ret = WaitForSingleObject(hOpened, 0);
+todo_wine_if(getenv("WINEESYNC"))   /* XFAIL: validation is not implemented */
     ok(wait_ret == WAIT_FAILED, "WaitForSingleObject succeeded\n");
     CloseHandle(hOpened);
 
@@ -249,6 +250,7 @@ todo_wine
 
     SetLastError(0xdeadbeef);
     ret = ReleaseMutex(hCreated);
+todo_wine_if(getenv("WINEESYNC"))   /* XFAIL: due to the above */
     ok(!ret && (GetLastError() == ERROR_NOT_OWNER),
         "ReleaseMutex should have failed with ERROR_NOT_OWNER instead of %d\n", GetLastError());
 
-- 
2.20.1


From dd1c9796a8ea30b75b4ac77feea5e6a3ebc5cabb Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 13 Jun 2018 22:40:47 -0500
Subject: [PATCH 48/83] kernel32/tests: Add some semaphore tests.

---
 dlls/kernel32/tests/sync.c | 98 +++++++++++++++++++++++++++++++++++++-
 1 file changed, 97 insertions(+), 1 deletion(-)

diff --git a/dlls/kernel32/tests/sync.c b/dlls/kernel32/tests/sync.c
index aebb25d659..354ccb89ad 100644
--- a/dlls/kernel32/tests/sync.c
+++ b/dlls/kernel32/tests/sync.c
@@ -577,7 +577,10 @@ static void test_event(void)
 
 static void test_semaphore(void)
 {
-    HANDLE handle, handle2;
+    HANDLE handle, handle2, handles[2];
+    DWORD ret;
+    LONG prev;
+    int i;
 
     /* test case sensitivity */
 
@@ -619,6 +622,99 @@ static void test_semaphore(void)
     ok( GetLastError() == ERROR_INVALID_PARAMETER, "wrong error %u\n", GetLastError());
 
     CloseHandle( handle );
+
+    handle = CreateSemaphoreA( NULL, 0, 5, NULL );
+    ok(!!handle, "CreateSemaphore failed: %u\n", GetLastError());
+
+    ret = WaitForSingleObject( handle, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %u\n", ret);
+
+    ret = ReleaseSemaphore( handle, 1, &prev );
+    ok(ret, "got error %u\n", GetLastError());
+    ok(prev == 0, "got prev %d\n", prev);
+
+    ret = ReleaseSemaphore( handle, 1, &prev );
+    ok(ret, "got error %u\n", GetLastError());
+    ok(prev == 1, "got prev %d\n", prev);
+
+    ret = ReleaseSemaphore( handle, 5, &prev );
+    ok(!ret, "got %d\n", ret);
+    ok(GetLastError() == ERROR_TOO_MANY_POSTS, "got error %u\n", GetLastError());
+    ok(prev == 1, "got prev %d\n", prev);
+
+    ret = ReleaseSemaphore( handle, 2, &prev );
+    ok(ret, "got error %u\n", GetLastError());
+    ok(prev == 2, "got prev %d\n", prev);
+
+    ret = ReleaseSemaphore( handle, 1, &prev );
+    ok(ret, "got error %u\n", GetLastError());
+    ok(prev == 4, "got prev %d\n", prev);
+
+    for (i = 0; i < 5; i++)
+    {
+        ret = WaitForSingleObject( handle, 0 );
+        ok(ret == 0, "got %u\n", ret);
+    }
+
+    ret = WaitForSingleObject( handle, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %u\n", ret);
+
+    handle2 = CreateSemaphoreA( NULL, 3, 5, NULL );
+    ok(!!handle2, "CreateSemaphore failed: %u\n", GetLastError());
+
+    ret = ReleaseSemaphore( handle2, 1, &prev );
+    ok(ret, "got error %u\n", GetLastError());
+    ok(prev == 3, "got prev %d\n", prev);
+
+    for (i = 0; i < 4; i++)
+    {
+        ret = WaitForSingleObject( handle2, 0 );
+        ok(ret == 0, "got %u\n", ret);
+    }
+
+    ret = WaitForSingleObject( handle2, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %u\n", ret);
+
+    handles[0] = handle;
+    handles[1] = handle2;
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %u\n", ret);
+
+    ReleaseSemaphore( handle, 1, NULL );
+    ReleaseSemaphore( handle2, 1, NULL );
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == 0, "got %u\n", ret);
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == 1, "got %u\n", ret);
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %u\n", ret);
+
+    ReleaseSemaphore( handle, 1, NULL );
+    ReleaseSemaphore( handle2, 1, NULL );
+
+    ret = WaitForMultipleObjects( 2, handles, TRUE, 0 );
+    ok(ret == 0, "got %u\n", ret);
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %u\n", ret);
+
+    ReleaseSemaphore( handle, 1, NULL );
+
+    ret = WaitForMultipleObjects( 2, handles, TRUE, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %u\n", ret);
+
+    ret = WaitForSingleObject( handle, 0 );
+    ok(ret == 0, "got %u\n", ret);
+
+    ret = CloseHandle( handle );
+    ok(ret, "got error %u\n", ret);
+
+    ret = CloseHandle( handle2 );
+    ok(ret, "got error %u\n", ret);
 }
 
 static void test_waitable_timer(void)
-- 
2.20.1


From 97ca85935808f652dba6c1dd25f70c3153fb4d1f Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 13 Jun 2018 22:59:37 -0500
Subject: [PATCH 49/83] kernel32/tests: Add some event tests.

---
 dlls/kernel32/tests/sync.c | 119 ++++++++++++++++++++++++++++++++++++-
 1 file changed, 118 insertions(+), 1 deletion(-)

diff --git a/dlls/kernel32/tests/sync.c b/dlls/kernel32/tests/sync.c
index 354ccb89ad..e0c5354c2f 100644
--- a/dlls/kernel32/tests/sync.c
+++ b/dlls/kernel32/tests/sync.c
@@ -464,12 +464,13 @@ static void test_slist(void)
 
 static void test_event(void)
 {
-    HANDLE handle, handle2;
+    HANDLE handle, handle2, handles[2];
     SECURITY_ATTRIBUTES sa;
     SECURITY_DESCRIPTOR sd;
     ACL acl;
     DWORD ret;
     BOOL val;
+    int i;
 
     /* no sd */
     handle = CreateEventA(NULL, FALSE, FALSE, __FILE__ ": Test Event");
@@ -573,6 +574,122 @@ static void test_event(void)
     ok( ret, "QueryMemoryResourceNotification failed err %u\n", GetLastError() );
     ok( val == FALSE || val == TRUE, "wrong value %u\n", val );
     CloseHandle( handle );
+
+    handle = CreateEventA( NULL, TRUE, FALSE, NULL );
+    ok(!!handle, "got error %u\n", GetLastError());
+
+    ret = WaitForSingleObject( handle, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %u\n", ret);
+
+    ret = SetEvent( handle );
+    ok(ret, "got error %u\n", GetLastError());
+
+    ret = SetEvent( handle );
+    ok(ret, "got error %u\n", GetLastError());
+
+    for (i = 0; i < 100; i++)
+    {
+        ret = WaitForSingleObject( handle, 0 );
+        ok(ret == 0, "got %u\n", ret);
+    }
+
+    ret = ResetEvent( handle );
+    ok(ret, "got error %u\n", GetLastError());
+
+    ret = ResetEvent( handle );
+    ok(ret, "got error %u\n", GetLastError());
+
+    ret = WaitForSingleObject( handle, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %u\n", ret);
+
+    handle2 = CreateEventA( NULL, FALSE, TRUE, NULL );
+    ok(!!handle2, "got error %u\n", GetLastError());
+
+    ret = WaitForSingleObject( handle2, 0 );
+    ok(ret == 0, "got %u\n", ret);
+
+    ret = WaitForSingleObject( handle2, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %u\n", ret);
+
+    ret = SetEvent( handle2 );
+    ok(ret, "got error %u\n", GetLastError());
+
+    ret = SetEvent( handle2 );
+    ok(ret, "got error %u\n", GetLastError());
+
+    ret = ResetEvent( handle2 );
+    ok(ret, "got error %u\n", GetLastError());
+
+    ret = ResetEvent( handle2 );
+    ok(ret, "got error %u\n", GetLastError());
+
+    ret = WaitForSingleObject( handle2, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %u\n", ret);
+
+    handles[0] = handle;
+    handles[1] = handle2;
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %u\n", ret);
+
+    SetEvent( handle );
+    SetEvent( handle2 );
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == 0, "got %u\n", ret);
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == 0, "got %u\n", ret);
+
+    ret = WaitForSingleObject( handle2, 0 );
+    ok(ret == 0, "got %u\n", ret);
+
+    ResetEvent( handle );
+    SetEvent( handle2 );
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == 1, "got %u\n", ret);
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %u\n", ret);
+
+    SetEvent( handle );
+    SetEvent( handle2 );
+
+    ret = WaitForMultipleObjects( 2, handles, TRUE, 0 );
+    ok(ret == 0, "got %u\n", ret);
+
+    ret = WaitForMultipleObjects( 2, handles, TRUE, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %u\n", ret);
+
+    SetEvent( handle2 );
+    ResetEvent( handle );
+
+    ret = WaitForMultipleObjects( 2, handles, TRUE, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %u\n", ret);
+
+    ret = WaitForSingleObject( handle2, 0 );
+    ok(ret == 0, "got %u\n", ret);
+
+    handles[0] = handle2;
+    handles[1] = handle;
+    SetEvent( handle );
+    SetEvent( handle2 );
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == 0, "got %u\n", ret);
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == 1, "got %u\n", ret);
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == 1, "got %u\n", ret);
+
+    ret = CloseHandle( handle );
+    ok(ret, "got error %u\n", GetLastError());
+
+    ret = CloseHandle( handle2 );
+    ok(ret, "got error %u\n", GetLastError());
 }
 
 static void test_semaphore(void)
-- 
2.20.1


From 5c00a207a9de43dbeed4c020226bee426aebfb53 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 13 Jun 2018 23:32:04 -0500
Subject: [PATCH 50/83] kernel32/tests: Add some mutex tests.

---
 dlls/kernel32/tests/sync.c | 94 ++++++++++++++++++++++++++++++++++++++
 1 file changed, 94 insertions(+)

diff --git a/dlls/kernel32/tests/sync.c b/dlls/kernel32/tests/sync.c
index e0c5354c2f..98c96cb703 100644
--- a/dlls/kernel32/tests/sync.c
+++ b/dlls/kernel32/tests/sync.c
@@ -177,8 +177,23 @@ static void test_signalandwait(void)
     CloseHandle(file);
 }
 
+static HANDLE mutex, mutex2, mutices[2];
+
+static DWORD WINAPI mutex_thread( void *param )
+{
+    DWORD expect = (DWORD)(DWORD_PTR)param;
+    DWORD ret;
+
+    ret = WaitForSingleObject( mutex, 0 );
+    ok(ret == expect, "expected %u, got %u\n", expect, ret);
+
+    if (!ret) ReleaseMutex( mutex );
+    return 0;
+}
+
 static void test_mutex(void)
 {
+    HANDLE thread;
     DWORD wait_ret;
     BOOL ret;
     HANDLE hCreated;
@@ -289,6 +304,85 @@ todo_wine_if(getenv("WINEESYNC"))   /* XFAIL: due to the above */
     CloseHandle(hOpened);
 
     CloseHandle(hCreated);
+
+    mutex = CreateMutexA( NULL, FALSE, NULL );
+    ok(!!mutex, "got error %u\n", GetLastError());
+
+    ret = ReleaseMutex( mutex );
+    ok(!ret, "got %d\n", ret);
+    ok(GetLastError() == ERROR_NOT_OWNER, "got error %u\n", GetLastError());
+
+    for (i = 0; i < 100; i++)
+    {
+        ret = WaitForSingleObject( mutex, 0 );
+        ok(ret == 0, "got %u\n", ret);
+    }
+
+    for (i = 0; i < 100; i++)
+    {
+        ret = ReleaseMutex( mutex );
+        ok(ret, "got error %u\n", GetLastError());
+    }
+
+    ret = ReleaseMutex( mutex );
+    ok(!ret, "got %d\n", ret);
+    ok(GetLastError() == ERROR_NOT_OWNER, "got error %u\n", GetLastError());
+
+    thread = CreateThread( NULL, 0, mutex_thread, (void *)0, 0, NULL );
+    ret = WaitForSingleObject( thread, 2000 );
+    ok(ret == 0, "wait failed: %u\n", ret);
+
+    WaitForSingleObject( mutex, 0 );
+
+    thread = CreateThread( NULL, 0, mutex_thread, (void *)WAIT_TIMEOUT, 0, NULL );
+    ret = WaitForSingleObject( thread, 2000 );
+    ok(ret == 0, "wait failed: %u\n", ret);
+
+    ret = ReleaseMutex( mutex );
+        ok(ret, "got error %u\n", GetLastError());
+
+    thread = CreateThread( NULL, 0, mutex_thread, (void *)0, 0, NULL );
+    ret = WaitForSingleObject( thread, 2000 );
+    ok(ret == 0, "wait failed: %u\n", ret);
+
+    mutex2 = CreateMutexA( NULL, TRUE, NULL );
+    ok(!!mutex2, "got error %u\n", GetLastError());
+
+    ret = ReleaseMutex( mutex2 );
+    ok(ret, "got error %u\n", GetLastError());
+
+    ret = ReleaseMutex( mutex2 );
+    ok(!ret, "got %d\n", ret);
+    ok(GetLastError() == ERROR_NOT_OWNER, "got error %u\n", GetLastError());
+
+    mutices[0] = mutex;
+    mutices[1] = mutex2;
+
+    ret = WaitForMultipleObjects( 2, mutices, FALSE, 0 );
+    ok(ret == 0, "got %u\n", ret);
+
+    ret = ReleaseMutex( mutex );
+    ok(ret, "got error %u\n", GetLastError());
+
+    ret = ReleaseMutex( mutex2 );
+    ok(!ret, "got %d\n", ret);
+    ok(GetLastError() == ERROR_NOT_OWNER, "got error %u\n", GetLastError());
+
+    ret = WaitForMultipleObjects( 2, mutices, TRUE, 0 );
+    ok(ret == 0, "got %u\n", ret);
+
+    ret = ReleaseMutex( mutex );
+    ok(ret, "got error %u\n", GetLastError());
+
+    ret = ReleaseMutex( mutex2 );
+    ok(ret, "got error %u\n", GetLastError());
+
+    ret = CloseHandle( mutex );
+    ok(ret, "got error %u\n", GetLastError());
+
+    ret = CloseHandle( mutex2 );
+    ok(ret, "got error %u\n", GetLastError());
+
 }
 
 static void test_slist(void)
-- 
2.20.1


From 90bf7e295c7422a799dafb0aecd7c11e1a14cd8b Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 13 Jun 2018 23:58:01 -0500
Subject: [PATCH 51/83] kernel32/tests: Add some tests for wait timeouts.

---
 dlls/kernel32/tests/sync.c | 68 ++++++++++++++++++++++++++++++++++++++
 1 file changed, 68 insertions(+)

diff --git a/dlls/kernel32/tests/sync.c b/dlls/kernel32/tests/sync.c
index 98c96cb703..8a4a01d33f 100644
--- a/dlls/kernel32/tests/sync.c
+++ b/dlls/kernel32/tests/sync.c
@@ -54,6 +54,7 @@ static BOOLEAN (WINAPI *pTryAcquireSRWLockShared)(PSRWLOCK);
 
 static NTSTATUS (WINAPI *pNtAllocateVirtualMemory)(HANDLE, PVOID *, ULONG, SIZE_T *, ULONG, ULONG);
 static NTSTATUS (WINAPI *pNtFreeVirtualMemory)(HANDLE, PVOID *, SIZE_T *, ULONG);
+static NTSTATUS (WINAPI *pNtQuerySystemTime)(LARGE_INTEGER *);
 static NTSTATUS (WINAPI *pNtWaitForSingleObject)(HANDLE, BOOLEAN, const LARGE_INTEGER *);
 static NTSTATUS (WINAPI *pNtWaitForMultipleObjects)(ULONG,const HANDLE*,BOOLEAN,BOOLEAN,const LARGE_INTEGER*);
 static PSLIST_ENTRY (__fastcall *pRtlInterlockedPushListSList)(PSLIST_HEADER list, PSLIST_ENTRY first,
@@ -1480,11 +1481,15 @@ static HANDLE modify_handle(HANDLE handle, DWORD modify)
     return ULongToHandle(tmp);
 }
 
+#define TIMEOUT_INFINITE (((LONGLONG)0x7fffffff) << 32 | 0xffffffff)
+
 static void test_WaitForSingleObject(void)
 {
     HANDLE signaled, nonsignaled, invalid;
+    LARGE_INTEGER ntnow, ntthen;
     LARGE_INTEGER timeout;
     NTSTATUS status;
+    DWORD now, then;
     DWORD ret;
 
     signaled = CreateEventW(NULL, TRUE, TRUE, NULL);
@@ -1569,6 +1574,68 @@ static void test_WaitForSingleObject(void)
     status = pNtWaitForSingleObject(GetCurrentThread(), FALSE, &timeout);
     ok(status == STATUS_TIMEOUT, "expected STATUS_TIMEOUT, got %08x\n", status);
 
+    ret = WaitForSingleObject( signaled, 0 );
+    ok(ret == 0, "got %u\n", ret);
+
+    ret = WaitForSingleObject( nonsignaled, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %u\n", ret);
+
+    /* test that a timed wait actually does wait */
+    now = GetTickCount();
+    ret = WaitForSingleObject( nonsignaled, 100 );
+    then = GetTickCount();
+    ok(ret == WAIT_TIMEOUT, "got %u\n", ret);
+    ok(abs((then - now) - 100) < 5, "got %u ms\n", then - now);
+
+    now = GetTickCount();
+    ret = WaitForSingleObject( signaled, 100 );
+    then = GetTickCount();
+    ok(ret == 0, "got %u\n", ret);
+    ok(abs(then - now) < 5, "got %u ms\n", then - now);
+
+    ret = WaitForSingleObject( signaled, INFINITE );
+    ok(ret == 0, "got %u\n", ret);
+
+    /* test NT timeouts */
+    pNtQuerySystemTime( &ntnow );
+    timeout.QuadPart = ntnow.QuadPart + 100 * 10000;
+    status = pNtWaitForSingleObject( nonsignaled, FALSE, &timeout );
+    pNtQuerySystemTime( &ntthen );
+    ok(status == STATUS_TIMEOUT, "got %#x\n", status);
+    ok(abs(((ntthen.QuadPart - ntnow.QuadPart) / 10000) - 100) < 5, "got %s ns\n",
+        wine_dbgstr_longlong((ntthen.QuadPart - ntnow.QuadPart) * 100));
+
+    pNtQuerySystemTime( &ntnow );
+    timeout.QuadPart = -100 * 10000;
+    status = pNtWaitForSingleObject( nonsignaled, FALSE, &timeout );
+    pNtQuerySystemTime( &ntthen );
+    ok(status == STATUS_TIMEOUT, "got %#x\n", status);
+    ok(abs(((ntthen.QuadPart - ntnow.QuadPart) / 10000) - 100) < 5, "got %s ns\n",
+        wine_dbgstr_longlong((ntthen.QuadPart - ntnow.QuadPart) * 100));
+
+    status = pNtWaitForSingleObject( signaled, FALSE, NULL );
+    ok(status == 0, "got %#x\n", status);
+
+    timeout.QuadPart = TIMEOUT_INFINITE;
+    status = pNtWaitForSingleObject( signaled, FALSE, &timeout );
+    ok(status == 0, "got %#x\n", status);
+
+    pNtQuerySystemTime( &ntnow );
+    timeout.QuadPart = ntnow.QuadPart;
+    status = pNtWaitForSingleObject( nonsignaled, FALSE, &timeout );
+    pNtQuerySystemTime( &ntthen );
+    ok(status == STATUS_TIMEOUT, "got %#x\n", status);
+    ok(abs((ntthen.QuadPart - ntnow.QuadPart) / 10000) < 5, "got %s ns\n",
+        wine_dbgstr_longlong((ntthen.QuadPart - ntnow.QuadPart) * 100));
+
+    pNtQuerySystemTime( &ntnow );
+    timeout.QuadPart = ntnow.QuadPart - 100 * 10000;
+    status = pNtWaitForSingleObject( nonsignaled, FALSE, &timeout );
+    pNtQuerySystemTime( &ntthen );
+    ok(status == STATUS_TIMEOUT, "got %#x\n", status);
+    ok(abs((ntthen.QuadPart - ntnow.QuadPart) / 10000) < 5, "got %s ns\n",
+        wine_dbgstr_longlong((ntthen.QuadPart - ntnow.QuadPart) * 100));
+
     CloseHandle(signaled);
     CloseHandle(nonsignaled);
 }
@@ -2970,6 +3037,7 @@ START_TEST(sync)
     pTryAcquireSRWLockShared = (void *)GetProcAddress(hdll, "TryAcquireSRWLockShared");
     pNtAllocateVirtualMemory = (void *)GetProcAddress(hntdll, "NtAllocateVirtualMemory");
     pNtFreeVirtualMemory = (void *)GetProcAddress(hntdll, "NtFreeVirtualMemory");
+    pNtQuerySystemTime = (void *)GetProcAddress(hntdll, "NtQuerySystemTime");
     pNtWaitForSingleObject = (void *)GetProcAddress(hntdll, "NtWaitForSingleObject");
     pNtWaitForMultipleObjects = (void *)GetProcAddress(hntdll, "NtWaitForMultipleObjects");
     pRtlInterlockedPushListSList = (void *)GetProcAddress(hntdll, "RtlInterlockedPushListSList");
-- 
2.20.1


From d8bb66324150e04376c60910a8cbea750250eeb2 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Tue, 19 Jun 2018 10:50:09 -0500
Subject: [PATCH 52/83] ntdll: Go through the server if necessary when
 performing event/semaphore/mutex ops.

Because we might have a duplicated or inherited handle, and we won't know about it until we ask the server.
---
 dlls/ntdll/esync.c | 50 +++++++++++++++++++++++++++-------------------
 1 file changed, 29 insertions(+), 21 deletions(-)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 395c8d3366..59704bd90a 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -196,7 +196,7 @@ static BOOL add_to_list( HANDLE handle, struct esync *obj )
     return TRUE;
 }
 
-static void *esync_get_object( HANDLE handle )
+static struct esync *get_cached_object( HANDLE handle )
 {
     UINT_PTR entry, idx = handle_to_index( handle, &entry );
 
@@ -205,11 +205,14 @@ static void *esync_get_object( HANDLE handle )
     return esync_list[entry][idx];
 }
 
-/* Gets a waitable object. This is either a proper esync object (i.e. an event,
+/* Gets an object. This is either a proper esync object (i.e. an event,
  * semaphore, etc. created using create_esync) or a generic synchronizable
  * server-side object which the server will signal (e.g. a process, thread,
- * message queue, etc.) */
-static NTSTATUS get_waitable_object( HANDLE handle, struct esync **obj )
+ * message queue, etc.)
+ *
+ * Note that we have to make the server path available even for esync objects
+ * since we might be passed a duplicated or inherited handle. */
+static NTSTATUS get_object( HANDLE handle, struct esync **obj )
 {
     obj_handle_t fd_handle;
     enum esync_type type;
@@ -219,11 +222,11 @@ static NTSTATUS get_waitable_object( HANDLE handle, struct esync **obj )
     NTSTATUS ret;
     int fd;
 
-    if ((*obj = esync_get_object( handle ))) return STATUS_SUCCESS;
+    if ((*obj = get_cached_object( handle ))) return STATUS_SUCCESS;
 
     /* We need to try grabbing it from the server. */
     server_enter_uninterrupted_section( &fd_cache_section, &sigset );
-    if (!(esync = esync_get_object( handle )))
+    if (!(esync = get_cached_object( handle )))
     {
         SERVER_START_REQ( get_esync_fd )
         {
@@ -420,7 +423,7 @@ NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
         /* Initialize the shared memory portion.
          * Note we store max here (even though we don't need to) just to keep
          * it the same size as the mutex's shm portion. */
-        struct esync *obj = esync_get_object( *handle );
+        struct esync *obj = get_cached_object( *handle );
         struct semaphore *semaphore = obj->shm;
         semaphore->max = max;
         semaphore->count = initial;
@@ -446,14 +449,15 @@ NTSTATUS esync_open_semaphore( HANDLE *handle, ACCESS_MASK access,
 
 NTSTATUS esync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev )
 {
-    struct esync *obj = esync_get_object( handle );
+    struct esync *obj;
     struct semaphore *semaphore;
     uint64_t count64 = count;
     ULONG current;
+    NTSTATUS ret;
 
     TRACE("%p, %d, %p.\n", handle, count, prev);
 
-    if (!obj) return STATUS_INVALID_HANDLE;
+    if ((ret = get_object( handle, &obj))) return ret;
     semaphore = obj->shm;
 
     do
@@ -498,12 +502,13 @@ NTSTATUS esync_open_event( HANDLE *handle, ACCESS_MASK access,
 
 NTSTATUS esync_set_event( HANDLE handle )
 {
-    struct esync *obj = esync_get_object( handle );
     static const uint64_t value = 1;
+    struct esync *obj;
+    NTSTATUS ret;
 
     TRACE("%p.\n", handle);
 
-    if (!obj) return STATUS_INVALID_HANDLE;
+    if ((ret = get_object( handle, &obj ))) return ret;
 
     if (write( obj->fd, &value, sizeof(value) ) == -1)
         return FILE_GetNtStatus();
@@ -513,12 +518,13 @@ NTSTATUS esync_set_event( HANDLE handle )
 
 NTSTATUS esync_reset_event( HANDLE handle )
 {
-    struct esync *obj = esync_get_object( handle );
     static uint64_t value;
+    struct esync *obj;
+    NTSTATUS ret;
 
     TRACE("%p.\n", handle);
 
-    if (!obj) return STATUS_INVALID_HANDLE;
+    if ((ret = get_object( handle, &obj ))) return ret;
 
     /* we don't care about the return value */
     read( obj->fd, &value, sizeof(value) );
@@ -528,12 +534,13 @@ NTSTATUS esync_reset_event( HANDLE handle )
 
 NTSTATUS esync_pulse_event( HANDLE handle )
 {
-    struct esync *obj = esync_get_object( handle );
     static uint64_t value = 1;
+    struct esync *obj;
+    NTSTATUS ret;
 
     TRACE("%p.\n", handle);
 
-    if (!obj) return STATUS_INVALID_HANDLE;
+    if ((ret = get_object( handle, &obj ))) return ret;
 
     /* This isn't really correct; an application could miss the write.
      * Unfortunately we can't really do much better. Fortunately this is rarely
@@ -559,7 +566,7 @@ NTSTATUS esync_create_mutex( HANDLE *handle, ACCESS_MASK access,
     if (!ret)
     {
         /* Initialize the shared memory portion. */
-        struct esync *obj = esync_get_object( *handle );
+        struct esync *obj = get_cached_object( *handle );
         struct mutex *mutex = obj->shm;
         mutex->tid = initial ? GetCurrentThreadId() : 0;
         mutex->count = initial ? 1 : 0;
@@ -585,13 +592,14 @@ NTSTATUS esync_open_mutex( HANDLE *handle, ACCESS_MASK access,
 
 NTSTATUS esync_release_mutex( HANDLE *handle, LONG *prev )
 {
-    struct esync *obj = esync_get_object( handle );
+    struct esync *obj;
     struct mutex *mutex;
     static const uint64_t value = 1;
+    NTSTATUS ret;
 
     TRACE("%p, %p.\n", handle, prev);
 
-    if (!obj) return STATUS_INVALID_HANDLE;
+    if ((ret = get_object( handle, &obj ))) return ret;
     mutex = obj->shm;
 
     /* This is thread-safe, because the only thread that can change the tid to
@@ -715,7 +723,7 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
 
     for (i = 0; i < count; i++)
     {
-        ret = get_waitable_object( handles[i], &objs[i] );
+        ret = get_object( handles[i], &objs[i] );
         if (ret == STATUS_SUCCESS)
             has_esync = 1;
         else if (ret == STATUS_NOT_IMPLEMENTED)
@@ -1072,10 +1080,10 @@ userapc:
 NTSTATUS esync_signal_and_wait( HANDLE signal, HANDLE wait, BOOLEAN alertable,
     const LARGE_INTEGER *timeout )
 {
-    struct esync *obj = esync_get_object( signal );
+    struct esync *obj;
     NTSTATUS ret;
 
-    if (!obj) return STATUS_INVALID_HANDLE;
+    if ((ret = get_object( signal, &obj ))) return ret;
 
     switch (obj->type)
     {
-- 
2.20.1


From a447cadbedc14626ee862d8f073a8a55481ba87a Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Tue, 19 Jun 2018 11:27:58 -0500
Subject: [PATCH 53/83] server: Create eventfd descriptors for
 console_input_events objects.

---
 server/console.c | 19 ++++++++++++++++++-
 1 file changed, 18 insertions(+), 1 deletion(-)

diff --git a/server/console.c b/server/console.c
index b0038d079a..8dd8d0ccb3 100644
--- a/server/console.c
+++ b/server/console.c
@@ -38,6 +38,7 @@
 #include "unicode.h"
 #include "wincon.h"
 #include "winternl.h"
+#include "esync.h"
 
 struct screen_buffer;
 struct console_input_events;
@@ -95,6 +96,7 @@ static const struct object_ops console_input_ops =
 static void console_input_events_dump( struct object *obj, int verbose );
 static void console_input_events_destroy( struct object *obj );
 static int console_input_events_signaled( struct object *obj, struct wait_queue_entry *entry );
+static int console_input_events_get_esync_fd( struct object *obj, enum esync_type *type );
 
 struct console_input_events
 {
@@ -102,6 +104,7 @@ struct console_input_events
     int			  num_alloc;   /* number of allocated events */
     int 		  num_used;    /* number of actually used events */
     struct console_renderer_event*	events;
+    int                   esync_fd;    /* esync file descriptor (signalled when events present) */
 };
 
 static const struct object_ops console_input_events_ops =
@@ -112,7 +115,7 @@ static const struct object_ops console_input_events_ops =
     add_queue,                        /* add_queue */
     remove_queue,                     /* remove_queue */
     console_input_events_signaled,    /* signaled */
-    NULL,                             /* get_esync_fd */
+    console_input_events_get_esync_fd,/* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     no_get_fd,                        /* get_fd */
@@ -250,6 +253,13 @@ static int console_input_events_signaled( struct object *obj, struct wait_queue_
     return (evts->num_used != 0);
 }
 
+static int console_input_events_get_esync_fd( struct object *obj, enum esync_type *type )
+{
+    struct console_input_events *evts = (struct console_input_events *)obj;
+    *type = ESYNC_MANUAL_SERVER;
+    return evts->esync_fd;
+}
+
 /* add an event to the console's renderer events list */
 static void console_input_events_append( struct console_input* console,
 					 struct console_renderer_event* evt)
@@ -304,6 +314,9 @@ static void console_input_events_get( struct console_input_events* evts )
                  (evts->num_used - num) * sizeof(evts->events[0]) );
     }
     evts->num_used -= num;
+
+    if (do_esync() && !evts->num_used)
+        esync_clear( evts->esync_fd );
 }
 
 static struct console_input_events *create_console_input_events(void)
@@ -313,6 +326,10 @@ static struct console_input_events *create_console_input_events(void)
     if (!(evt = alloc_object( &console_input_events_ops ))) return NULL;
     evt->num_alloc = evt->num_used = 0;
     evt->events = NULL;
+    evt->esync_fd = -1;
+
+    if (do_esync())
+        evt->esync_fd = esync_create_fd( 0, 0 );
     return evt;
 }
 
-- 
2.20.1


From f866e082659ee3b9427ee8bd4378c6fa3b7202f9 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 20 Jun 2018 13:30:45 -0500
Subject: [PATCH 54/83] server: Alter conditions in is_queue_hung(), again.

Complications with SMTO_ABORTIFHUNG lead to implementing this function
exactly correctly.

On Windows, a queue is not hung if you somehow process messages (doesn't
matter how), or if you call MsgWaitForMultipleObjects().

In a sense, Wine had this correct, except not exactly. Firstly, you can call
MsgWait(0, NULL, FALSE, 0, 0); Sleep(1000); in a loop and not be considered
hung; i.e. you don't have to be actively waiting on the queue, but can just
poll it. You also don't have to have a mask that lets in any events--but
just calling WaitForMultipleObjects() isn't enough. On the other hand,
calling MsgWait(0, NULL, FALSE, INFINITE, 0) will result in a hung queue.

last_get_msg should probably be renamed, but nothing better comes to mind.
---
 server/queue.c | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/server/queue.c b/server/queue.c
index d88edb0f73..86e6bc4351 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -910,7 +910,7 @@ static void cleanup_results( struct msg_queue *queue )
 /* check if the thread owning the queue is hung (not checking for messages) */
 static int is_queue_hung( struct msg_queue *queue )
 {
-    return is_signaled( queue ) && (current_time - queue->last_get_msg > 5 * TICKS_PER_SEC);
+    return (current_time - queue->last_get_msg > 5 * TICKS_PER_SEC);
 }
 
 static int msg_queue_add_queue( struct object *obj, struct wait_queue_entry *entry )
@@ -926,6 +926,12 @@ static int msg_queue_add_queue( struct object *obj, struct wait_queue_entry *ent
     }
     if (process->idle_event && !(queue->wake_mask & QS_SMRESULT)) set_event( process->idle_event );
 
+    /* On Windows, we are considered hung iff we have not somehow processed
+     * messages OR done a MsgWait call in the last 5 seconds. Note that in the
+     * latter case repeatedly waiting for 0 seconds is not hung, but waiting
+     * forever is hung, so this is correct. */
+    queue->last_get_msg = current_time;
+
     if (queue->fd && list_empty( &obj->wait_queue ))  /* first on the queue */
         set_fd_events( queue->fd, POLLIN );
     add_queue( obj, entry );
-- 
2.20.1


From d1f654808f7929f1e84f154863eed1b198a97dc1 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 20 Jun 2018 13:41:12 -0500
Subject: [PATCH 55/83] ntdll: Let the server know when we are doing a message
 wait.

---
 dlls/ntdll/esync.c | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 59704bd90a..e5106a5bdd 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -734,11 +734,22 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
 
     if (objs[count - 1] && objs[count - 1]->type == ESYNC_QUEUE)
     {
+        select_op_t select_op;
+
         /* Last object in the list is a queue, which means someone is using
          * MsgWaitForMultipleObjects(). We have to wait not only for the server
          * fd (signaled on send_message, etc.) but also the USER driver's fd
          * (signaled on e.g. X11 events.) */
         msgwait = TRUE;
+
+        /* We need to let the server know we are doing a message wait, for two
+         * reasons. First one is WaitForInputIdle(). Second one is checking for
+         * hung queues. Do it like this. */
+        select_op.wait.op = SELECT_WAIT;
+        select_op.wait.handles[0] = wine_server_obj_handle( handles[count - 1] );
+        ret = server_select( &select_op, offsetof( select_op_t, wait.handles[1] ), 0, &zero );
+        if (ret != STATUS_WAIT_0 && ret != STATUS_TIMEOUT)
+            ERR("Unexpected ret %#x\n", ret);
     }
 
     if (has_esync && has_server)
-- 
2.20.1


From 183e94b4a0a0bed5a4c7264d95893b26f21410ca Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 20 Jun 2018 14:04:04 -0500
Subject: [PATCH 56/83] ntdll: Avoid server_select() when waiting for critical
 sections.

There's no reason not to always use NtWaitForSingleObject(), so just do that.

And of course this lets esync work right.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
---
 dlls/ntdll/critsection.c | 5 +----
 1 file changed, 1 insertion(+), 4 deletions(-)

diff --git a/dlls/ntdll/critsection.c b/dlls/ntdll/critsection.c
index 42e432c8f6..fb616adfd8 100644
--- a/dlls/ntdll/critsection.c
+++ b/dlls/ntdll/critsection.c
@@ -230,12 +230,9 @@ static inline NTSTATUS wait_semaphore( RTL_CRITICAL_SECTION *crit, int timeout )
     {
         HANDLE sem = get_semaphore( crit );
         LARGE_INTEGER time;
-        select_op_t select_op;
 
         time.QuadPart = timeout * (LONGLONG)-10000000;
-        select_op.wait.op = SELECT_WAIT;
-        select_op.wait.handles[0] = wine_server_obj_handle( sem );
-        ret = server_select( &select_op, offsetof( select_op_t, wait.handles[1] ), 0, &time );
+        ret = NtWaitForSingleObject( sem, FALSE, &time );
     }
     return ret;
 }
-- 
2.20.1


From a9ff49e6165945e8590f6f3026010491dcf74ddb Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 20 Jun 2018 15:07:28 -0500
Subject: [PATCH 57/83] user32: Remove hooks that time out.

In accordance with Win7+ behaviour.
---
 dlls/user32/hook.c | 17 +++++++++++------
 1 file changed, 11 insertions(+), 6 deletions(-)

diff --git a/dlls/user32/hook.c b/dlls/user32/hook.c
index 3aa7b33a8c..79171fac04 100644
--- a/dlls/user32/hook.c
+++ b/dlls/user32/hook.c
@@ -381,6 +381,7 @@ void *get_hook_proc( void *proc, const WCHAR *module, HMODULE *free_module )
 static LRESULT call_hook( struct hook_info *info, INT code, WPARAM wparam, LPARAM lparam )
 {
     DWORD_PTR ret = 0;
+    LRESULT lres;
 
     if (info->tid)
     {
@@ -394,20 +395,24 @@ static LRESULT call_hook( struct hook_info *info, INT code, WPARAM wparam, LPARA
         switch(info->id)
         {
         case WH_KEYBOARD_LL:
-            MSG_SendInternalMessageTimeout( info->pid, info->tid, WM_WINE_KEYBOARD_LL_HOOK,
-                                            wparam, (LPARAM)&h_extra, SMTO_ABORTIFHUNG,
-                                            get_ll_hook_timeout(), &ret );
+            lres = MSG_SendInternalMessageTimeout( info->pid, info->tid, WM_WINE_KEYBOARD_LL_HOOK,
+                wparam, (LPARAM)&h_extra, SMTO_ABORTIFHUNG, get_ll_hook_timeout(), &ret );
             break;
         case WH_MOUSE_LL:
-            MSG_SendInternalMessageTimeout( info->pid, info->tid, WM_WINE_MOUSE_LL_HOOK,
-                                            wparam, (LPARAM)&h_extra, SMTO_ABORTIFHUNG,
-                                            get_ll_hook_timeout(), &ret );
+            lres = MSG_SendInternalMessageTimeout( info->pid, info->tid, WM_WINE_MOUSE_LL_HOOK,
+                wparam, (LPARAM)&h_extra, SMTO_ABORTIFHUNG, get_ll_hook_timeout(), &ret );
             break;
         default:
             ERR("Unknown hook id %d\n", info->id);
             assert(0);
             break;
         }
+
+        if (!lres && GetLastError() == ERROR_TIMEOUT)
+        {
+            TRACE("Hook %p timed out; removing it.\n", info->handle);
+            UnhookWindowsHookEx( info->handle );
+        }
     }
     else if (info->proc)
     {
-- 
2.20.1


From f465453de690e75fbfff4e6cde9d77bb75203e59 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 20 Jun 2018 15:10:08 -0500
Subject: [PATCH 58/83] server: Don't check for a hung queue when sending
 low-level hooks.

Since user32 does this.

This logic is independent of the SMTO_ABORTIFHUNG logic on Windows. In fact, IsHungAppWindow() uses yet another algorithm.
---
 server/queue.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/server/queue.c b/server/queue.c
index 86e6bc4351..2a9d70c137 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -1577,7 +1577,6 @@ static int send_hook_ll_message( struct desktop *desktop, struct message *hardwa
 
     if (!(hook_thread = get_first_global_hook( id ))) return 0;
     if (!(queue = hook_thread->queue)) return 0;
-    if (is_queue_hung( queue )) return 0;
 
     if (!(msg = mem_alloc( sizeof(*msg) ))) return 0;
 
-- 
2.20.1


From a7a6434c3dd7be56e78f9b3200a89ca8d2406bde Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Tue, 26 Jun 2018 18:44:44 -0500
Subject: [PATCH 59/83] kernel32/tests: Zigzag test.

The primary function is to check for races. The secondary function is to measure performance.
---
 dlls/kernel32/tests/sync.c | 79 ++++++++++++++++++++++++++++++++++++++
 1 file changed, 79 insertions(+)

diff --git a/dlls/kernel32/tests/sync.c b/dlls/kernel32/tests/sync.c
index 8a4a01d33f..9b2e57c339 100644
--- a/dlls/kernel32/tests/sync.c
+++ b/dlls/kernel32/tests/sync.c
@@ -3012,6 +3012,84 @@ static void test_apc_deadlock(void)
     CloseHandle(pi.hProcess);
 }
 
+static int zigzag_state, zigzag_count[2], zigzag_stop;
+
+static DWORD CALLBACK zigzag_event0(void *arg)
+{
+    HANDLE *events = arg;
+
+    while (!zigzag_stop)
+    {
+        WaitForSingleObject(events[0], INFINITE);
+        ResetEvent(events[0]);
+        ok(zigzag_state == 0, "got wrong state %d\n", zigzag_state);
+        zigzag_state++;
+        SetEvent(events[1]);
+        zigzag_count[0]++;
+    }
+    trace("thread 0 got done\n");
+    return 0;
+}
+
+static DWORD CALLBACK zigzag_event1(void *arg)
+{
+    HANDLE *events = arg;
+
+    while (!zigzag_stop)
+    {
+        WaitForSingleObject(events[1], INFINITE);
+        ResetEvent(events[1]);
+        ok(zigzag_state == 1, "got wrong state %d\n", zigzag_state);
+        zigzag_state--;
+        SetEvent(events[0]);
+        zigzag_count[1]++;
+    }
+    trace("thread 1 got done\n");
+    return 0;
+}
+
+static void test_zigzag_event(void)
+{
+    /* The basic idea is to test SetEvent/Wait back and forth between two
+     * threads. Each thread clears their own event, sets some common data,
+     * signals the other's, then waits on their own. We make sure the common
+     * data is always in the right state. We also print performance data. */
+
+    HANDLE threads[2], events[2];
+    BOOL ret;
+
+    events[0] = CreateEventA(NULL, FALSE, FALSE, NULL);
+    events[1] = CreateEventA(NULL, FALSE, FALSE, NULL);
+
+    threads[0] = CreateThread(NULL, 0, zigzag_event0, events, 0, NULL);
+    threads[1] = CreateThread(NULL, 0, zigzag_event1, events, 0, NULL);
+
+    zigzag_state = 0;
+    zigzag_count[0] = zigzag_count[1] = 0;
+    zigzag_stop = 0;
+
+    trace("starting zigzag test (events)\n");
+    SetEvent(events[0]);
+    Sleep(2000);
+    zigzag_stop = 1;
+    ret = WaitForMultipleObjects(2, threads, FALSE, INFINITE);
+    trace("%d\n", ret);
+    ok(ret == 0 || ret == 1, "wait failed: %u\n", ret);
+
+    ok(zigzag_count[0] == zigzag_count[1] || zigzag_count[0] == zigzag_count[1] + 1,
+        "count did not match: %d != %d\n", zigzag_count[0], zigzag_count[1]);
+
+    /* signal the other thread to finish, if it didn't already
+     * (in theory they both would at the same time, but there's a slight race on teardown if we get
+     * thread 1 SetEvent -> thread 0 ResetEvent -> thread 0 Wait -> thread 1 exits */
+    zigzag_state = 1-ret;
+    SetEvent(events[1-ret]);
+    ret = WaitForSingleObject(threads[1-ret], 1000);
+    ok(!ret, "wait failed: %u\n", ret);
+
+    trace("count: %d\n", zigzag_count[0]);
+}
+
 START_TEST(sync)
 {
     char **argv;
@@ -3071,4 +3149,5 @@ START_TEST(sync)
     test_srwlock_example();
     test_alertable_wait();
     test_apc_deadlock();
+    test_zigzag_event();
 }
-- 
2.20.1


From 13f102db490011ea74c8a705c80a941b6c29ce6d Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 1 Jul 2018 12:00:09 +0200
Subject: [PATCH 60/83] =?UTF-8?q?server:=20Try=20to=20remove=20a=20pre?=
 =?UTF-8?q?=C3=ABxisting=20shm=20file.?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This should have been removed even if wineserver was killed, but if someone
uses SIGKILL or something similar we should try to handle that gracefully.
---
 server/esync.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/server/esync.c b/server/esync.c
index 8bf6e441f1..5cf4bddbb0 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -83,6 +83,8 @@ void esync_init(void)
     else
         sprintf( shm_name, "/wine-%lx-esync", (unsigned long)st.st_ino );
 
+    shm_unlink( shm_name );
+
     shm_fd = shm_open( shm_name, O_RDWR | O_CREAT | O_EXCL, 0644 );
     if (shm_fd == -1)
         perror( "shm_open" );
-- 
2.20.1


From 85e2784dceb254401102f2883ef2a30df47da9a1 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 4 Jul 2018 14:34:37 +0200
Subject: [PATCH 61/83] ntdll: Implement NtQuerySemaphore().

---
 dlls/ntdll/esync.c | 26 ++++++++++++++++++++++++++
 dlls/ntdll/esync.h |  2 ++
 dlls/ntdll/sync.c  |  3 +++
 3 files changed, 31 insertions(+)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index e5106a5bdd..9b4313a251 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -480,6 +480,32 @@ NTSTATUS esync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev )
     return STATUS_SUCCESS;
 }
 
+NTSTATUS esync_query_semaphore( HANDLE handle, SEMAPHORE_INFORMATION_CLASS class,
+    void *info, ULONG len, ULONG *ret_len )
+{
+    struct esync *obj;
+    struct semaphore *semaphore;
+    SEMAPHORE_BASIC_INFORMATION *out = info;
+    NTSTATUS ret;
+
+    TRACE("%p, %u, %p, %u, %p.\n", handle, class, info, len, ret_len);
+
+    if (class != SemaphoreBasicInformation)
+    {
+        FIXME("(%p,%d,%u) Unknown class\n", handle, class, len);
+        return STATUS_INVALID_INFO_CLASS;
+    }
+
+    if ((ret = get_object( handle, &obj ))) return ret;
+    semaphore = obj->shm;
+
+    out->CurrentCount = semaphore->count;
+    out->MaximumCount = semaphore->max;
+    if (ret_len) *ret_len = sizeof(*out);
+
+    return STATUS_SUCCESS;
+}
+
 NTSTATUS esync_create_event( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, EVENT_TYPE event_type, BOOLEAN initial )
 {
diff --git a/dlls/ntdll/esync.h b/dlls/ntdll/esync.h
index 0a784b0e79..bc0ef16842 100644
--- a/dlls/ntdll/esync.h
+++ b/dlls/ntdll/esync.h
@@ -39,6 +39,8 @@ extern NTSTATUS esync_open_event( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr ) DECLSPEC_HIDDEN;
 extern NTSTATUS esync_open_mutex( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr ) DECLSPEC_HIDDEN;
+extern NTSTATUS esync_query_semaphore( HANDLE handle, SEMAPHORE_INFORMATION_CLASS class,
+    void *info, ULONG len, ULONG *ret_len ) DECLSPEC_HIDDEN;
 
 extern NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
                                     BOOLEAN alertable, const LARGE_INTEGER *timeout ) DECLSPEC_HIDDEN;
diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index e13c6a247b..c2da9b8ce6 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -305,6 +305,9 @@ NTSTATUS WINAPI NtQuerySemaphore( HANDLE handle, SEMAPHORE_INFORMATION_CLASS cla
     NTSTATUS ret;
     SEMAPHORE_BASIC_INFORMATION *out = info;
 
+    if (do_esync())
+        return esync_query_semaphore( handle, class, info, len, ret_len );
+
     TRACE("(%p, %u, %p, %u, %p)\n", handle, class, info, len, ret_len);
 
     if (class != SemaphoreBasicInformation)
-- 
2.20.1


From b83952cd39a09f628592ce39ee83be2a9af37db6 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 4 Jul 2018 14:40:30 +0200
Subject: [PATCH 62/83] ntdll: Implement NtQueryEvent().

---
 dlls/ntdll/esync.c | 27 +++++++++++++++++++++++++++
 dlls/ntdll/esync.h |  2 ++
 dlls/ntdll/sync.c  |  3 +++
 3 files changed, 32 insertions(+)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 9b4313a251..aa927c5fc3 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -578,6 +578,33 @@ NTSTATUS esync_pulse_event( HANDLE handle )
     return STATUS_SUCCESS;
 }
 
+NTSTATUS esync_query_event( HANDLE handle, EVENT_INFORMATION_CLASS class,
+    void *info, ULONG len, ULONG *ret_len )
+{
+    struct esync *obj;
+    EVENT_BASIC_INFORMATION *out = info;
+    struct pollfd fd;
+    NTSTATUS ret;
+
+    TRACE("%p, %u, %p, %u, %p.\n", handle, class, info, len, ret_len);
+
+    if (class != EventBasicInformation)
+    {
+        FIXME("(%p,%d,%u) Unknown class\n", handle, class, len);
+        return STATUS_INVALID_INFO_CLASS;
+    }
+
+    if ((ret = get_object( handle, &obj ))) return ret;
+
+    fd.fd = obj->fd;
+    fd.events = POLLIN;
+    out->EventState = poll( &fd, 1, 0 );
+    out->EventType = (obj->type == ESYNC_AUTO_EVENT ? SynchronizationEvent : NotificationEvent);
+    if (ret_len) *ret_len = sizeof(*out);
+
+    return STATUS_SUCCESS;
+}
+
 NTSTATUS esync_create_mutex( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, BOOLEAN initial )
 {
diff --git a/dlls/ntdll/esync.h b/dlls/ntdll/esync.h
index bc0ef16842..fefb1a31fa 100644
--- a/dlls/ntdll/esync.h
+++ b/dlls/ntdll/esync.h
@@ -41,6 +41,8 @@ extern NTSTATUS esync_open_mutex( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr ) DECLSPEC_HIDDEN;
 extern NTSTATUS esync_query_semaphore( HANDLE handle, SEMAPHORE_INFORMATION_CLASS class,
     void *info, ULONG len, ULONG *ret_len ) DECLSPEC_HIDDEN;
+extern NTSTATUS esync_query_event( HANDLE handle, EVENT_INFORMATION_CLASS class,
+    void *info, ULONG len, ULONG *ret_len ) DECLSPEC_HIDDEN;
 
 extern NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
                                     BOOLEAN alertable, const LARGE_INTEGER *timeout ) DECLSPEC_HIDDEN;
diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index c2da9b8ce6..cac07c204e 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -511,6 +511,9 @@ NTSTATUS WINAPI NtQueryEvent( HANDLE handle, EVENT_INFORMATION_CLASS class,
     NTSTATUS ret;
     EVENT_BASIC_INFORMATION *out = info;
 
+    if (do_esync())
+        return esync_query_event( handle, class, info, len, ret_len );
+
     TRACE("(%p, %u, %p, %u, %p)\n", handle, class, info, len, ret_len);
 
     if (class != EventBasicInformation)
-- 
2.20.1


From a8b1b4bb248ed64612ce688f996b340f04183e70 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 4 Jul 2018 14:47:23 +0200
Subject: [PATCH 63/83] ntdll: Implement NtQueryMutant().

---
 dlls/ntdll/esync.c | 27 +++++++++++++++++++++++++++
 dlls/ntdll/esync.h |  2 ++
 dlls/ntdll/sync.c  |  3 +++
 3 files changed, 32 insertions(+)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index aa927c5fc3..e10f0ea4bf 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -677,6 +677,33 @@ NTSTATUS esync_release_mutex( HANDLE *handle, LONG *prev )
     return STATUS_SUCCESS;
 }
 
+NTSTATUS esync_query_mutex( HANDLE handle, MUTANT_INFORMATION_CLASS class,
+    void *info, ULONG len, ULONG *ret_len )
+{
+    struct esync *obj;
+    struct mutex *mutex;
+    MUTANT_BASIC_INFORMATION *out = info;
+    NTSTATUS ret;
+
+    TRACE("%p, %u, %p, %u, %p.\n", handle, class, info, len, ret_len);
+
+    if (class != MutantBasicInformation)
+    {
+        FIXME("(%p,%d,%u) Unknown class\n", handle, class, len);
+        return STATUS_INVALID_INFO_CLASS;
+    }
+
+    if ((ret = get_object( handle, &obj ))) return ret;
+    mutex = obj->shm;
+
+    out->CurrentCount = 1 - mutex->count;
+    out->OwnedByCaller = (mutex->tid == GetCurrentThreadId());
+    out->AbandonedState = FALSE;
+    if (ret_len) *ret_len = sizeof(*out);
+
+    return STATUS_SUCCESS;
+}
+
 #define TICKSPERSEC        10000000
 #define TICKSPERMSEC       10000
 
diff --git a/dlls/ntdll/esync.h b/dlls/ntdll/esync.h
index fefb1a31fa..35afc304d9 100644
--- a/dlls/ntdll/esync.h
+++ b/dlls/ntdll/esync.h
@@ -43,6 +43,8 @@ extern NTSTATUS esync_query_semaphore( HANDLE handle, SEMAPHORE_INFORMATION_CLAS
     void *info, ULONG len, ULONG *ret_len ) DECLSPEC_HIDDEN;
 extern NTSTATUS esync_query_event( HANDLE handle, EVENT_INFORMATION_CLASS class,
     void *info, ULONG len, ULONG *ret_len ) DECLSPEC_HIDDEN;
+extern NTSTATUS esync_query_mutex( HANDLE handle, MUTANT_INFORMATION_CLASS class,
+    void *info, ULONG len, ULONG *ret_len ) DECLSPEC_HIDDEN;
 
 extern NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
                                     BOOLEAN alertable, const LARGE_INTEGER *timeout ) DECLSPEC_HIDDEN;
diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index cac07c204e..c36e8022d2 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -634,6 +634,9 @@ NTSTATUS WINAPI NtQueryMutant( HANDLE handle, MUTANT_INFORMATION_CLASS class,
     NTSTATUS ret;
     MUTANT_BASIC_INFORMATION *out = info;
 
+    if (do_esync())
+        return esync_query_mutex( handle, class, info, len, ret_len );
+
     TRACE("(%p, %u, %p, %u, %p)\n", handle, class, info, len, ret_len);
 
     if (class != MutantBasicInformation)
-- 
2.20.1


From 89769c3e6362b3949ab9cbf5fdf0bb7ea0846d16 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 7 Jul 2018 12:57:47 +0200
Subject: [PATCH 64/83] server: Create eventfd descriptors for pseudo-fd
 objects and use them for named pipes.

---
 server/fd.c         | 22 ++++++++++++++++++++++
 server/file.h       |  1 +
 server/named_pipe.c |  4 ++--
 3 files changed, 25 insertions(+), 2 deletions(-)

diff --git a/server/fd.c b/server/fd.c
index 4c94c4918f..9dac2ffa29 100644
--- a/server/fd.c
+++ b/server/fd.c
@@ -101,6 +101,7 @@
 #include "handle.h"
 #include "process.h"
 #include "request.h"
+#include "esync.h"
 
 #include "winternl.h"
 #include "winioctl.h"
@@ -195,6 +196,7 @@ struct fd
     struct completion   *completion;  /* completion object attached to this fd */
     apc_param_t          comp_key;    /* completion key to set in completion events */
     unsigned int         comp_flags;  /* completion flags */
+    int                  esync_fd;    /* esync file descriptor */
 };
 
 static void fd_dump( struct object *obj, int verbose );
@@ -1496,6 +1498,9 @@ static void fd_destroy( struct object *obj )
         if (fd->unix_fd != -1) close( fd->unix_fd );
         free( fd->unix_name );
     }
+
+    if (do_esync())
+        close( fd->esync_fd );
 }
 
 /* check if the desired access is possible without violating */
@@ -1610,6 +1615,7 @@ static struct fd *alloc_fd_object(void)
     fd->poll_index = -1;
     fd->completion = NULL;
     fd->comp_flags = 0;
+    fd->esync_fd   = -1;
     init_async_queue( &fd->read_q );
     init_async_queue( &fd->write_q );
     init_async_queue( &fd->wait_q );
@@ -1647,11 +1653,15 @@ struct fd *alloc_pseudo_fd( const struct fd_ops *fd_user_ops, struct object *use
     fd->completion = NULL;
     fd->comp_flags = 0;
     fd->no_fd_status = STATUS_BAD_DEVICE_TYPE;
+    fd->esync_fd   = -1;
     init_async_queue( &fd->read_q );
     init_async_queue( &fd->write_q );
     init_async_queue( &fd->wait_q );
     list_init( &fd->inode_entry );
     list_init( &fd->locks );
+
+    if (do_esync())
+        fd->esync_fd = esync_create_fd( 0, 0 );
     return fd;
 }
 
@@ -1971,6 +1981,9 @@ void set_fd_signaled( struct fd *fd, int signaled )
     if (fd->comp_flags & FILE_SKIP_SET_EVENT_ON_HANDLE) return;
     fd->signaled = signaled;
     if (signaled) wake_up( fd->user, 0 );
+
+    if (do_esync() && !signaled)
+        esync_clear( fd->esync_fd );
 }
 
 /* check if fd is signaled */
@@ -2008,6 +2021,15 @@ int default_fd_signaled( struct object *obj, struct wait_queue_entry *entry )
     return ret;
 }
 
+int default_fd_get_esync_fd( struct object *obj, enum esync_type *type )
+{
+    struct fd *fd = get_obj_fd( obj );
+    int ret = fd->esync_fd;
+    *type = ESYNC_MANUAL_SERVER;
+    release_object( fd );
+    return ret;
+}
+
 /* default map_access() routine for objects that behave like an fd */
 unsigned int default_fd_map_access( struct object *obj, unsigned int access )
 {
diff --git a/server/file.h b/server/file.h
index 6b67866d3f..5ad7122b5a 100644
--- a/server/file.h
+++ b/server/file.h
@@ -103,6 +103,7 @@ extern int is_fd_signaled( struct fd *fd );
 extern char *dup_fd_name( struct fd *root, const char *name );
 
 extern int default_fd_signaled( struct object *obj, struct wait_queue_entry *entry );
+extern int default_fd_get_esync_fd( struct object *obj, enum esync_type *type );
 extern unsigned int default_fd_map_access( struct object *obj, unsigned int access );
 extern int default_fd_get_poll_events( struct fd *fd );
 extern void default_poll_event( struct fd *fd, int event );
diff --git a/server/named_pipe.c b/server/named_pipe.c
index b279e5661f..39bd9544f6 100644
--- a/server/named_pipe.c
+++ b/server/named_pipe.c
@@ -161,7 +161,7 @@ static const struct object_ops pipe_server_ops =
     add_queue,                    /* add_queue */
     remove_queue,                 /* remove_queue */
     default_fd_signaled,          /* signaled */
-    NULL,                         /* get_esync_fd */
+    default_fd_get_esync_fd,      /* get_esync_fd */
     no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     pipe_end_get_fd,              /* get_fd */
@@ -203,7 +203,7 @@ static const struct object_ops pipe_client_ops =
     add_queue,                    /* add_queue */
     remove_queue,                 /* remove_queue */
     default_fd_signaled,          /* signaled */
-    NULL,                         /* get_esync_fd */
+    default_fd_get_esync_fd,      /* get_esync_fd */
     no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     pipe_end_get_fd,              /* get_fd */
-- 
2.20.1


From 0306a819c5675aaa2481d2982c72dfd0db8bb35f Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 7 Jul 2018 15:10:53 +0200
Subject: [PATCH 65/83] ntdll: Cache the esync struct itself instead of a
 pointer to it.

Now that the esync object has a constant size, we can perform this
optimization.
---
 dlls/ntdll/esync.c | 70 ++++++++++++++++------------------------------
 1 file changed, 24 insertions(+), 46 deletions(-)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index e10f0ea4bf..b856de231e 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -156,11 +156,11 @@ static void *get_shm( unsigned int idx )
 /* We'd like lookup to be fast. To that end, we use a static list indexed by handle.
  * This is copied and adapted from the fd cache code. */
 
-#define ESYNC_LIST_BLOCK_SIZE  (65536 / sizeof(struct esync *))
-#define ESYNC_LIST_ENTRIES     128
+#define ESYNC_LIST_BLOCK_SIZE  (65536 / sizeof(struct esync))
+#define ESYNC_LIST_ENTRIES     256
 
-static struct esync * *esync_list[ESYNC_LIST_ENTRIES];
-static struct esync * esync_list_initial_block[ESYNC_LIST_BLOCK_SIZE];
+static struct esync *esync_list[ESYNC_LIST_ENTRIES];
+static struct esync esync_list_initial_block[ESYNC_LIST_BLOCK_SIZE];
 
 static inline UINT_PTR handle_to_index( HANDLE handle, UINT_PTR *entry )
 {
@@ -169,7 +169,7 @@ static inline UINT_PTR handle_to_index( HANDLE handle, UINT_PTR *entry )
     return idx % ESYNC_LIST_BLOCK_SIZE;
 }
 
-static BOOL add_to_list( HANDLE handle, struct esync *obj )
+static struct esync *add_to_list( HANDLE handle, enum esync_type type, int fd, void *shm )
 {
     UINT_PTR entry, idx = handle_to_index( handle, &entry );
 
@@ -191,9 +191,12 @@ static BOOL add_to_list( HANDLE handle, struct esync *obj )
         }
     }
 
-    obj = interlocked_xchg_ptr((void **)&esync_list[entry][idx], obj);
-    assert(!obj);
-    return TRUE;
+    if (!interlocked_cmpxchg((int *)&esync_list[entry][idx].type, type, 0))
+    {
+        esync_list[entry][idx].fd = fd;
+        esync_list[entry][idx].shm = shm;
+    }
+    return &esync_list[entry][idx];
 }
 
 static struct esync *get_cached_object( HANDLE handle )
@@ -201,8 +204,9 @@ static struct esync *get_cached_object( HANDLE handle )
     UINT_PTR entry, idx = handle_to_index( handle, &entry );
 
     if (entry >= ESYNC_LIST_ENTRIES || !esync_list[entry]) return NULL;
+    if (!esync_list[entry][idx].type) return NULL;
 
-    return esync_list[entry][idx];
+    return &esync_list[entry][idx];
 }
 
 /* Gets an object. This is either a proper esync object (i.e. an event,
@@ -214,19 +218,18 @@ static struct esync *get_cached_object( HANDLE handle )
  * since we might be passed a duplicated or inherited handle. */
 static NTSTATUS get_object( HANDLE handle, struct esync **obj )
 {
+    NTSTATUS ret = STATUS_SUCCESS;
+    enum esync_type type = 0;
+    unsigned int shm_idx = 0;
     obj_handle_t fd_handle;
-    enum esync_type type;
-    unsigned int shm_idx;
-    struct esync *esync;
     sigset_t sigset;
-    NTSTATUS ret;
-    int fd;
+    int fd = -1;
 
     if ((*obj = get_cached_object( handle ))) return STATUS_SUCCESS;
 
     /* We need to try grabbing it from the server. */
     server_enter_uninterrupted_section( &fd_cache_section, &sigset );
-    if (!(esync = get_cached_object( handle )))
+    if (!(*obj = get_cached_object( handle )))
     {
         SERVER_START_REQ( get_esync_fd )
         {
@@ -243,10 +246,9 @@ static NTSTATUS get_object( HANDLE handle, struct esync **obj )
     }
     server_leave_uninterrupted_section( &fd_cache_section, &sigset );
 
-    if (esync)
+    if (*obj)
     {
         /* We managed to grab it while in the CS; return it. */
-        *obj = esync;
         return STATUS_SUCCESS;
     }
 
@@ -259,31 +261,21 @@ static NTSTATUS get_object( HANDLE handle, struct esync **obj )
 
     TRACE("Got fd %d for handle %p.\n", fd, handle);
 
-    esync = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*esync) );
-    esync->fd = fd;
-    esync->type = type;
-
-    esync->shm = shm_idx ? get_shm( shm_idx ) : 0;
-
-    add_to_list( handle, esync );
-
-    *obj = esync;
+    *obj = add_to_list( handle, type, fd, shm_idx ? get_shm( shm_idx ) : 0 );
     return ret;
 }
 
 NTSTATUS esync_close( HANDLE handle )
 {
     UINT_PTR entry, idx = handle_to_index( handle, &entry );
-    struct esync *obj;
 
     TRACE("%p.\n", handle);
 
     if (entry < ESYNC_LIST_ENTRIES && esync_list[entry])
     {
-        if ((obj = interlocked_xchg_ptr( (void **)&esync_list[entry][idx], 0 )))
+        if (interlocked_xchg((int *)&esync_list[entry][idx].type, 0))
         {
-            close( obj->fd );
-            RtlFreeHeap( GetProcessHeap(), 0, obj );
+            close( esync_list[entry][idx].fd );
             return STATUS_SUCCESS;
         }
     }
@@ -329,14 +321,7 @@ static NTSTATUS create_esync( enum esync_type type, HANDLE *handle,
 
     if (!ret || ret == STATUS_OBJECT_NAME_EXISTS)
     {
-        struct esync *obj = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*obj) );
-        if (!obj) return STATUS_NO_MEMORY;
-
-        obj->type = type;
-        obj->fd = fd;
-        obj->shm = shm_idx ? get_shm( shm_idx ) : 0;
-
-        add_to_list( *handle, obj );
+        add_to_list( *handle, type, fd, shm_idx ? get_shm( shm_idx ) : 0 );
 
         TRACE("-> handle %p, fd %d, shm index %d.\n", *handle, fd, shm_idx);
     }
@@ -377,14 +362,7 @@ static NTSTATUS open_esync( enum esync_type type, HANDLE *handle,
 
     if (!ret)
     {
-        struct esync *obj = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*obj) );
-        if (!obj) return STATUS_NO_MEMORY;
-
-        obj->type = type;
-        obj->fd = fd;
-        obj->shm = shm_idx ? get_shm( shm_idx ) : 0;
-
-        add_to_list( *handle, obj );
+        add_to_list( *handle, type, fd, shm_idx ? get_shm( shm_idx ) : 0 );
 
         TRACE("-> handle %p, fd %d.\n", *handle, fd);
     }
-- 
2.20.1


From cdc1e15eb6672bfb78d15b194904e523b7c028aa Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 4 Jul 2018 14:58:33 +0200
Subject: [PATCH 66/83] esync: Update README.

---
 README.esync | 25 +++++++++++++++++++++++--
 1 file changed, 23 insertions(+), 2 deletions(-)

diff --git a/README.esync b/README.esync
index 627cc3f481..30e241755a 100644
--- a/README.esync
+++ b/README.esync
@@ -2,6 +2,29 @@ This is eventfd-based synchronization, or 'esync' for short. Turn it on with
 WINEESYNC=1 (note that it checks the presence and not the value); debug it
 with +esync.
 
+== BUGS AND LIMITATIONS ==
+
+Please let me know if you find any bugs. If you can, also attach a log with
++seh,+pid,+esync,+server.
+
+If you get something like "eventfd: Too many open files" and then things start
+crashing, you've probably run out of file descriptors. esync creates one
+eventfd descriptor for each synchronization object, and some games may use a
+large number of these.  Linux by default limits a process to 4096 file
+descriptors, which probably was reasonable back in the nineties but isn't
+really anymore. (Fortunately Debian and derivatives [Ubuntu, Mint] already
+have a reasonable limit.) To raise the limit you'll want to edit
+/etc/security/limits.conf and add a line like
+
+* hard nofile 1048576
+
+then restart your session.
+
+Also note that if the wineserver has esync active, all clients also must, and
+vice versa. Otherwise things will probably crash quite badly.
+
+== EXPLANATION ==
+
 The aim is to execute all synchronization operations in "user-space", that is,
 without going through wineserver. We do this using Linux's eventfd
 facility. The main impetus to using eventfd is so that we can poll multiple
@@ -135,8 +158,6 @@ surprisingly there aren't that many. In particular:
 
 There are some things that are perfectly implementable but that I just haven't
 done yet:
-* NtQuery*. That said, these APIs aren't exposed through kernel32 in any way, so
-  I doubt anyone is going to be using them.
 * Other synchronizable server primitives. It's unlikely we'll need any of
   these, except perhaps named pipes (which would honestly be rather difficult)
   and (maybe) timers.
-- 
2.20.1


From cd8d82054f21455f1023ce96b768b93b47eac16a Mon Sep 17 00:00:00 2001
From: Mathieu Comandon <strycore@gmail.com>
Date: Sat, 21 Jul 2018 12:56:50 -0700
Subject: [PATCH 67/83] esync: Add note about file limits not being raised when
 using systemd.

---
 README.esync | 12 +++++++++++-
 1 file changed, 11 insertions(+), 1 deletion(-)

diff --git a/README.esync b/README.esync
index 30e241755a..7706f395eb 100644
--- a/README.esync
+++ b/README.esync
@@ -20,6 +20,16 @@ have a reasonable limit.) To raise the limit you'll want to edit
 
 then restart your session.
 
+On distributions using systemd, the settings in `/etc/security/limits.conf` will
+be overridden by systemd's own settings. If you run `ulimit -Hn` and it returns
+a lower number than the one you've previously set then you can set
+
+DefaultLimitNOFILE=100000
+
+in both `/etc/systemd/system.conf` and `/etc/systemd/user.conf`. You can then
+execute `sudo systemctl daemon-reexec` and restart your session. Check again
+with `ulimit -Hn` that the limit is correct.
+
 Also note that if the wineserver has esync active, all clients also must, and
 vice versa. Otherwise things will probably crash quite badly.
 
@@ -188,4 +198,4 @@ done by the kernel.
 
 Anyway, yeah, this is esync. Use it if you like.
 
---Zebediah Figura
\ No newline at end of file
+--Zebediah Figura
-- 
2.20.1


From 4c9bbbf1ee628160e4f57d50416feafd6f821376 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 26 Jul 2018 15:00:02 -0600
Subject: [PATCH 68/83] ntdll: Ignore pseudo-handles.

---
 dlls/ntdll/esync.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index b856de231e..54a792c838 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -227,6 +227,12 @@ static NTSTATUS get_object( HANDLE handle, struct esync **obj )
 
     if ((*obj = get_cached_object( handle ))) return STATUS_SUCCESS;
 
+    if ((INT_PTR)handle < 0)
+    {
+        /* We can deal with pseudo-handles, but it's just easier this way */
+        return STATUS_NOT_IMPLEMENTED;
+    }
+
     /* We need to try grabbing it from the server. */
     server_enter_uninterrupted_section( &fd_cache_section, &sigset );
     if (!(*obj = get_cached_object( handle )))
-- 
2.20.1


From 1236260bca6a0a9a05b3757a27ecda54e24a6d29 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 26 Jul 2018 10:01:54 -0600
Subject: [PATCH 69/83] ntdll: Try to avoid poll() for uncontended objects.

Just semaphores and mutexes thus far.

We don't have to worry about races because this is just a hint: we still call read() eventually.
---
 dlls/ntdll/esync.c | 60 ++++++++++++++++++++++++++++++++++++++--------
 1 file changed, 50 insertions(+), 10 deletions(-)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 54a792c838..90531279eb 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -850,23 +850,63 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
 
     if (wait_any || count == 1)
     {
+        /* Try to check objects now, so we can obviate poll() at least. */
         for (i = 0; i < count; i++)
         {
             struct esync *obj = objs[i];
 
-            if (obj && obj->type == ESYNC_MUTEX)
+            if (obj)
             {
-                /* If we already own the mutex, return immediately. */
-                /* Note: This violates the assumption that the *first* object
-                 * to be signaled will be returned. If that becomes a problem,
-                 * we can always check the state of each object before waiting. */
-                struct mutex *mutex = obj->shm;
+                switch (obj->type)
+                {
+                case ESYNC_MUTEX:
+                {
+                    struct mutex *mutex = obj->shm;
 
-                if (mutex->tid == GetCurrentThreadId())
+                    if (mutex->tid == GetCurrentThreadId())
+                    {
+                        TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                        mutex->count++;
+                        return i;
+                    }
+                    else if (!mutex->count)
+                    {
+                        if ((size = read( obj->fd, &value, sizeof(value) )) == sizeof(value))
+                        {
+                            TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                            mutex->tid = GetCurrentThreadId();
+                            mutex->count++;
+                            return i;
+                        }
+                    }
+                    break;
+                }
+                case ESYNC_SEMAPHORE:
                 {
-                    TRACE("Woken up by handle %p [%d].\n", handles[i], i);
-                    mutex->count++;
-                    return i;
+                    struct semaphore *semaphore = obj->shm;
+
+                    if (semaphore->count)
+                    {
+                        if ((size = read( obj->fd, &value, sizeof(value) )) == sizeof(value))
+                        {
+                            TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                            interlocked_xchg_add( &semaphore->count, -1 );
+                            return i;
+                        }
+                    }
+                    break;
+                }
+                case ESYNC_AUTO_EVENT:
+                case ESYNC_MANUAL_EVENT:
+                    /* TODO */
+                    break;
+                case ESYNC_AUTO_SERVER:
+                case ESYNC_MANUAL_SERVER:
+                case ESYNC_QUEUE:
+                    /* We can't wait on any of these. Fortunately I don't think
+                     * they'll ever be uncontended anyway (at least, they won't be
+                     * performance-critical). */
+                    break;
                 }
             }
 
-- 
2.20.1


From 71f7c596404754136926dbebf626601ef64e5644 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 26 Jul 2018 11:20:44 -0600
Subject: [PATCH 70/83] ntdll: Store an event's signaled state internally.

This was way harder than I thought it would be...
---
 dlls/ntdll/esync.c | 210 ++++++++++++++++++++++++++++++++++++---------
 server/esync.c     |  26 +++---
 2 files changed, 181 insertions(+), 55 deletions(-)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 90531279eb..8883b46bc9 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -92,12 +92,21 @@ struct semaphore
     int max;
     int count;
 };
+C_ASSERT(sizeof(struct semaphore) == 8);
 
 struct mutex
 {
     DWORD tid;
     int count;    /* recursion count */
 };
+C_ASSERT(sizeof(struct mutex) == 8);
+
+struct event
+{
+    int signaled;
+    int locked;
+};
+C_ASSERT(sizeof(struct event) == 8);
 
 static char shm_name[29];
 static int shm_fd;
@@ -395,7 +404,7 @@ NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
     /* We need this lock to protect against a potential (though unlikely) race:
      * if a different process tries to open a named object and manages to use
      * it between the time we get back from the server and the time we
-     * initialize the shared memory, it'll have uninitialize values for the
+     * initialize the shared memory, it'll have uninitialized values for the
      * object's state. That requires us to be REALLY slow, but we're not taking
      * any chances. Synchronize on the CS here so that we're sure to be ready
      * before anyone else can open the object. */
@@ -494,34 +503,121 @@ NTSTATUS esync_create_event( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, EVENT_TYPE event_type, BOOLEAN initial )
 {
     enum esync_type type = (event_type == SynchronizationEvent ? ESYNC_AUTO_EVENT : ESYNC_MANUAL_EVENT);
+    NTSTATUS ret;
 
     TRACE("name %s, %s-reset, initial %d.\n",
         attr ? debugstr_us(attr->ObjectName) : "<no name>",
         event_type == NotificationEvent ? "manual" : "auto", initial);
 
-    return create_esync( type, handle, access, attr, initial, 0 );
+    RtlEnterCriticalSection( &shm_init_section );
+
+    ret = create_esync( type, handle, access, attr, initial, 0 );
+
+    if (!ret)
+    {
+        /* Initialize the shared memory portion. */
+        struct esync *obj = get_cached_object( *handle );
+        struct event *event = obj->shm;
+        event->signaled = initial;
+        event->locked = 0;
+    }
+
+    RtlLeaveCriticalSection( &shm_init_section );
+
+    return ret;
 }
 
 NTSTATUS esync_open_event( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr )
 {
+    NTSTATUS ret;
+
     TRACE("name %s.\n", debugstr_us(attr->ObjectName));
 
-    return open_esync( ESYNC_AUTO_EVENT, handle, access, attr ); /* doesn't matter which */
+    RtlEnterCriticalSection( &shm_init_section );
+    ret = open_esync( ESYNC_AUTO_EVENT, handle, access, attr ); /* doesn't matter which */
+    RtlLeaveCriticalSection( &shm_init_section );
+    return ret;
+}
+
+static inline void small_pause(void)
+{
+#ifdef __i386__
+    __asm__ __volatile__( "rep;nop" : : : "memory" );
+#else
+    __asm__ __volatile__( "" : : : "memory" );
+#endif
 }
 
+/* Manual-reset events are actually racier than other objects in terms of shm
+ * state. With other objects, races don't matter, because we only treat the shm
+ * state as a hint that lets us skip poll()we still have to read(). But with
+ * manual-reset events we don't, which means that the shm state can be out of
+ * sync with the actual state.
+ *
+ * In general we shouldn't have to worry about races between modifying the
+ * event and waiting on it. If the state changes while we're waiting, it's
+ * equally plausible that we caught it before or after the state changed.
+ * However, we can have races between SetEvent() and ResetEvent(), so that the
+ * event has inconsistent internal state.
+ *
+ * To solve this we have to use the other field to lock the event. Currently
+ * this is implemented as a spinlock, but I'm not sure if a futex might be
+ * better. I'm also not sure if it's possible to obviate locking by arranging
+ * writes and reads in a certain way.
+ *
+ * Note that we don't have to worry about locking in esync_wait_objects().
+ * There's only two general patterns:
+ *
+ * WaitFor()    SetEvent()
+ * -------------------------
+ * read()
+ * signaled = 0
+ *              signaled = 1
+ *              write()
+ * -------------------------
+ * read()
+ *              signaled = 1
+ * signaled = 0
+ *              <no write(), because it was already signaled>
+ * -------------------------
+ *
+ * That is, if SetEvent() tries to signal the event before WaitFor() resets its
+ * signaled state, it won't bother trying to write(), and then the signaled
+ * state will be reset, so the result is a consistent non-signaled event.
+ * There's several variations to this pattern but all of them are protected in
+ * the same way. Note however this is why we have to use interlocked_xchg()
+ * event inside of the lock.
+ *
+ * And of course if SetEvent() follows WaitFor() entirely, well, there's no
+ * problem at all.
+ */
+
 NTSTATUS esync_set_event( HANDLE handle )
 {
     static const uint64_t value = 1;
     struct esync *obj;
+    struct event *event;
     NTSTATUS ret;
 
     TRACE("%p.\n", handle);
 
     if ((ret = get_object( handle, &obj ))) return ret;
+    event = obj->shm;
 
-    if (write( obj->fd, &value, sizeof(value) ) == -1)
-        return FILE_GetNtStatus();
+    /* Acquire the spinlock. */
+    while (interlocked_cmpxchg( &event->locked, 1, 0 ))
+        small_pause();
+
+    /* Only bother signaling the fd if we weren't already signaled. */
+    if (!interlocked_xchg( &event->signaled, 1 ))
+    {
+        if (write( obj->fd, &value, sizeof(value) ) == -1)
+            return FILE_GetNtStatus();
+    }
+
+    /* Release the spinlock. */
+    event->locked = 0;
 
     return STATUS_SUCCESS;
 }
@@ -530,14 +626,27 @@ NTSTATUS esync_reset_event( HANDLE handle )
 {
     static uint64_t value;
     struct esync *obj;
+    struct event *event;
     NTSTATUS ret;
 
     TRACE("%p.\n", handle);
 
     if ((ret = get_object( handle, &obj ))) return ret;
+    event = obj->shm;
 
-    /* we don't care about the return value */
-    read( obj->fd, &value, sizeof(value) );
+    /* Acquire the spinlock. */
+    while (interlocked_cmpxchg( &event->locked, 1, 0 ))
+        small_pause();
+
+    /* Only bother signaling the fd if we weren't already signaled. */
+    if (interlocked_xchg( &event->signaled, 0 ))
+    {
+        /* we don't care about the return value */
+        read( obj->fd, &value, sizeof(value) );
+    }
+
+    /* Release the spinlock. */
+    event->locked = 0;
 
     return STATUS_SUCCESS;
 }
@@ -732,6 +841,35 @@ static int do_poll( struct pollfd *fds, nfds_t nfds, ULONGLONG *end )
     return ret;
 }
 
+static void update_grabbed_object( struct esync *obj )
+{
+    if (obj->type == ESYNC_MUTEX)
+    {
+        struct mutex *mutex = obj->shm;
+        /* We don't have to worry about a race between this and read(); the
+         * fact that we grabbed it means the count is now zero, so nobody else
+         * can (and the only thread that can release it is us). */
+        mutex->tid = GetCurrentThreadId();
+        mutex->count++;
+    }
+    else if (obj->type == ESYNC_SEMAPHORE)
+    {
+        struct semaphore *semaphore = obj->shm;
+        /* We don't have to worry about a race between this and read(); the
+         * fact that we were able to grab it at all means the count is nonzero,
+         * and if someone else grabbed it then the count must have been >= 2,
+         * etc. */
+        interlocked_xchg_add( &semaphore->count, -1 );
+    }
+    else if (obj->type == ESYNC_AUTO_EVENT)
+    {
+        struct event *event = obj->shm;
+        /* We don't have to worry about a race between this and read(), for
+         * reasons described near esync_set_event(). */
+        event->signaled = 0;
+    }
+}
+
 /* A value of STATUS_NOT_IMPLEMENTED returned from this function means that we
  * need to delegate to server_select(). */
 NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
@@ -897,9 +1035,30 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
                     break;
                 }
                 case ESYNC_AUTO_EVENT:
+                {
+                    struct event *event = obj->shm;
+
+                    if (event->signaled)
+                    {
+                        if ((size = read( obj->fd, &value, sizeof(value) )) == sizeof(value))
+                        {
+                            TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                            event->signaled = 0;
+                            return i;
+                        }
+                    }
+                }
                 case ESYNC_MANUAL_EVENT:
-                    /* TODO */
+                {
+                    struct event *event = obj->shm;
+
+                    if (event->signaled)
+                    {
+                        TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                        return i;
+                    }
                     break;
+                }
                 case ESYNC_AUTO_SERVER:
                 case ESYNC_MANUAL_SERVER:
                 case ESYNC_QUEUE:
@@ -960,25 +1119,7 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
                             {
                                 /* We found our object. */
                                 TRACE("Woken up by handle %p [%d].\n", handles[i], i);
-                                if (obj->type == ESYNC_MUTEX)
-                                {
-                                    struct mutex *mutex = obj->shm;
-                                    /* We don't have to worry about a race between this and read();
-                                     * the fact that we grabbed it means the count is now zero,
-                                     * so nobody else can (and the only thread that can release
-                                     * it is us). */
-                                    mutex->tid = GetCurrentThreadId();
-                                    mutex->count = 1;
-                                }
-                                else if (obj->type == ESYNC_SEMAPHORE)
-                                {
-                                    struct semaphore *semaphore = obj->shm;
-                                    /* We don't have to worry about a race between this and read();
-                                     * the fact that we were able to grab it at all means the count
-                                     * is nonzero, and if someone else grabbed it then the count
-                                     * must have been >= 2, etc. */
-                                    interlocked_xchg_add( &semaphore->count, -1 );
-                                }
+                                update_grabbed_object( obj );
                                 return i;
                             }
                         }
@@ -1142,19 +1283,8 @@ tryagain:
                 /* Make sure to let ourselves know that we grabbed the mutexes
                  * and semaphores. */
                 for (i = 0; i < count; i++)
-                {
-                    if (objs[i]->type == ESYNC_MUTEX)
-                    {
-                        struct mutex *mutex = objs[i]->shm;
-                        mutex->tid = GetCurrentThreadId();
-                        mutex->count++;
-                    }
-                    else if (objs[i]->type == ESYNC_SEMAPHORE)
-                    {
-                        struct semaphore *semaphore = objs[i]->shm;
-                        interlocked_xchg_add( &semaphore->count, -1 );
-                    }
-                }
+                    update_grabbed_object( objs[i] );
+
                 TRACE("Wait successful.\n");
                 return STATUS_SUCCESS;
             }
diff --git a/server/esync.c b/server/esync.c
index 5cf4bddbb0..f1fa923cca 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -190,25 +190,21 @@ static struct esync *create_esync( struct object *root, const struct unicode_str
                 return NULL;
             }
             esync->type = type;
-            if (type == ESYNC_SEMAPHORE || type == ESYNC_MUTEX)
+
+            /* Use the fd as index, since that'll be unique across all
+             * processes, but should hopefully end up also allowing reuse. */
+            esync->shm_idx = esync->fd + 1; /* we keep index 0 reserved */
+            while (esync->shm_idx * 8 >= shm_size)
             {
-                /* Use the fd as index, since that'll be unique across all
-                 * processes, but should hopefully end up also allowing reuse. */
-                esync->shm_idx = esync->fd + 1; /* we keep index 0 reserved */
-                while (esync->shm_idx * 8 >= shm_size)
+                /* Better expand the shm section. */
+                shm_size += sysconf( _SC_PAGESIZE );
+                if (ftruncate( shm_fd, shm_size ) == -1)
                 {
-                    /* Better expand the shm section. */
-                    shm_size += sysconf( _SC_PAGESIZE );
-                    if (ftruncate( shm_fd, shm_size ) == -1)
-                    {
-                        fprintf( stderr, "esync: couldn't expand %s to size %ld: ",
-                            shm_name, shm_size );
-                        perror( "ftruncate" );
-                    }
+                    fprintf( stderr, "esync: couldn't expand %s to size %ld: ",
+                        shm_name, shm_size );
+                    perror( "ftruncate" );
                 }
             }
-            else
-                esync->shm_idx = 0;
         }
         else
         {
-- 
2.20.1


From 75e14fd823941ac460fc0452a597dedf9b3ced05 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 28 Jul 2018 12:09:40 -0500
Subject: [PATCH 71/83] ntdll: Fix growing the shm_addrs array.

Fixes an issue exposed by the last patch and visible in GTA V. Presumably
this didn't show up earlier because applications usually don't create large
numbers of semaphores or mutexes, and previously events didn't use shared
memory.
---
 dlls/ntdll/esync.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 8883b46bc9..882031c6ef 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -142,8 +142,9 @@ static void *get_shm( unsigned int idx )
 
     if (entry >= shm_addrs_size)
     {
-        shm_addrs_size *= 2;
-        if (!(shm_addrs = RtlReAllocateHeap( GetProcessHeap(), HEAP_ZERO_MEMORY, shm_addrs, shm_addrs_size )))
+        shm_addrs_size = entry + 1;
+        if (!(shm_addrs = RtlReAllocateHeap( GetProcessHeap(), HEAP_ZERO_MEMORY,
+                shm_addrs, shm_addrs_size * sizeof(shm_addrs[0]) )))
             ERR("Failed to grow shm_addrs array to size %d.\n", shm_addrs_size);
     }
 
-- 
2.20.1


From 6d2cc8afd0a86f2d428335b48a7ff39f9e137502 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 29 Jul 2018 13:36:42 -0500
Subject: [PATCH 72/83] server: Update the shared memory state when (re)setting
 an event.

---
 server/esync.c | 104 ++++++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 98 insertions(+), 6 deletions(-)

diff --git a/server/esync.c b/server/esync.c
index f1fa923cca..a0745a2306 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -63,6 +63,9 @@ int do_esync(void)
 static char shm_name[29];
 static int shm_fd;
 static off_t shm_size;
+static void **shm_addrs;
+static int shm_addrs_size;  /* length of the allocated shm_addrs array */
+static long pagesize;
 
 static void shm_cleanup(void)
 {
@@ -89,7 +92,12 @@ void esync_init(void)
     if (shm_fd == -1)
         perror( "shm_open" );
 
-    shm_size = sysconf( _SC_PAGESIZE );
+    pagesize = sysconf( _SC_PAGESIZE );
+
+    shm_addrs = calloc( 128, sizeof(shm_addrs[0]) );
+    shm_addrs_size = 128;
+
+    shm_size = pagesize;
     if (ftruncate( shm_fd, shm_size ) == -1)
         perror( "ftruncate" );
 
@@ -197,7 +205,7 @@ static struct esync *create_esync( struct object *root, const struct unicode_str
             while (esync->shm_idx * 8 >= shm_size)
             {
                 /* Better expand the shm section. */
-                shm_size += sysconf( _SC_PAGESIZE );
+                shm_size += pagesize;
                 if (ftruncate( shm_fd, shm_size ) == -1)
                 {
                     fprintf( stderr, "esync: couldn't expand %s to size %ld: ",
@@ -273,24 +281,108 @@ void esync_clear( int fd )
     read( fd, &value, sizeof(value) );
 }
 
+/* Sadly, we need all of this infrastructure to keep the shm state in sync. */
+
+static void *get_shm( unsigned int idx )
+{
+    int entry  = (idx * 8) / pagesize;
+    int offset = (idx * 8) % pagesize;
+
+    if (entry >= shm_addrs_size)
+    {
+        if (!(shm_addrs = realloc( shm_addrs, (entry + 1) * sizeof(shm_addrs[0]) )))
+            fprintf( stderr, "esync: couldn't expand shm_addrs array to size %d\n", entry + 1 );
+
+        memset( &shm_addrs[shm_addrs_size], 0, (entry + 1 - shm_addrs_size) * sizeof(shm_addrs[0]) );
+
+        shm_addrs_size = entry + 1;
+    }
+
+    if (!shm_addrs[entry])
+    {
+        void *addr = mmap( NULL, pagesize, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, entry * pagesize );
+        if (addr == (void *)-1)
+        {
+            fprintf( stderr, "esync: failed to map page %d (offset %#lx): ", entry, entry * pagesize );
+            perror( "mmap" );
+        }
+
+        if (debug_level)
+            fprintf( stderr, "esync: Mapping page %d at %p.\n", entry, addr );
+
+        if (interlocked_cmpxchg_ptr( &shm_addrs[entry], addr, 0 ))
+            munmap( addr, pagesize ); /* someone beat us to it */
+    }
+
+    return (void *)((unsigned long)shm_addrs[entry] + offset);
+}
+
+struct event
+{
+    int signaled;
+    int locked;
+};
+C_ASSERT(sizeof(struct event) == 8);
+
+static inline void small_pause(void)
+{
+#ifdef __i386__
+    __asm__ __volatile__( "rep;nop" : : : "memory" );
+#else
+    __asm__ __volatile__( "" : : : "memory" );
+#endif
+}
+
 /* Server-side event support. */
 void esync_set_event( struct esync *esync )
 {
     static const uint64_t value = 1;
+    struct event *event = get_shm( esync->shm_idx );
 
     assert( esync->obj.ops == &esync_ops );
-    if (write( esync->fd, &value, sizeof(value) ) == -1)
-        perror( "esync: write" );
+    assert( event != NULL );
+
+    if (debug_level)
+        fprintf( stderr, "esync_set_event() fd=%d\n", esync->fd );
+
+    /* Acquire the spinlock. */
+    while (interlocked_cmpxchg( &event->locked, 1, 0 ))
+        small_pause();
+
+    if (!interlocked_xchg( &event->signaled, 1 ))
+    {
+        if (write( esync->fd, &value, sizeof(value) ) == -1)
+            perror( "esync: write" );
+    }
+
+    /* Release the spinlock. */
+    event->locked = 0;
 }
 
 void esync_reset_event( struct esync *esync )
 {
     static uint64_t value = 1;
+    struct event *event = get_shm( esync->shm_idx );
 
     assert( esync->obj.ops == &esync_ops );
+    assert( event != NULL );
 
-    /* we don't care about the return value */
-    read( esync->fd, &value, sizeof(value) );
+    if (debug_level)
+        fprintf( stderr, "esync_reset_event() fd=%d\n", esync->fd );
+
+    /* Acquire the spinlock. */
+    while (interlocked_cmpxchg( &event->locked, 1, 0 ))
+        small_pause();
+
+    /* Only bother signaling the fd if we weren't already signaled. */
+    if (interlocked_xchg( &event->signaled, 0 ))
+    {
+        /* we don't care about the return value */
+        read( esync->fd, &value, sizeof(value) );
+    }
+
+    /* Release the spinlock. */
+    event->locked = 0;
 }
 
 DECL_HANDLER(create_esync)
-- 
2.20.1


From 85b02a78960e55512c782335ce20ba6744b7dfdd Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Tue, 31 Jul 2018 11:54:39 -0500
Subject: [PATCH 73/83] ntdll: Fix a missing break statement.

Should fix #2, #3, #6.
---
 dlls/ntdll/esync.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 882031c6ef..32cb68ad9b 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -1048,6 +1048,7 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
                             return i;
                         }
                     }
+                    break;
                 }
                 case ESYNC_MANUAL_EVENT:
                 {
-- 
2.20.1


From 99fd2f443f6386afc2ad89d3828419a36a9c06cc Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 4 Aug 2018 15:15:12 -0500
Subject: [PATCH 74/83] ntdll, server: Abort if esync is enabled for the server
 but not the client, and vice versa.

---
 dlls/ntdll/esync.c  | 28 +++++++++++++++++++++++++++-
 dlls/ntdll/thread.c |  3 +--
 server/esync.c      | 12 ++++++++++++
 3 files changed, 40 insertions(+), 3 deletions(-)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 32cb68ad9b..4d3e29490d 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -114,10 +114,29 @@ static void **shm_addrs;
 static int shm_addrs_size;  /* length of the allocated shm_addrs array */
 static long pagesize;
 
+static NTSTATUS create_esync( enum esync_type type, HANDLE *handle,
+    ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr, int initval, int flags );
+
 void esync_init(void)
 {
     struct stat st;
 
+    if (!do_esync())
+    {
+        /* make sure the server isn't running with WINEESYNC */
+        HANDLE handle;
+        NTSTATUS ret;
+
+        ret = create_esync( 0, &handle, 0, NULL, 0, 0 );
+        if (ret != STATUS_NOT_IMPLEMENTED)
+        {
+            ERR("Server is running with WINEESYNC but this process is not, please enable WINEESYNC or restart wineserver.\n");
+            exit(1);
+        }
+
+        return;
+    }
+
     if (stat( wine_get_config_dir(), &st ) == -1)
         ERR("Cannot stat %s\n", wine_get_config_dir());
 
@@ -127,7 +146,14 @@ void esync_init(void)
         sprintf( shm_name, "/wine-%lx-esync", (unsigned long)st.st_ino );
 
     if ((shm_fd = shm_open( shm_name, O_RDWR, 0644 )) == -1)
-        ERR("Failed to initialize shared memory: %s\n", strerror( errno ));
+    {
+        /* probably the server isn't running with WINEESYNC, tell the user and bail */
+        if (errno == ENOENT)
+            ERR("Failed to open esync shared memory file; make sure no stale wineserver instances are running without WINEESYNC.\n");
+        else
+            ERR("Failed to initialize shared memory: %s\n", strerror( errno ));
+        exit(1);
+    }
 
     pagesize = sysconf( _SC_PAGESIZE );
 
diff --git a/dlls/ntdll/thread.c b/dlls/ntdll/thread.c
index f6c3ef8783..0154e2a973 100644
--- a/dlls/ntdll/thread.c
+++ b/dlls/ntdll/thread.c
@@ -267,8 +267,7 @@ void thread_init(void)
 
     fill_cpu_info();
 
-    if (do_esync())
-        esync_init();
+    esync_init();
 
     NtCreateKeyedEvent( &keyed_event, GENERIC_READ | GENERIC_WRITE, NULL, 0 );
 }
diff --git a/server/esync.c b/server/esync.c
index a0745a2306..10001a243b 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -393,6 +393,18 @@ DECL_HANDLER(create_esync)
     const struct security_descriptor *sd;
     const struct object_attributes *objattr = get_req_object_attributes( &sd, &name, &root );
 
+    if (!do_esync())
+    {
+        set_error( STATUS_NOT_IMPLEMENTED );
+        return;
+    }
+
+    if (!req->type)
+    {
+        set_error( STATUS_INVALID_PARAMETER_4 );
+        return;
+    }
+
     if (!objattr) return;
 
     if ((esync = create_esync( root, &name, objattr->attributes, req->initval, req->flags, req->type, sd )))
-- 
2.20.1


From ae8cbeeef7a44023b1b1e6c6b7b1aad0e1dff28f Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 4 Aug 2018 15:18:24 -0500
Subject: [PATCH 75/83] esync: Update README.

---
 README.esync | 14 +++++---------
 1 file changed, 5 insertions(+), 9 deletions(-)

diff --git a/README.esync b/README.esync
index 7706f395eb..b64bfefc1a 100644
--- a/README.esync
+++ b/README.esync
@@ -5,7 +5,7 @@ with +esync.
 == BUGS AND LIMITATIONS ==
 
 Please let me know if you find any bugs. If you can, also attach a log with
-+seh,+pid,+esync,+server.
++seh,+pid,+esync,+server,+timestamp.
 
 If you get something like "eventfd: Too many open files" and then things start
 crashing, you've probably run out of file descriptors. esync creates one
@@ -20,11 +20,11 @@ have a reasonable limit.) To raise the limit you'll want to edit
 
 then restart your session.
 
-On distributions using systemd, the settings in `/etc/security/limits.conf` will
-be overridden by systemd's own settings. If you run `ulimit -Hn` and it returns
-a lower number than the one you've previously set then you can set
+On distributions using systemd, the settings in `/etc/security/limits.conf`
+will be overridden by systemd's own settings. If you run `ulimit -Hn` and it
+returns a lower number than the one you've previously set, then you can set
 
-DefaultLimitNOFILE=100000
+DefaultLimitNOFILE=1048576
 
 in both `/etc/systemd/system.conf` and `/etc/systemd/user.conf`. You can then
 execute `sudo systemctl daemon-reexec` and restart your session. Check again
@@ -157,10 +157,6 @@ surprisingly there aren't that many. In particular:
   can probably be something reasonable.) It's also possible, although I
   haven't yet looked, to use some different kind of synchronization
   primitives, but pipes would be easiest to tack onto this framework.
-* We might hit the maximum number of open fd's. On my system the soft limit is
-  1024 and the hard limit is 1048576. I'm inclined to hope this won't be an
-  issue, since a hypothetical Linux port of any application might just as well
-  use the same number of eventfds.
 * PulseEvent() can't work the way it's supposed to work. Fortunately it's rare
   and deprecated. It's also explicitly mentioned on MSDN that a thread can
   miss the notification for a kernel APC, so in a sense we're not necessarily
-- 
2.20.1


From 4e6d48474212f91d891551dedcce13c61cba9b87 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 11 Aug 2018 10:45:43 -0500
Subject: [PATCH 76/83] ntdll: Correctly allocate the esync handle cache.

Fixes a regression introduced by 7b583a367ca05f961c1183a9647245ecd9f2160f.

Should hopefully fix #7.
---
 dlls/ntdll/esync.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 4d3e29490d..0bced88235 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -220,7 +220,7 @@ static struct esync *add_to_list( HANDLE handle, enum esync_type type, int fd, v
         if (!entry) esync_list[0] = esync_list_initial_block;
         else
         {
-            void *ptr = wine_anon_mmap( NULL, ESYNC_LIST_BLOCK_SIZE * sizeof(struct esync *),
+            void *ptr = wine_anon_mmap( NULL, ESYNC_LIST_BLOCK_SIZE * sizeof(struct esync),
                                         PROT_READ | PROT_WRITE, 0 );
             if (ptr == MAP_FAILED) return FALSE;
             esync_list[entry] = ptr;
-- 
2.20.1


From 379f1f4ac503f6bfe7146daf1c2e66310dd199f4 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 29 Jul 2018 16:53:58 -0500
Subject: [PATCH 77/83] ntdll, server: Specify EFD_SEMAPHORE on the server
 side.

This just makes things cleaner; since we already pass the type to the server
there's no reason to pass this as well.
---
 dlls/ntdll/esync.c             | 21 +++++++--------------
 include/wine/server_protocol.h |  4 +---
 server/esync.c                 | 11 ++++++++---
 server/protocol.def            |  1 -
 server/request.h               |  5 ++---
 server/trace.c                 |  1 -
 6 files changed, 18 insertions(+), 25 deletions(-)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 0bced88235..e3434e78f2 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -30,11 +30,9 @@
 # include <sys/poll.h>
 #endif
 #include <stdarg.h>
+#include <stdint.h>
 #include <stdlib.h>
 #include <stdio.h>
-#ifdef HAVE_SYS_EVENTFD_H
-# include <sys/eventfd.h>
-#endif
 #ifdef HAVE_SYS_MMAN_H
 # include <sys/mman.h>
 #endif
@@ -51,10 +49,6 @@
 #include "ntdll_misc.h"
 #include "esync.h"
 
-#ifndef EFD_SEMAPHORE
-#define EFD_SEMAPHORE 1
-#endif
-
 WINE_DEFAULT_DEBUG_CHANNEL(esync);
 
 int do_esync(void)
@@ -115,7 +109,7 @@ static int shm_addrs_size;  /* length of the allocated shm_addrs array */
 static long pagesize;
 
 static NTSTATUS create_esync( enum esync_type type, HANDLE *handle,
-    ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr, int initval, int flags );
+    ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr, int initval );
 
 void esync_init(void)
 {
@@ -127,7 +121,7 @@ void esync_init(void)
         HANDLE handle;
         NTSTATUS ret;
 
-        ret = create_esync( 0, &handle, 0, NULL, 0, 0 );
+        ret = create_esync( 0, &handle, 0, NULL, 0 );
         if (ret != STATUS_NOT_IMPLEMENTED)
         {
             ERR("Server is running with WINEESYNC but this process is not, please enable WINEESYNC or restart wineserver.\n");
@@ -326,7 +320,7 @@ NTSTATUS esync_close( HANDLE handle )
 }
 
 static NTSTATUS create_esync( enum esync_type type, HANDLE *handle,
-    ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr, int initval, int flags )
+    ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr, int initval )
 {
     NTSTATUS ret;
     data_size_t len;
@@ -345,7 +339,6 @@ static NTSTATUS create_esync( enum esync_type type, HANDLE *handle,
     {
         req->access  = access;
         req->initval = initval;
-        req->flags   = flags;
         req->type    = type;
         wine_server_add_data( req, objattr, len );
         ret = wine_server_call( req );
@@ -437,7 +430,7 @@ NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
      * before anyone else can open the object. */
     RtlEnterCriticalSection( &shm_init_section );
 
-    ret = create_esync( ESYNC_SEMAPHORE, handle, access, attr, initial, EFD_SEMAPHORE );
+    ret = create_esync( ESYNC_SEMAPHORE, handle, access, attr, initial );
     if (!ret)
     {
         /* Initialize the shared memory portion.
@@ -538,7 +531,7 @@ NTSTATUS esync_create_event( HANDLE *handle, ACCESS_MASK access,
 
     RtlEnterCriticalSection( &shm_init_section );
 
-    ret = create_esync( type, handle, access, attr, initial, 0 );
+    ret = create_esync( type, handle, access, attr, initial );
 
     if (!ret)
     {
@@ -735,7 +728,7 @@ NTSTATUS esync_create_mutex( HANDLE *handle, ACCESS_MASK access,
 
     RtlEnterCriticalSection( &shm_init_section );
 
-    ret = create_esync( ESYNC_MUTEX, handle, access, attr, initial ? 0 : 1, 0 );
+    ret = create_esync( ESYNC_MUTEX, handle, access, attr, initial ? 0 : 1 );
     if (!ret)
     {
         /* Initialize the shared memory portion. */
diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index a9c97f8110..c234015adc 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -5670,10 +5670,8 @@ struct create_esync_request
     struct request_header __header;
     unsigned int access;
     int          initval;
-    int          flags;
     int          type;
     /* VARARG(objattr,object_attributes); */
-    char __pad_28[4];
 };
 struct create_esync_reply
 {
@@ -6641,6 +6639,6 @@ union generic_reply
     struct get_esync_apc_fd_reply get_esync_apc_fd_reply;
 };
 
-#define SERVER_PROTOCOL_VERSION 574
+#define SERVER_PROTOCOL_VERSION 575
 
 #endif /* __WINE_WINE_SERVER_PROTOCOL_H */
diff --git a/server/esync.c b/server/esync.c
index 10001a243b..3e78387e88 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -178,7 +178,7 @@ static int type_matches( enum esync_type type1, enum esync_type type2 )
 }
 
 static struct esync *create_esync( struct object *root, const struct unicode_str *name,
-    unsigned int attr, int initval, int flags, enum esync_type type,
+    unsigned int attr, int initval, enum esync_type type,
     const struct security_descriptor *sd )
 {
 #ifdef HAVE_SYS_EVENTFD_H
@@ -188,8 +188,13 @@ static struct esync *create_esync( struct object *root, const struct unicode_str
     {
         if (get_error() != STATUS_OBJECT_NAME_EXISTS)
         {
+            int flags = EFD_CLOEXEC | EFD_NONBLOCK;
+
+            if (type == ESYNC_SEMAPHORE)
+                flags |= EFD_SEMAPHORE;
+
             /* initialize it if it didn't already exist */
-            esync->fd = eventfd( initval, flags | EFD_CLOEXEC | EFD_NONBLOCK );
+            esync->fd = eventfd( initval, flags );
             if (esync->fd == -1)
             {
                 perror( "eventfd" );
@@ -407,7 +412,7 @@ DECL_HANDLER(create_esync)
 
     if (!objattr) return;
 
-    if ((esync = create_esync( root, &name, objattr->attributes, req->initval, req->flags, req->type, sd )))
+    if ((esync = create_esync( root, &name, objattr->attributes, req->initval, req->type, sd )))
     {
         if (get_error() == STATUS_OBJECT_NAME_EXISTS)
             reply->handle = alloc_handle( current->process, esync, req->access, objattr->attributes );
diff --git a/server/protocol.def b/server/protocol.def
index 721df0bd19..29ecd8b1f6 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -3868,7 +3868,6 @@ struct handle_info
 @REQ(create_esync)
     unsigned int access;        /* wanted access rights */
     int          initval;       /* initial value */
-    int          flags;         /* flags (EFD_SEMAPHORE or 0) */
     int          type;          /* type of esync object (see below) */
     VARARG(objattr,object_attributes); /* object attributes */
 @REPLY
diff --git a/server/request.h b/server/request.h
index b3c31367d2..13b5b5f380 100644
--- a/server/request.h
+++ b/server/request.h
@@ -2416,9 +2416,8 @@ C_ASSERT( FIELD_OFFSET(struct terminate_job_request, status) == 16 );
 C_ASSERT( sizeof(struct terminate_job_request) == 24 );
 C_ASSERT( FIELD_OFFSET(struct create_esync_request, access) == 12 );
 C_ASSERT( FIELD_OFFSET(struct create_esync_request, initval) == 16 );
-C_ASSERT( FIELD_OFFSET(struct create_esync_request, flags) == 20 );
-C_ASSERT( FIELD_OFFSET(struct create_esync_request, type) == 24 );
-C_ASSERT( sizeof(struct create_esync_request) == 32 );
+C_ASSERT( FIELD_OFFSET(struct create_esync_request, type) == 20 );
+C_ASSERT( sizeof(struct create_esync_request) == 24 );
 C_ASSERT( FIELD_OFFSET(struct create_esync_reply, handle) == 8 );
 C_ASSERT( FIELD_OFFSET(struct create_esync_reply, type) == 12 );
 C_ASSERT( FIELD_OFFSET(struct create_esync_reply, shm_idx) == 16 );
diff --git a/server/trace.c b/server/trace.c
index c06ae1a674..7a5e2060ec 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -4545,7 +4545,6 @@ static void dump_create_esync_request( const struct create_esync_request *req )
 {
     fprintf( stderr, " access=%08x", req->access );
     fprintf( stderr, ", initval=%d", req->initval );
-    fprintf( stderr, ", flags=%d", req->flags );
     fprintf( stderr, ", type=%d", req->type );
     dump_varargs_object_attributes( ", objattr=", cur_size );
 }
-- 
2.20.1


From d38ddda257a6b404d01b5fcb402300e0e2432629 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 29 Jul 2018 16:50:08 -0500
Subject: [PATCH 78/83] ntdll, server: Initialize the shared memory portion on
 the server side.

Simply using a CS only prevents this race within one process.
---
 dlls/ntdll/esync.c             | 100 +++---------------------
 include/wine/server_protocol.h |   4 +-
 server/esync.c                 | 135 ++++++++++++++++++++++-----------
 server/protocol.def            |   1 +
 server/request.h               |   3 +-
 server/trace.c                 |   1 +
 6 files changed, 107 insertions(+), 137 deletions(-)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index e3434e78f2..f678ae8483 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -109,7 +109,7 @@ static int shm_addrs_size;  /* length of the allocated shm_addrs array */
 static long pagesize;
 
 static NTSTATUS create_esync( enum esync_type type, HANDLE *handle,
-    ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr, int initval );
+    ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr, int initval, int max );
 
 void esync_init(void)
 {
@@ -121,7 +121,7 @@ void esync_init(void)
         HANDLE handle;
         NTSTATUS ret;
 
-        ret = create_esync( 0, &handle, 0, NULL, 0 );
+        ret = create_esync( 0, &handle, 0, NULL, 0, 0 );
         if (ret != STATUS_NOT_IMPLEMENTED)
         {
             ERR("Server is running with WINEESYNC but this process is not, please enable WINEESYNC or restart wineserver.\n");
@@ -320,7 +320,7 @@ NTSTATUS esync_close( HANDLE handle )
 }
 
 static NTSTATUS create_esync( enum esync_type type, HANDLE *handle,
-    ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr, int initval )
+    ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr, int initval, int max )
 {
     NTSTATUS ret;
     data_size_t len;
@@ -340,6 +340,7 @@ static NTSTATUS create_esync( enum esync_type type, HANDLE *handle,
         req->access  = access;
         req->initval = initval;
         req->type    = type;
+        req->max     = max;
         wine_server_add_data( req, objattr, len );
         ret = wine_server_call( req );
         if (!ret || ret == STATUS_OBJECT_NAME_EXISTS)
@@ -404,60 +405,21 @@ static NTSTATUS open_esync( enum esync_type type, HANDLE *handle,
     return ret;
 }
 
-RTL_CRITICAL_SECTION shm_init_section;
-static RTL_CRITICAL_SECTION_DEBUG critsect_debug =
-{
-    0, 0, &shm_init_section,
-    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
-      0, 0, { (DWORD_PTR)(__FILE__ ": shm_init_section") }
-};
-RTL_CRITICAL_SECTION shm_init_section = { &critsect_debug, -1, 0, 0, 0, 0 };
-
 NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, LONG initial, LONG max)
 {
-    NTSTATUS ret;
-
     TRACE("name %s, initial %d, max %d.\n",
         attr ? debugstr_us(attr->ObjectName) : "<no name>", initial, max);
 
-    /* We need this lock to protect against a potential (though unlikely) race:
-     * if a different process tries to open a named object and manages to use
-     * it between the time we get back from the server and the time we
-     * initialize the shared memory, it'll have uninitialized values for the
-     * object's state. That requires us to be REALLY slow, but we're not taking
-     * any chances. Synchronize on the CS here so that we're sure to be ready
-     * before anyone else can open the object. */
-    RtlEnterCriticalSection( &shm_init_section );
-
-    ret = create_esync( ESYNC_SEMAPHORE, handle, access, attr, initial );
-    if (!ret)
-    {
-        /* Initialize the shared memory portion.
-         * Note we store max here (even though we don't need to) just to keep
-         * it the same size as the mutex's shm portion. */
-        struct esync *obj = get_cached_object( *handle );
-        struct semaphore *semaphore = obj->shm;
-        semaphore->max = max;
-        semaphore->count = initial;
-    }
-
-    RtlLeaveCriticalSection( &shm_init_section );
-
-    return ret;
+    return create_esync( ESYNC_SEMAPHORE, handle, access, attr, initial, max );
 }
 
 NTSTATUS esync_open_semaphore( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr )
 {
-    NTSTATUS ret;
-
     TRACE("name %s.\n", debugstr_us(attr->ObjectName));
 
-    RtlEnterCriticalSection( &shm_init_section );
-    ret = open_esync( ESYNC_SEMAPHORE, handle, access, attr );
-    RtlLeaveCriticalSection( &shm_init_section );
-    return ret;
+    return open_esync( ESYNC_SEMAPHORE, handle, access, attr );
 }
 
 NTSTATUS esync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev )
@@ -523,41 +485,20 @@ NTSTATUS esync_create_event( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, EVENT_TYPE event_type, BOOLEAN initial )
 {
     enum esync_type type = (event_type == SynchronizationEvent ? ESYNC_AUTO_EVENT : ESYNC_MANUAL_EVENT);
-    NTSTATUS ret;
 
     TRACE("name %s, %s-reset, initial %d.\n",
         attr ? debugstr_us(attr->ObjectName) : "<no name>",
         event_type == NotificationEvent ? "manual" : "auto", initial);
 
-    RtlEnterCriticalSection( &shm_init_section );
-
-    ret = create_esync( type, handle, access, attr, initial );
-
-    if (!ret)
-    {
-        /* Initialize the shared memory portion. */
-        struct esync *obj = get_cached_object( *handle );
-        struct event *event = obj->shm;
-        event->signaled = initial;
-        event->locked = 0;
-    }
-
-    RtlLeaveCriticalSection( &shm_init_section );
-
-    return ret;
+    return create_esync( type, handle, access, attr, initial, 0 );
 }
 
 NTSTATUS esync_open_event( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr )
 {
-    NTSTATUS ret;
-
     TRACE("name %s.\n", debugstr_us(attr->ObjectName));
 
-    RtlEnterCriticalSection( &shm_init_section );
-    ret = open_esync( ESYNC_AUTO_EVENT, handle, access, attr ); /* doesn't matter which */
-    RtlLeaveCriticalSection( &shm_init_section );
-    return ret;
+    return open_esync( ESYNC_AUTO_EVENT, handle, access, attr ); /* doesn't matter which */
 }
 
 static inline void small_pause(void)
@@ -721,39 +662,18 @@ NTSTATUS esync_query_event( HANDLE handle, EVENT_INFORMATION_CLASS class,
 NTSTATUS esync_create_mutex( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, BOOLEAN initial )
 {
-    NTSTATUS ret;
-
     TRACE("name %s, initial %d.\n",
         attr ? debugstr_us(attr->ObjectName) : "<no name>", initial);
 
-    RtlEnterCriticalSection( &shm_init_section );
-
-    ret = create_esync( ESYNC_MUTEX, handle, access, attr, initial ? 0 : 1 );
-    if (!ret)
-    {
-        /* Initialize the shared memory portion. */
-        struct esync *obj = get_cached_object( *handle );
-        struct mutex *mutex = obj->shm;
-        mutex->tid = initial ? GetCurrentThreadId() : 0;
-        mutex->count = initial ? 1 : 0;
-    }
-
-    RtlLeaveCriticalSection( &shm_init_section );
-
-    return ret;
+    return create_esync( ESYNC_MUTEX, handle, access, attr, initial ? 0 : 1, 0 );
 }
 
 NTSTATUS esync_open_mutex( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr )
 {
-    NTSTATUS ret;
-
     TRACE("name %s.\n", debugstr_us(attr->ObjectName));
 
-    RtlEnterCriticalSection( &shm_init_section );
-    ret = open_esync( ESYNC_MUTEX, handle, access, attr );
-    RtlLeaveCriticalSection( &shm_init_section );
-    return ret;
+    return open_esync( ESYNC_MUTEX, handle, access, attr );
 }
 
 NTSTATUS esync_release_mutex( HANDLE *handle, LONG *prev )
diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index c234015adc..7429b1cd73 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -5671,7 +5671,9 @@ struct create_esync_request
     unsigned int access;
     int          initval;
     int          type;
+    int          max;
     /* VARARG(objattr,object_attributes); */
+    char __pad_28[4];
 };
 struct create_esync_reply
 {
@@ -6639,6 +6641,6 @@ union generic_reply
     struct get_esync_apc_fd_reply get_esync_apc_fd_reply;
 };
 
-#define SERVER_PROTOCOL_VERSION 575
+#define SERVER_PROTOCOL_VERSION 576
 
 #endif /* __WINE_WINE_SERVER_PROTOCOL_H */
diff --git a/server/esync.c b/server/esync.c
index 3e78387e88..35e7a8a1fe 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -177,8 +177,63 @@ static int type_matches( enum esync_type type1, enum esync_type type2 )
             (type2 == ESYNC_AUTO_EVENT || type2 == ESYNC_MANUAL_EVENT));
 }
 
+static void *get_shm( unsigned int idx )
+{
+    int entry  = (idx * 8) / pagesize;
+    int offset = (idx * 8) % pagesize;
+
+    if (entry >= shm_addrs_size)
+    {
+        if (!(shm_addrs = realloc( shm_addrs, (entry + 1) * sizeof(shm_addrs[0]) )))
+            fprintf( stderr, "esync: couldn't expand shm_addrs array to size %d\n", entry + 1 );
+
+        memset( &shm_addrs[shm_addrs_size], 0, (entry + 1 - shm_addrs_size) * sizeof(shm_addrs[0]) );
+
+        shm_addrs_size = entry + 1;
+    }
+
+    if (!shm_addrs[entry])
+    {
+        void *addr = mmap( NULL, pagesize, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, entry * pagesize );
+        if (addr == (void *)-1)
+        {
+            fprintf( stderr, "esync: failed to map page %d (offset %#lx): ", entry, entry * pagesize );
+            perror( "mmap" );
+        }
+
+        if (debug_level)
+            fprintf( stderr, "esync: Mapping page %d at %p.\n", entry, addr );
+
+        if (interlocked_cmpxchg_ptr( &shm_addrs[entry], addr, 0 ))
+            munmap( addr, pagesize ); /* someone beat us to it */
+    }
+
+    return (void *)((unsigned long)shm_addrs[entry] + offset);
+}
+
+struct semaphore
+{
+    int max;
+    int count;
+};
+C_ASSERT(sizeof(struct semaphore) == 8);
+
+struct mutex
+{
+    DWORD tid;
+    int count;    /* recursion count */
+};
+C_ASSERT(sizeof(struct mutex) == 8);
+
+struct event
+{
+    int signaled;
+    int locked;
+};
+C_ASSERT(sizeof(struct event) == 8);
+
 static struct esync *create_esync( struct object *root, const struct unicode_str *name,
-    unsigned int attr, int initval, enum esync_type type,
+    unsigned int attr, int initval, int max, enum esync_type type,
     const struct security_descriptor *sd )
 {
 #ifdef HAVE_SYS_EVENTFD_H
@@ -218,6 +273,38 @@ static struct esync *create_esync( struct object *root, const struct unicode_str
                     perror( "ftruncate" );
                 }
             }
+
+            /* Initialize the shared memory portion. We want to do this on the
+             * server side to avoid a potential though unlikely race whereby
+             * the same object is opened and used between the time it's created
+             * and the time its shared memory portion is initialized. */
+            switch (type)
+            {
+            case ESYNC_SEMAPHORE:
+            {
+                struct semaphore *semaphore = get_shm( esync->shm_idx );
+                semaphore->max = max;
+                semaphore->count = initval;
+                break;
+            }
+            case ESYNC_AUTO_EVENT:
+            case ESYNC_MANUAL_EVENT:
+            {
+                struct event *event = get_shm( esync->shm_idx );
+                event->signaled = initval ? 1 : 0;
+                event->locked = 0;
+                break;
+            }
+            case ESYNC_MUTEX:
+            {
+                struct mutex *mutex = get_shm( esync->shm_idx );
+                mutex->tid = initval ? 0 : current->id;
+                mutex->count = initval ? 0 : 1;
+                break;
+            }
+            default:
+                assert( 0 );
+            }
         }
         else
         {
@@ -286,49 +373,6 @@ void esync_clear( int fd )
     read( fd, &value, sizeof(value) );
 }
 
-/* Sadly, we need all of this infrastructure to keep the shm state in sync. */
-
-static void *get_shm( unsigned int idx )
-{
-    int entry  = (idx * 8) / pagesize;
-    int offset = (idx * 8) % pagesize;
-
-    if (entry >= shm_addrs_size)
-    {
-        if (!(shm_addrs = realloc( shm_addrs, (entry + 1) * sizeof(shm_addrs[0]) )))
-            fprintf( stderr, "esync: couldn't expand shm_addrs array to size %d\n", entry + 1 );
-
-        memset( &shm_addrs[shm_addrs_size], 0, (entry + 1 - shm_addrs_size) * sizeof(shm_addrs[0]) );
-
-        shm_addrs_size = entry + 1;
-    }
-
-    if (!shm_addrs[entry])
-    {
-        void *addr = mmap( NULL, pagesize, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, entry * pagesize );
-        if (addr == (void *)-1)
-        {
-            fprintf( stderr, "esync: failed to map page %d (offset %#lx): ", entry, entry * pagesize );
-            perror( "mmap" );
-        }
-
-        if (debug_level)
-            fprintf( stderr, "esync: Mapping page %d at %p.\n", entry, addr );
-
-        if (interlocked_cmpxchg_ptr( &shm_addrs[entry], addr, 0 ))
-            munmap( addr, pagesize ); /* someone beat us to it */
-    }
-
-    return (void *)((unsigned long)shm_addrs[entry] + offset);
-}
-
-struct event
-{
-    int signaled;
-    int locked;
-};
-C_ASSERT(sizeof(struct event) == 8);
-
 static inline void small_pause(void)
 {
 #ifdef __i386__
@@ -412,7 +456,8 @@ DECL_HANDLER(create_esync)
 
     if (!objattr) return;
 
-    if ((esync = create_esync( root, &name, objattr->attributes, req->initval, req->type, sd )))
+    if ((esync = create_esync( root, &name, objattr->attributes, req->initval,
+        req->max, req->type, sd )))
     {
         if (get_error() == STATUS_OBJECT_NAME_EXISTS)
             reply->handle = alloc_handle( current->process, esync, req->access, objattr->attributes );
diff --git a/server/protocol.def b/server/protocol.def
index 29ecd8b1f6..0a5088f2dd 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -3869,6 +3869,7 @@ struct handle_info
     unsigned int access;        /* wanted access rights */
     int          initval;       /* initial value */
     int          type;          /* type of esync object (see below) */
+    int          max;           /* maximum count on a semaphore */
     VARARG(objattr,object_attributes); /* object attributes */
 @REPLY
     obj_handle_t handle;        /* handle to the object */
diff --git a/server/request.h b/server/request.h
index 13b5b5f380..e470ccbb4a 100644
--- a/server/request.h
+++ b/server/request.h
@@ -2417,7 +2417,8 @@ C_ASSERT( sizeof(struct terminate_job_request) == 24 );
 C_ASSERT( FIELD_OFFSET(struct create_esync_request, access) == 12 );
 C_ASSERT( FIELD_OFFSET(struct create_esync_request, initval) == 16 );
 C_ASSERT( FIELD_OFFSET(struct create_esync_request, type) == 20 );
-C_ASSERT( sizeof(struct create_esync_request) == 24 );
+C_ASSERT( FIELD_OFFSET(struct create_esync_request, max) == 24 );
+C_ASSERT( sizeof(struct create_esync_request) == 32 );
 C_ASSERT( FIELD_OFFSET(struct create_esync_reply, handle) == 8 );
 C_ASSERT( FIELD_OFFSET(struct create_esync_reply, type) == 12 );
 C_ASSERT( FIELD_OFFSET(struct create_esync_reply, shm_idx) == 16 );
diff --git a/server/trace.c b/server/trace.c
index 7a5e2060ec..db420781e7 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -4546,6 +4546,7 @@ static void dump_create_esync_request( const struct create_esync_request *req )
     fprintf( stderr, " access=%08x", req->access );
     fprintf( stderr, ", initval=%d", req->initval );
     fprintf( stderr, ", type=%d", req->type );
+    fprintf( stderr, ", max=%d", req->max );
     dump_varargs_object_attributes( ", objattr=", cur_size );
 }
 
-- 
2.20.1


From 07d9c8aa44e8bd8fa23a8030986f72e0bdc2a17b Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 13 Aug 2018 21:35:06 -0500
Subject: [PATCH 79/83] ntdll, server: Revert to old implementation of hung
 queue detection.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

By manually notifying the server every time we enter and exit a message wait.

The hung queue logic keeps breaking. In the case of bug #9 it was breaking
because we were waiting for more than 5 seconds on our queue and then someone
sent us a message with SMTO_ABORTIFHUNG. Just stop fighting against the
server and try to coperate with it instead. It takes two extra server calls,
but ideally the GUI thread isn't going to be in the same sort of performance-
critical code that this patchset was written for.
---
 dlls/ntdll/esync.c             | 53 +++++++++++++++++++++++++---------
 include/wine/server_protocol.h | 16 +++++++++-
 server/protocol.def            |  6 +++-
 server/queue.c                 | 35 +++++++++++++++++-----
 server/request.h               |  5 +++-
 server/trace.c                 |  8 +++++
 6 files changed, 100 insertions(+), 23 deletions(-)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index f678ae8483..0ca8896202 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -812,8 +812,8 @@ static void update_grabbed_object( struct esync *obj )
 
 /* A value of STATUS_NOT_IMPLEMENTED returned from this function means that we
  * need to delegate to server_select(). */
-NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
-                             BOOLEAN alertable, const LARGE_INTEGER *timeout )
+static NTSTATUS __esync_wait_objects( DWORD count, const HANDLE *handles,
+    BOOLEAN wait_any, BOOLEAN alertable, const LARGE_INTEGER *timeout )
 {
     static const LARGE_INTEGER zero = {0};
 
@@ -876,22 +876,11 @@ NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
 
     if (objs[count - 1] && objs[count - 1]->type == ESYNC_QUEUE)
     {
-        select_op_t select_op;
-
         /* Last object in the list is a queue, which means someone is using
          * MsgWaitForMultipleObjects(). We have to wait not only for the server
          * fd (signaled on send_message, etc.) but also the USER driver's fd
          * (signaled on e.g. X11 events.) */
         msgwait = TRUE;
-
-        /* We need to let the server know we are doing a message wait, for two
-         * reasons. First one is WaitForInputIdle(). Second one is checking for
-         * hung queues. Do it like this. */
-        select_op.wait.op = SELECT_WAIT;
-        select_op.wait.handles[0] = wine_server_obj_handle( handles[count - 1] );
-        ret = server_select( &select_op, offsetof( select_op_t, wait.handles[1] ), 0, &zero );
-        if (ret != STATUS_WAIT_0 && ret != STATUS_TIMEOUT)
-            ERR("Unexpected ret %#x\n", ret);
     }
 
     if (has_esync && has_server)
@@ -1263,6 +1252,44 @@ userapc:
     return ret;
 }
 
+/* We need to let the server know when we are doing a message wait, and when we
+ * are done with one, so that all of the code surrounding hung queues works.
+ * We also need this for WaitForInputIdle(). */
+static void server_set_msgwait( int in_msgwait )
+{
+    SERVER_START_REQ( esync_msgwait )
+    {
+        req->in_msgwait = in_msgwait;
+        wine_server_call( req );
+    }
+    SERVER_END_REQ;
+}
+
+/* This is a very thin wrapper around the proper implementation above. The
+ * purpose is to make sure the server knows when we are doing a message wait.
+ * This is separated into a wrapper function since there are at least a dozen
+ * exit paths from esync_wait_objects(). */
+NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
+                             BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    BOOL msgwait = FALSE;
+    struct esync *obj;
+    NTSTATUS ret;
+
+    if (!get_object( handles[count - 1], &obj ) && obj->type == ESYNC_QUEUE)
+    {
+        msgwait = TRUE;
+        server_set_msgwait( 1 );
+    }
+
+    ret = __esync_wait_objects( count, handles, wait_any, alertable, timeout );
+
+    if (msgwait)
+        server_set_msgwait( 0 );
+
+    return ret;
+}
+
 NTSTATUS esync_signal_and_wait( HANDLE signal, HANDLE wait, BOOLEAN alertable,
     const LARGE_INTEGER *timeout )
 {
diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index 7429b1cd73..c3c175de81 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -5728,6 +5728,17 @@ struct get_esync_apc_fd_reply
     struct reply_header __header;
 };
 
+
+struct esync_msgwait_request
+{
+    struct request_header __header;
+    int          in_msgwait;
+};
+struct esync_msgwait_reply
+{
+    struct reply_header __header;
+};
+
 enum esync_type
 {
     ESYNC_SEMAPHORE = 1,
@@ -6037,6 +6048,7 @@ enum request
     REQ_open_esync,
     REQ_get_esync_fd,
     REQ_get_esync_apc_fd,
+    REQ_esync_msgwait,
     REQ_NB_REQUESTS
 };
 
@@ -6339,6 +6351,7 @@ union generic_request
     struct open_esync_request open_esync_request;
     struct get_esync_fd_request get_esync_fd_request;
     struct get_esync_apc_fd_request get_esync_apc_fd_request;
+    struct esync_msgwait_request esync_msgwait_request;
 };
 union generic_reply
 {
@@ -6639,8 +6652,9 @@ union generic_reply
     struct open_esync_reply open_esync_reply;
     struct get_esync_fd_reply get_esync_fd_reply;
     struct get_esync_apc_fd_reply get_esync_apc_fd_reply;
+    struct esync_msgwait_reply esync_msgwait_reply;
 };
 
-#define SERVER_PROTOCOL_VERSION 576
+#define SERVER_PROTOCOL_VERSION 577
 
 #endif /* __WINE_WINE_SERVER_PROTOCOL_H */
diff --git a/server/protocol.def b/server/protocol.def
index 0a5088f2dd..1800591676 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -3900,7 +3900,11 @@ struct handle_info
 
 /* Retrieve the fd to wait on for user APCs. */
 @REQ(get_esync_apc_fd)
-@REPLY
+@END
+
+/* Notify the server that we are doing a message wait (or done with one). */
+@REQ(esync_msgwait)
+    int          in_msgwait;    /* are we in a message wait? */
 @END
 
 enum esync_type
diff --git a/server/queue.c b/server/queue.c
index 2a9d70c137..db812af57f 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -142,6 +142,7 @@ struct msg_queue
     struct hook_table     *hooks;           /* hook table */
     timeout_t              last_get_msg;    /* time of last get message call */
     int                    esync_fd;        /* esync file descriptor (signalled on message) */
+    int                    esync_in_msgwait; /* our thread is currently waiting on us */
 };
 
 struct hotkey
@@ -910,7 +911,21 @@ static void cleanup_results( struct msg_queue *queue )
 /* check if the thread owning the queue is hung (not checking for messages) */
 static int is_queue_hung( struct msg_queue *queue )
 {
-    return (current_time - queue->last_get_msg > 5 * TICKS_PER_SEC);
+    struct wait_queue_entry *entry;
+
+    if (current_time - queue->last_get_msg <= 5 * TICKS_PER_SEC)
+        return 0;  /* less than 5 seconds since last get message -> not hung */
+
+    LIST_FOR_EACH_ENTRY( entry, &queue->obj.wait_queue, struct wait_queue_entry, entry )
+    {
+        if (get_wait_queue_thread(entry)->queue == queue)
+            return 0;  /* thread is waiting on queue -> not hung */
+    }
+
+    if (do_esync() && queue->esync_in_msgwait)
+        return 0;   /* thread is waiting on queue in absentia -> not hung */
+
+    return 1;
 }
 
 static int msg_queue_add_queue( struct object *obj, struct wait_queue_entry *entry )
@@ -926,12 +941,6 @@ static int msg_queue_add_queue( struct object *obj, struct wait_queue_entry *ent
     }
     if (process->idle_event && !(queue->wake_mask & QS_SMRESULT)) set_event( process->idle_event );
 
-    /* On Windows, we are considered hung iff we have not somehow processed
-     * messages OR done a MsgWait call in the last 5 seconds. Note that in the
-     * latter case repeatedly waiting for 0 seconds is not hung, but waiting
-     * forever is hung, so this is correct. */
-    queue->last_get_msg = current_time;
-
     if (queue->fd && list_empty( &obj->wait_queue ))  /* first on the queue */
         set_fd_events( queue->fd, POLLIN );
     add_queue( obj, entry );
@@ -1577,6 +1586,7 @@ static int send_hook_ll_message( struct desktop *desktop, struct message *hardwa
 
     if (!(hook_thread = get_first_global_hook( id ))) return 0;
     if (!(queue = hook_thread->queue)) return 0;
+    if (is_queue_hung( queue )) return 0;
 
     if (!(msg = mem_alloc( sizeof(*msg) ))) return 0;
 
@@ -3141,3 +3151,14 @@ DECL_HANDLER(update_rawinput_devices)
     e = find_rawinput_device( 1, 6 );
     current->process->rawinput_kbd   = e ? &e->device : NULL;
 }
+
+DECL_HANDLER(esync_msgwait)
+{
+    struct msg_queue *queue = get_current_queue();
+
+    if (!queue) return;
+    queue->esync_in_msgwait = req->in_msgwait;
+
+    if (current->process->idle_event && !(queue->wake_mask & QS_SMRESULT))
+        set_event( current->process->idle_event );
+}
diff --git a/server/request.h b/server/request.h
index e470ccbb4a..1da634bad9 100644
--- a/server/request.h
+++ b/server/request.h
@@ -407,6 +407,7 @@ DECL_HANDLER(create_esync);
 DECL_HANDLER(open_esync);
 DECL_HANDLER(get_esync_fd);
 DECL_HANDLER(get_esync_apc_fd);
+DECL_HANDLER(esync_msgwait);
 
 #ifdef WANT_REQUEST_HANDLERS
 
@@ -708,6 +709,7 @@ static const req_handler req_handlers[REQ_NB_REQUESTS] =
     (req_handler)req_open_esync,
     (req_handler)req_get_esync_fd,
     (req_handler)req_get_esync_apc_fd,
+    (req_handler)req_esync_msgwait,
 };
 
 C_ASSERT( sizeof(affinity_t) == 8 );
@@ -2438,7 +2440,8 @@ C_ASSERT( FIELD_OFFSET(struct get_esync_fd_reply, type) == 8 );
 C_ASSERT( FIELD_OFFSET(struct get_esync_fd_reply, shm_idx) == 12 );
 C_ASSERT( sizeof(struct get_esync_fd_reply) == 16 );
 C_ASSERT( sizeof(struct get_esync_apc_fd_request) == 16 );
-C_ASSERT( sizeof(struct get_esync_apc_fd_reply) == 8 );
+C_ASSERT( FIELD_OFFSET(struct esync_msgwait_request, in_msgwait) == 12 );
+C_ASSERT( sizeof(struct esync_msgwait_request) == 16 );
 
 #endif  /* WANT_REQUEST_HANDLERS */
 
diff --git a/server/trace.c b/server/trace.c
index db420781e7..5ced043966 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -4588,6 +4588,11 @@ static void dump_get_esync_apc_fd_request( const struct get_esync_apc_fd_request
 {
 }
 
+static void dump_esync_msgwait_request( const struct esync_msgwait_request *req )
+{
+    fprintf( stderr, " in_msgwait=%d", req->in_msgwait );
+}
+
 static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_new_process_request,
     (dump_func)dump_exec_process_request,
@@ -4884,6 +4889,7 @@ static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_open_esync_request,
     (dump_func)dump_get_esync_fd_request,
     (dump_func)dump_get_esync_apc_fd_request,
+    (dump_func)dump_esync_msgwait_request,
 };
 
 static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {
@@ -5182,6 +5188,7 @@ static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_open_esync_reply,
     (dump_func)dump_get_esync_fd_reply,
     NULL,
+    NULL,
 };
 
 static const char * const req_names[REQ_NB_REQUESTS] = {
@@ -5480,6 +5487,7 @@ static const char * const req_names[REQ_NB_REQUESTS] = {
     "open_esync",
     "get_esync_fd",
     "get_esync_apc_fd",
+    "esync_msgwait",
 };
 
 static const struct
-- 
2.20.1


From 2229e112008f780173b163a86e5a3ca4a635a6bf Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Tue, 14 Aug 2018 20:00:54 -0500
Subject: [PATCH 80/83] ntdll: Fix a couple of misplaced global variables.

There's no reason these should be global, and in particular, this means that esync_pulse_event() might end up writing 0, which raises the likelihood of a missed wakeup from "probable" to "certain".

Fixes #10.
---
 dlls/ntdll/esync.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 0ca8896202..304e4981f0 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -585,7 +585,7 @@ NTSTATUS esync_set_event( HANDLE handle )
 
 NTSTATUS esync_reset_event( HANDLE handle )
 {
-    static uint64_t value;
+    uint64_t value;
     struct esync *obj;
     struct event *event;
     NTSTATUS ret;
@@ -614,7 +614,7 @@ NTSTATUS esync_reset_event( HANDLE handle )
 
 NTSTATUS esync_pulse_event( HANDLE handle )
 {
-    static uint64_t value = 1;
+    uint64_t value = 1;
     struct esync *obj;
     NTSTATUS ret;
 
-- 
2.20.1


From c89b1bd4b4c826a388865893f7a065c134f6c1e4 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 19 Aug 2018 12:50:57 -0500
Subject: [PATCH 81/83] ntdll: Yield during PulseEvent().

May help with #10, although the real fix there is just not to use esync.
---
 dlls/ntdll/esync.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 304e4981f0..490522eeb3 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -627,6 +627,11 @@ NTSTATUS esync_pulse_event( HANDLE handle )
      * used (and publicly deprecated). */
     if (write( obj->fd, &value, sizeof(value) ) == -1)
         return FILE_GetNtStatus();
+
+    /* Try to give other threads a chance to wake up. Hopefully erring on this
+     * side is the better thing to do... */
+    NtYieldExecution();
+
     read( obj->fd, &value, sizeof(value) );
 
     return STATUS_SUCCESS;
-- 
2.20.1


From b56fae644368409026c34c5470296d92bb0b7296 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 19 Aug 2018 12:54:33 -0500
Subject: [PATCH 82/83] ntdll, server: Check the value of WINEESYNC instead of
 just the presence.

People keep getting tripped up by this.
---
 dlls/ntdll/esync.c | 2 +-
 server/esync.c     | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/esync.c b/dlls/ntdll/esync.c
index 490522eeb3..a7fee03669 100644
--- a/dlls/ntdll/esync.c
+++ b/dlls/ntdll/esync.c
@@ -57,7 +57,7 @@ int do_esync(void)
     static int do_esync_cached = -1;
 
     if (do_esync_cached == -1)
-        do_esync_cached = (getenv("WINEESYNC") != NULL);
+        do_esync_cached = getenv("WINEESYNC") && atoi(getenv("WINEESYNC"));
 
     return do_esync_cached;
 #else
diff --git a/server/esync.c b/server/esync.c
index 35e7a8a1fe..c414163120 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -52,7 +52,7 @@ int do_esync(void)
     static int do_esync_cached = -1;
 
     if (do_esync_cached == -1)
-        do_esync_cached = (getenv("WINEESYNC") != NULL);
+        do_esync_cached = getenv("WINEESYNC") && atoi(getenv("WINEESYNC"));
 
     return do_esync_cached;
 #else
-- 
2.20.1


From 15e70e0672ab2c42f12051be015e23aa7761c429 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 19 Aug 2018 13:40:05 -0500
Subject: [PATCH 83/83] esync: Update README.

---
 README.esync | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/README.esync b/README.esync
index b64bfefc1a..11d86563a1 100644
--- a/README.esync
+++ b/README.esync
@@ -1,6 +1,5 @@
 This is eventfd-based synchronization, or 'esync' for short. Turn it on with
-WINEESYNC=1 (note that it checks the presence and not the value); debug it
-with +esync.
+WINEESYNC=1; debug it with +esync.
 
 == BUGS AND LIMITATIONS ==
 
-- 
2.20.1

